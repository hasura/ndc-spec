<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hasura Data Connectors Developer&#x27;s Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">API Specification</li><li class="chapter-item expanded "><a href="specification/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="specification/changelog.html"><strong aria-hidden="true">2.</strong> Changelog</a></li><li class="chapter-item expanded "><a href="specification/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="specification/versioning.html"><strong aria-hidden="true">4.</strong> Versioning</a></li><li class="chapter-item expanded "><a href="specification/error-handling.html"><strong aria-hidden="true">5.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="specification/health.html"><strong aria-hidden="true">6.</strong> Service Health</a></li><li class="chapter-item expanded "><a href="specification/metrics.html"><strong aria-hidden="true">7.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="specification/telemetry.html"><strong aria-hidden="true">8.</strong> Telemetry</a></li><li class="chapter-item expanded "><a href="specification/capabilities.html"><strong aria-hidden="true">9.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="specification/types.html"><strong aria-hidden="true">10.</strong> Types</a></li><li class="chapter-item expanded "><a href="specification/schema/index.html"><strong aria-hidden="true">11.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/schema/scalar-types.html"><strong aria-hidden="true">11.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="specification/schema/object-types.html"><strong aria-hidden="true">11.2.</strong> Object Types</a></li><li class="chapter-item expanded "><a href="specification/schema/collections.html"><strong aria-hidden="true">11.3.</strong> Collections</a></li><li class="chapter-item expanded "><a href="specification/schema/functions.html"><strong aria-hidden="true">11.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="specification/schema/procedures.html"><strong aria-hidden="true">11.5.</strong> Procedures</a></li><li class="chapter-item expanded "><a href="specification/schema/capabilities.html"><strong aria-hidden="true">11.6.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="specification/schema/arguments.html"><strong aria-hidden="true">11.7.</strong> Request-level arguments</a></li></ol></li><li class="chapter-item expanded "><a href="specification/queries/index.html"><strong aria-hidden="true">12.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/queries/field-selection.html"><strong aria-hidden="true">12.1.</strong> Field Selection</a></li><li class="chapter-item expanded "><a href="specification/queries/filtering.html"><strong aria-hidden="true">12.2.</strong> Filtering</a></li><li class="chapter-item expanded "><a href="specification/queries/sorting.html"><strong aria-hidden="true">12.3.</strong> Sorting</a></li><li class="chapter-item expanded "><a href="specification/queries/pagination.html"><strong aria-hidden="true">12.4.</strong> Pagination</a></li><li class="chapter-item expanded "><a href="specification/queries/aggregates.html"><strong aria-hidden="true">12.5.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="specification/queries/grouping.html"><strong aria-hidden="true">12.6.</strong> Grouping</a></li><li class="chapter-item expanded "><a href="specification/queries/arguments.html"><strong aria-hidden="true">12.7.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="specification/queries/relationships.html"><strong aria-hidden="true">12.8.</strong> Relationships</a></li><li class="chapter-item expanded "><a href="specification/queries/variables.html"><strong aria-hidden="true">12.9.</strong> Variables</a></li><li class="chapter-item expanded "><a href="specification/queries/functions.html"><strong aria-hidden="true">12.10.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="specification/mutations/index.html"><strong aria-hidden="true">13.</strong> Mutations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/mutations/procedures.html"><strong aria-hidden="true">13.1.</strong> Procedures</a></li></ol></li><li class="chapter-item expanded "><a href="specification/explain.html"><strong aria-hidden="true">14.</strong> Explain</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">15.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/setup.html"><strong aria-hidden="true">16.</strong> Setup</a></li><li class="chapter-item expanded "><a href="tutorial/testing.html"><strong aria-hidden="true">17.</strong> Testing</a></li><li class="chapter-item expanded "><a href="tutorial/getting-started.html"><strong aria-hidden="true">18.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="tutorial/capabilities.html"><strong aria-hidden="true">19.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="tutorial/schema.html"><strong aria-hidden="true">20.</strong> Schema</a></li><li class="chapter-item expanded "><a href="tutorial/queries/index.html"><strong aria-hidden="true">21.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/queries/variables.html"><strong aria-hidden="true">21.1.</strong> Query Variables</a></li><li class="chapter-item expanded "><a href="tutorial/queries/arguments.html"><strong aria-hidden="true">21.2.</strong> Evaluating Arguments</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/index.html"><strong aria-hidden="true">21.3.</strong> Executing Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/queries/execute/sorting.html"><strong aria-hidden="true">21.3.1.</strong> Sorting</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/filtering.html"><strong aria-hidden="true">21.3.2.</strong> Filtering</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/pagination.html"><strong aria-hidden="true">21.3.3.</strong> Pagination</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/aggregates.html"><strong aria-hidden="true">21.3.4.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/field-selection.html"><strong aria-hidden="true">21.3.5.</strong> Field Selection</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/grouping.html"><strong aria-hidden="true">21.3.6.</strong> Grouping</a></li><li class="chapter-item expanded "><a href="tutorial/queries/execute/relationships.html"><strong aria-hidden="true">21.3.7.</strong> Relationships</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tutorial/mutations/index.html"><strong aria-hidden="true">22.</strong> Mutations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/mutations/operations.html"><strong aria-hidden="true">22.1.</strong> Handling Operations</a></li><li class="chapter-item expanded "><a href="tutorial/mutations/procedures.html"><strong aria-hidden="true">22.2.</strong> Procedures</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/explain.html"><strong aria-hidden="true">23.</strong> Explain</a></li><li class="chapter-item expanded "><a href="tutorial/health.html"><strong aria-hidden="true">24.</strong> Health and Metrics</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/types.html"><strong aria-hidden="true">25.</strong> Types</a></li><li class="chapter-item expanded "><a href="reference/json-schema.html"><strong aria-hidden="true">26.</strong> JSON Schema</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hasura Data Connectors Developer&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<div class="warning">
<p><b>NOTE</b></p>
<p>This specification contains the low-level details for connector authors, and is intended as a complete reference.</p>
<p>Users looking to build their own connectors might want to also look at some additional resources:</p>
<ul>
<li><a href="https://hasura.io/connectors">Hasura Connector Hub</a> contains a list of currently available connectors</li>
<li><a href="https://hasura.io/learn/graphql/hasura-v3-ts-connector/introduction/">Let's Build a Connector</a> is a step-by-step to creating a connector using TypeScript</li>
</ul>
</div>
<hr />
<p>Hasura data connectors allow you to extend the functionality of the Hasura server by providing web services which can resolve new sources of data. By following this specification, those sources of data can be added to your Hasura graph, and the usual Hasura features such as relationships and permissions will be supported for your data source.</p>
<p>This specification is designed to be as general as possible, supporting many different types of data source, while still being targeted enough to provide useful features with high performance guarantees. It is important to note that data connectors are designed for tabular data which supports efficient filtering and sorting. If you are able to model your data source given these constraints, then it will be a good fit for a data connector, but if not, you might like to consider a GraphQL remote source integration with Hasura instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-specification"><a class="header" href="#api-specification">API Specification</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Version</th></tr></thead><tbody>
<tr><td><code>0.2.5</code></td></tr>
</tbody></table>
</div>
<p>A data connector encapsulates a data source by implementing the protocol in this specification.</p>
<p>A data connector must implement several web service endpoints:</p>
<ul>
<li>A <strong>capabilities</strong> endpoint, which describes which features the data source is capable of implementing.</li>
<li>A <strong>schema</strong> endpoint, which describes the resources provided by the data source, and the shape of the data they contain.</li>
<li>A <strong>query</strong> endpoint, which reads data from one of the relations described by the schema endpoint.</li>
<li>A <strong>query/explain</strong> endpoint, which explains a query plan, without actually executing it.</li>
<li>A <strong>mutation</strong> endpoint, which modifies the data in one of the relations described by the schema endpoint.</li>
<li>A <strong>mutation/explain</strong> endpoint, which explains a mutation plan, without actually executing it.</li>
<li>A <strong>metrics</strong> endpoint, which exposes runtime metrics about the data connector.</li>
<li>A <strong>health</strong> endpoint, which indicates service health and readiness</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h2 id="025"><a class="header" href="#025"><code>0.2.5</code></a></h2>
<h3 id="specification"><a class="header" href="#specification">Specification</a></h3>
<ul>
<li>Support new aggregate functions <code>stddev</code>, <code>stddev_pop</code>, <code>array_agg</code>, <code>approx_distinct</code> and <code>approx_percentile_cont</code> in relational queries.</li>
</ul>
<h3 id="bug-fixes"><a class="header" href="#bug-fixes">Bug Fixes</a></h3>
<ul>
<li>Make request_arguments argument optional</li>
</ul>
<h2 id="024"><a class="header" href="#024"><code>0.2.4</code></a></h2>
<h3 id="specification-1"><a class="header" href="#specification-1">Specification</a></h3>
<ul>
<li>Add request-level arguments</li>
</ul>
<h3 id="ndc-test"><a class="header" href="#ndc-test"><code>ndc-test</code></a></h3>
<ul>
<li>Check empty <code>and</code>/<code>or</code> predicates</li>
</ul>
<h2 id="023"><a class="header" href="#023"><code>0.2.3</code></a></h2>
<h3 id="specification-2"><a class="header" href="#specification-2">Specification</a></h3>
<ul>
<li>Updates to relational queries
<ul>
<li>Add arguments to <code>From</code></li>
<li>Support <code>EXTRACT(EPOCH FROM ...)</code></li>
<li>New binary string concatenation operator</li>
<li><code>UNION</code> relations</li>
</ul>
</li>
<li>New relational <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code> operations</li>
</ul>
<h2 id="022"><a class="header" href="#022"><code>0.2.2</code></a></h2>
<h3 id="specification-3"><a class="header" href="#specification-3">Specification</a></h3>
<ul>
<li>New subcapabilities for semi-joins and anti-joins were added to the relational queries capability.</li>
</ul>
<h2 id="021"><a class="header" href="#021"><code>0.2.1</code></a></h2>
<h3 id="specification-4"><a class="header" href="#specification-4">Specification</a></h3>
<ul>
<li>A millisecond standard <a href="specification/./schema/scalar-types.html#extraction-functions">extraction function</a> was added.</li>
<li>New capabilities for relational queries were added.</li>
</ul>
<h3 id="ndc-test-1"><a class="header" href="#ndc-test-1"><code>ndc-test</code></a></h3>
<ul>
<li>Failing tests now display deltas between expected and actual results.</li>
</ul>
<h2 id="020"><a class="header" href="#020"><code>0.2.0</code></a></h2>
<h3 id="breaking-changes"><a class="header" href="#breaking-changes">Breaking Changes</a></h3>
<ul>
<li><code>ComparisonTarget::RootCollectionColumn</code> was removed and replaced by <em>named scopes</em> (<a href="https://github.com/hasura/ndc-spec/blob/36855ff20dcbd7d129427794aee9746b895390af/rfcs/0015-named-scopes.md">RFC</a>)</li>
<li><code>path</code> was removed from <code>ComparisonTarget::Column</code> (<a href="https://github.com/hasura/ndc-spec/blob/36855ff20dcbd7d129427794aee9746b895390af/rfcs/0011-no-paths-in-comparison-target.md">RFC</a>)</li>
<li><code>AggregateFunctionDefinition</code> was changed to an <code>enum</code>, to support <em>standardized aggregate functions</em> (<a href="https://github.com/hasura/ndc-spec/blob/a6610169f72cec6792d5e0830c57254e212b37d9/rfcs/0021-comparison-and-aggregate-meanings.md">RFC</a>)</li>
<li><code>ComparisonValue::Column</code> no longer uses <code>ComparisonTarget</code> to pick the column. Instead, the necessary column and pathing details are inlined onto the enum variant.</li>
<li>Declarations of foreign keys has moved from <code>CollectionInfo</code> to <code>ObjectType</code>. This enables object types nested within a collection's object type to declare foreign keys.</li>
<li>The target column in column mappings can now reference an object-nested field. The target column is now a field path (<code>Vec&lt;FieldName&gt;</code>) instead of just a field (<code>FieldName</code>). Column mappings occur in:
<ul>
<li><code>Relationship::column_mapping</code></li>
<li><code>ForeignKeyConstraint::column_mapping</code></li>
</ul>
</li>
<li>Scalar type representations are now required, and the previously deprecated <code>number</code> and <code>integer</code> representations have been removed.</li>
<li>If the capability <code>query.aggregates</code> is enabled, it is now expected that the new <a href="specification/./schema/capabilities.html">schema property <code>capabilities.query.aggregates</code></a> is also returned.</li>
</ul>
<h3 id="specification-5"><a class="header" href="#specification-5">Specification</a></h3>
<h4 id="grouping"><a class="header" href="#grouping">Grouping</a></h4>
<p>A <a href="specification/./queries/grouping.html">new section was added to the specification</a> which allows callers to group rows and aggregate within groups, generalizing SQL's <code>GROUP BY</code> functionality.</p>
<h4 id="extraction-functions"><a class="header" href="#extraction-functions">Extraction Functions</a></h4>
<p><a href="specification/./schema/scalar-types.html#extraction-functions">Extraction functions</a> were added to the schema response to facilitate <a href="specification/./queries/grouping.html#extraction-functions-and-complex-dimensions">grouping by components of complex dimensions</a>.</p>
<h4 id="named-scopes"><a class="header" href="#named-scopes">Named scopes</a></h4>
<p>Root column references were generalized to <em>named scopes</em>. Scopes are introduced by <code>EXISTS</code> expressions, and named scopes allow <a href="specification/./queries/filtering.html#referencing-a-column-from-a-collection-in-scope">references to columns outside of the current scope</a>; that is, outside the <code>EXISTS</code> expression. Unlike root column references, named scopes allow the caller to refer to columns in any collection in scope, and not just the root collection.</p>
<h4 id="nested-collections"><a class="header" href="#nested-collections">Nested collections</a></h4>
<ul>
<li><code>NestedField::Collection</code> was added to support <a href="specification/./queries/field-selection.html#nested-collections">querying nested collections</a>.</li>
<li>Exists predicates can now <a href="specification/./queries/filtering.html#nested-collections">search nested collections</a>.</li>
</ul>
<h4 id="filtering-involving-nested-scalar-arrays"><a class="header" href="#filtering-involving-nested-scalar-arrays">Filtering involving nested scalar arrays</a></h4>
<p>Nested scalar arrays can now be compared against in filter expressions.</p>
<ul>
<li>Exists predicates can now <a href="specification/./queries/filtering.html#nested-scalar-collections">search nested scalar collections</a></li>
<li>Expressions now have <a href="specification/./queries/filtering.html#nested-array-comparison-operators">nested array comparison operators</a> that can be used to test if a scalar array is empty or if it contains an element</li>
</ul>
<h4 id="filter-by-aggregates"><a class="header" href="#filter-by-aggregates">Filter by aggregates</a></h4>
<p><code>ComparisonTarget</code> was extended to allow <a href="specification/./queries/filtering.html#computing-an-aggregate">filtering by aggregates</a>.</p>
<h4 id="nested-relationships"><a class="header" href="#nested-relationships">Nested relationships</a></h4>
<p>Nested relationships are relationships where the columns being joined upon exist on nested objects within collection's object type. While NDC 0.1.x supports selecting fields across a relationship that starts from within a nested object, it does not support nested relationships in other contexts, such as filtering and ordering. To resolve this, the following additions have been made:</p>
<ul>
<li><code>ExistsInCollection::Related</code> has gained a <code>field_path</code> field that enables descent through nested fields before applying the relationship. This enables support for filtering across a nested relationship.</li>
<li><code>PathElement</code> has also gained a <code>field_path</code> field that enables descent through nested fields before applying the relationship. <code>PathElement</code> is used in multiple places, which unlocks nested relationships in these places:
<ul>
<li><code>ComparisonValue::Column</code> - part of filter predicates; where the right hand side of a comparison operation references a column</li>
<li><code>ComparisonTarget::Aggregate</code> - part of filter predicates; where the left hand side of a comparison operation references an aggregate</li>
<li><code>OrderByTarget::Column</code> - when you want to order by a column across an object relationship</li>
<li><code>OrderByTarget::Aggregate</code> - when you want to order by an aggregate that happens across a nested object relationship</li>
<li><code>Dimension::Column</code> - when selecting a column to group by that occurs across a nested object relationship</li>
</ul>
</li>
</ul>
<p>Column mappings used in relationships were also modified to allow the target column to be referenced via a field path, to allow targeting of object-nested columns across a relationship. Foreign keys are also now defined on the object type rather than the collection, which allows the declaration of foreign keys on object types that are used in nested fields inside a collection.</p>
<p>Nested relationships are now gated behind the <a href="specification/./capabilities.html#capabilities-fields"><code>relationships.nested</code></a> capabilities, and so connectors that do not declare these capabilities can expect to not have to deal with nested relationships.</p>
<h4 id="wider-field-arguments-support"><a class="header" href="#wider-field-arguments-support">Wider field arguments support</a></h4>
<p>Object type fields can declare arguments that must be submitted when the field is evaluated. However, support for using these fields is not universal; there are some features which do not allow the use of fields with arguments, for example in nested field paths, or in relationship column mappings.</p>
<p>Now, support for field arguments has been added to:</p>
<ul>
<li><code>ComparisonTarget::Column</code></li>
<li><code>ComparisonValue::Column</code></li>
<li><code>OrderByTarget::Column</code></li>
<li><code>Aggregate::ColumnCount</code></li>
<li><code>Aggregate::SingleColumn</code></li>
</ul>
<p>However, field arguments are still considered an unstable feature and their use is not recommended outside of very specialized, advanced use cases.</p>
<h4 id="more-standard-comparison-operators-standard-aggregate-functions"><a class="header" href="#more-standard-comparison-operators-standard-aggregate-functions">More standard comparison operators, standard aggregate functions</a></h4>
<p>Standard comparison operators have been added for <a href="specification/./schema/scalar-types.html#less_than-greater_than-less_than_or_equal-greater_than_or_equal"><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&lt;=</code></a>, and string comparisons <a href="specification/./schema/scalar-types.html#contains-icontains-starts_with-istarts_with-ends_with-iends_with"><code>contains</code>, <code>icontains</code>, <code>starts_with</code>, <code>istarts_with</code>, <code>ends_with</code> and <code>ends_with</code></a>. Connectors that have already defined these operators as custom operators should migrate them to standard operators.</p>
<p>In addition, aggregate functions now have a set of <a href="specification/./schema/scalar-types.html#standard-aggregation-functions">standard functions</a> that can be implemented: <code>sum</code>, <code>average</code>, <code>min</code>, <code>max</code>. Connectors that have already defined these functions as custom aggregate functions should migrate them to standard aggregate functions.</p>
<h4 id="x-hasura-ndc-version-header"><a class="header" href="#x-hasura-ndc-version-header"><code>X-Hasura-NDC-Version</code> header</a></h4>
<p>Clients can now <a href="specification/./versioning.html#requirements">indicate the intended protocol version</a> in a HTTP header alongside any request.</p>
<h4 id="scalar-type-representations"><a class="header" href="#scalar-type-representations">Scalar type representations</a></h4>
<p>Scalar type representations are now required; previously they were optional, where a missing representation was assumed to mean JSON. In addition, the deprecated number and integer representations have been removed; a more precise representation (such as float64 or int32) should be chosen instead.</p>
<h4 id="capability-specific-schema-information"><a class="header" href="#capability-specific-schema-information">Capability-specific schema information</a></h4>
<p>Certain capabilities may require specific data to be returned in the schema to support them. This data is now returned in the <a href="specification/./schema/capabilities.html">capabilities property</a> on the schema response.</p>
<p>Specifically, there is a new schema property, <code>capabilities.query.aggregates.count_scalar_type</code>, that defines the result type of all count aggregate functions. This must be returned if the capability <code>query.aggregates</code> is enabled.</p>
<h2 id="016"><a class="header" href="#016"><code>0.1.6</code></a></h2>
<h3 id="specification-6"><a class="header" href="#specification-6">Specification</a></h3>
<ul>
<li><code>EXISTS</code> expressions can now query nested collections</li>
</ul>
<h2 id="015"><a class="header" href="#015"><code>0.1.5</code></a></h2>
<h3 id="rust-libraries"><a class="header" href="#rust-libraries">Rust Libraries</a></h3>
<ul>
<li>Add newtypes for string types</li>
<li>Remove duplication by setting values in the workspace file</li>
<li>Export the specification version from <code>ndc-models</code></li>
</ul>
<h2 id="014"><a class="header" href="#014"><code>0.1.4</code></a></h2>
<h3 id="specification-7"><a class="header" href="#specification-7">Specification</a></h3>
<ul>
<li>Aggregates over nested fields</li>
</ul>
<h3 id="ndc-test-2"><a class="header" href="#ndc-test-2"><code>ndc-test</code></a></h3>
<ul>
<li>Replay test folders in alphabetical order</li>
</ul>
<h3 id="fixes"><a class="header" href="#fixes">Fixes</a></h3>
<ul>
<li>Add <code>impl Default</code> for <code>NestedFieldCapabilities</code></li>
</ul>
<h2 id="013"><a class="header" href="#013"><code>0.1.3</code></a></h2>
<h3 id="specification-8"><a class="header" href="#specification-8">Specification</a></h3>
<ul>
<li>Support field-level arguments</li>
<li>Support filtering and ordering by values of nested fields</li>
<li>Added a <code>biginteger</code> <a href="specification/./schema/scalar-types.html#type-representations">type representation</a></li>
</ul>
<h3 id="ndc-test-3"><a class="header" href="#ndc-test-3"><code>ndc-test</code></a></h3>
<ul>
<li>Validate all response types</li>
<li>Release pipeline for ndc-test CLI</li>
</ul>
<h3 id="rust-libraries-1"><a class="header" href="#rust-libraries-1">Rust Libraries</a></h3>
<ul>
<li>Upgrade Rust to v1.78.0, and the Rust dependencies to their latest versions</li>
<li>Add back features for native-tls vs rustls</li>
</ul>
<h2 id="012"><a class="header" href="#012"><code>0.1.2</code></a></h2>
<h3 id="specification-9"><a class="header" href="#specification-9">Specification</a></h3>
<ul>
<li>More <a href="specification/./schema/scalar-types.html#type-representations">type representations</a> were added, and some were deprecated.</li>
</ul>
<h3 id="rust-libraries-2"><a class="header" href="#rust-libraries-2">Rust Libraries</a></h3>
<ul>
<li>Upgrade to Rust v1.77</li>
<li>The <code>ndc-client</code> library was removed. Clients are advised to use the new <code>ndc-models</code> library for type definitions, and to use a HTTP client library of their choice directly.</li>
</ul>
<h2 id="011"><a class="header" href="#011"><code>0.1.1</code></a></h2>
<h3 id="specification-10"><a class="header" href="#specification-10">Specification</a></h3>
<ul>
<li><a href="specification/./schema/scalar-types.html#note-syntactic-equality">Equality operators were more precisely specified</a></li>
<li>Scalar types can now specify <a href="specification/./schema/scalar-types.html#type-representations">representations</a></li>
</ul>
<h3 id="ndc-test-4"><a class="header" href="#ndc-test-4"><code>ndc-test</code></a></h3>
<ul>
<li>Aggregate tests are gated behind the aggregates capability</li>
<li>Automatic tests are now generated for exists predicates</li>
<li>Automatic tests are now generated for <code>single_column</code> aggregates</li>
</ul>
<h3 id="rust-libraries-3"><a class="header" href="#rust-libraries-3">Rust Libraries</a></h3>
<ul>
<li><code>rustls</code> is supported instead of <code>native-tls</code> using a Cargo feature.</li>
<li>Upgrade <code>opentelemetry</code> to v0.22.0</li>
<li><code>colored</code> dependency removed in favor of <code>colorful</code></li>
</ul>
<h2 id="010"><a class="header" href="#010"><code>0.1.0</code></a></h2>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<p>Tables are now known as <em>collections</em>.</p>
<h3 id="collection-names"><a class="header" href="#collection-names">Collection Names</a></h3>
<p>Collection names are now single strings instead of arrays of strings. The array structure was previously used to represent qualification by a schema or database name, but the structure was not used anywhere on the client side, and had no semantic meaning. GDC now abstracts over these concepts, and expects relations to be named by strings.</p>
<h3 id="no-configuration"><a class="header" href="#no-configuration">No Configuration</a></h3>
<p>The configuration header convention was removed. Connectors are now expected to manage their own configuration, and a connector URL fully represents that connector with its pre-specified configuration.</p>
<h3 id="no-database-concepts-in-gdc"><a class="header" href="#no-database-concepts-in-gdc">No Database Concepts in GDC</a></h3>
<p>GDC no longer sends any metadata to indicate database-specific concepts. For example, a Collection used to indicate whether it was a Collection or view. Such metadata would be passed back in the query IR, to help the connector disambiguate which database object to query. When we proposed adding functions, we would have had to add a new type to disambiguate nullary functions from collections, etc. Instead, we now expect connectors to understand their own schema, and understand the query IR that they receive, as long as it is compatible with their GDC schema.</p>
<p>Column types are no longer sent in the query and mutation requests.</p>
<p>Tables, views and functions are unified under a single concept called "collections". GDC does not care how queries and mutations on relations are implemented.</p>
<h3 id="collection-arguments"><a class="header" href="#collection-arguments">Collection Arguments</a></h3>
<p>Collection arguments were added to relations in order to support use cases like table-valued functions and certain REST endpoints. Relationships can determine collection arguments.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Collections which return a single column and a single row are also called "functions", and identified separately in the schema response.</p>
<h3 id="field-arguments"><a class="header" href="#field-arguments">Field Arguments</a></h3>
<p>Field arguments were added to fields in order to support use cases like computed fields.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p>The equality operator is now expected on every scalar type implicitly.</p>
<p><em>Note</em>: it was already implicitly supported by any connector advertising the <code>variables</code> capability, which imposes column equality constraints in each row set fetched in a forall query.</p>
<p>The equality operator will have semantics assigned for the purposes of testing.</p>
<p>Scalars can define additional operators, whose semantics are opaque.</p>
<h3 id="procedures"><a class="header" href="#procedures">Procedures</a></h3>
<p>Proceduress were added to the list of available mutation operation types</p>
<h3 id="schema"><a class="header" href="#schema">Schema</a></h3>
<ul>
<li>Scalar types were moved to the schema endpoint</li>
<li>The <code>object_types</code> field was added to the schema endpoint</li>
</ul>
<h3 id="raw-queries"><a class="header" href="#raw-queries">Raw Queries</a></h3>
<p>The raw query endpoint was removed, since it cannot be given any useful semantics across all implementations.</p>
<h3 id="datasets"><a class="header" href="#datasets">Datasets</a></h3>
<p>The datasets endpoints were removed from the specification, because there was no way to usefully use it without prior knowledge of its implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Data connectors are implemented as HTTP services. To refer to a running data connector, it suffices to specify its base URL. All required endpoints are specified relative to this base URL.</p>
<p>All endpoints should accept JSON (in the case of POST request bodies) and return JSON using the <code>application/json</code> content type. The particular format of each JSON document will be specified for each endpoint.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<p>This specification is versioned using semantic versioning, and a data connector declares the <a href="https://semver.org">semantic version</a> of the specification that it implements via its <a href="specification/capabilities.html">capabilities</a> endpoint.</p>
<p>Non-breaking changes to the specification may be achieved via the addition of new capabilities, which a connector will be assumed not to implement if the corresponding field is not present in its capabilities endpoint.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>The client <em>may</em> send a semantic version string in the <code>X-Hasura-NDC-Version</code> HTTP header to any of the HTTP endpoints described by this specification. This header communicates the version of this specification that the client intends to use. Typically this should be the minimum non-breaking version of the specification that is supported by the client, so that the widest range of connectors can be used. For example, if a client sends supports sending v0.1.6 requests, then it technically is sending requests that are compatible with v0.1.0 clients because non-breaking additions are gated behind capabilities and would be disabled for older connectors. In this case, the client should send <code>0.1.0</code> as its version in the header.</p>
<p><em>If</em> the client sends this header, the connector should check compatibility with the requested version, and return an appropriate HTTP error code (e.g. <code>400 Bad Request</code>) if it is not capable of providing an implementation. Compatibility is defined as the semver range: <code>^{requested-version}</code>. For example, if the client sends <code>0.2.0</code>, then the compatible semver range is <code>^0.2.0</code>. If the connector implemented spec version <code>0.1.6</code>, this would be incompatible, but if it implemented spec version <code>0.2.1</code>, this would be compatible.</p>
<p><em>Note</em>: the <code>/capabilities</code> endpoint also indicates the implemented specification version for any connector, but it may not be practical for a client to check the capabilities endpoint before issuing a new request, so this provides a way to check compatibility in the course of a normal request.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<h2 id="status-codes"><a class="header" href="#status-codes">Status Codes</a></h2>
<p>Data connectors should use standard HTTP error codes to signal error conditions back to the Hasura server. In particular, the following error codes should be used in the indicated scenarios:</p>
<div class="table-wrapper"><table><thead><tr><th>Response Code</th><th>Meaning</th><th>Used when</th></tr></thead><tbody>
<tr><td>200</td><td>OK</td><td>The request was handled successfully according to this specification .</td></tr>
<tr><td>400</td><td>Bad Request</td><td>The request did not match the data connector's expectation based on this specification.</td></tr>
<tr><td>403</td><td>Forbidden</td><td>The request could not be handled because a permission check failed - for example, a mutation might fail because a check constraint was not met.</td></tr>
<tr><td>409</td><td>Conflict</td><td>The request could not be handled because it would create a conflicting state for the data source - for example, a mutation might fail because a foreign key constraint was not met.</td></tr>
<tr><td>422</td><td>Unprocessable Content</td><td>The request could not be handled because, while the request was well-formed, it was not semantically correct. For example, a value for a custom scalar type was provided, but with an incorrect type.</td></tr>
<tr><td>500</td><td>Internal Server Error</td><td>The request could not be handled because of an error on the server</td></tr>
<tr><td>501</td><td>Not Supported</td><td>The request could not be handled because it relies on an unsupported <a href="specification/capabilities.html">capability</a>. <em>Note</em>: this ought to indicate an error on the <em>caller</em> side, since the caller should not generate requests which are incompatible with the indicated capabilities.</td></tr>
<tr><td>502</td><td>Bad Gateway</td><td>The request could not be handled because an upstream service was unavailable or returned an unexpected response, e.g., a connection to a database server failed</td></tr>
</tbody></table>
</div>
<h2 id="response-body"><a class="header" href="#response-body">Response Body</a></h2>
<p>Data connectors should return an <a href="specification/../reference/types.html#errorresponse"><code>ErrorResponse</code></a> as JSON in the response body, in the case of an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="service-health"><a class="header" href="#service-health">Service Health</a></h1>
<p>Data connectors must provide a <strong>health endpoint</strong> which can be used to indicate service health and readiness to any client applications.</p>
<h2 id="request"><a class="header" href="#request">Request</a></h2>
<pre><code>GET /health
</code></pre>
<h2 id="response"><a class="header" href="#response">Response</a></h2>
<p>If the data connector is available and ready to accept requests, then the health endpoint should return status code <code>200 OK</code>.</p>
<p>Otherwise, it should ideally return a status code <code>503 Service Unavailable</code>, or some other appropriate HTTP error code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>Data connectors should provide a <strong>metrics endpoint</strong> which reports relevant metrics in a textual format. Data connectors can report any metrics which are deemed relevant, or none at all, with the exception of any reserved keys.</p>
<h2 id="request-1"><a class="header" href="#request-1">Request</a></h2>
<pre><code>GET /metrics
</code></pre>
<h2 id="response-1"><a class="header" href="#response-1">Response</a></h2>
<p>The metrics endpoint should return a content type of <code>text/plain</code>, and return any metrics in the <a href="https://prometheus.io/docs/instrumenting/exposition_formats/#text-based-format">Prometheus textual format</a>.</p>
<h3 id="reserved-keys"><a class="header" href="#reserved-keys">Reserved keys</a></h3>
<p>Metric names prefixed with <code>hasura_</code> are reserved for future use, and should not be included in the response.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code># HELP query_total The number of /query requests served
# TYPE query_total counter
query_total 10000 1685405427000
# HELP mutation_total The number of /mutation requests served
# TYPE mutation_total counter
mutation_total 5000 1685405427000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h1>
<p>Hasura uses OpenTelemetry to coordinate the collection of traces and metrics with data connectors.</p>
<h2 id="trace-collection"><a class="header" href="#trace-collection">Trace Collection</a></h2>
<p>Trace collection is out of the scope of this specification currently. This may change in a future revision.</p>
<h2 id="trace-propagation"><a class="header" href="#trace-propagation">Trace Propagation</a></h2>
<p>Hasura uses the <a href="https://www.w3.org/TR/trace-context/">W3C TraceContext specification</a> to implement trace propagation. Data connectors should propagate tracing headers in this format to any downstream services.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h1>
<p>The capabilities endpoint provides metadata about the features which the data connector (and data source) support.</p>
<h2 id="request-2"><a class="header" href="#request-2">Request</a></h2>
<pre><code>GET /capabilities
</code></pre>
<h2 id="response-2"><a class="header" href="#response-2">Response</a></h2>
<p>See <a href="specification/../reference/types.html#capabilitiesresponse"><code>CapabilitiesResponse</code></a></p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-json">{
  "version": "0.2.5",
  "capabilities": {
    "query": {
      "aggregates": {
        "filter_by": {},
        "group_by": {
          "filter": {},
          "order": {},
          "paginate": {}
        }
      },
      "variables": {},
      "nested_fields": {
        "filter_by": {
          "nested_arrays": {
            "contains": {},
            "is_empty": {}
          }
        },
        "order_by": {},
        "aggregates": {},
        "nested_collections": {}
      },
      "exists": {
        "named_scopes": {},
        "unrelated": {},
        "nested_collections": {},
        "nested_scalar_collections": {}
      }
    },
    "mutation": {},
    "relationships": {
      "relation_comparisons": {},
      "order_by_aggregate": {},
      "nested": {
        "array": {},
        "filtering": {},
        "ordering": {}
      }
    }
  }
}
</code></pre>
<h2 id="response-fields"><a class="header" href="#response-fields">Response Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>version</code></td><td>A <a href="https://semver.org">semantic version number</a> of this specification which the data connector claims to implement</td></tr>
<tr><td><code>capabilities</code></td><td>The capabilities that this connector supports, see <a href="specification/capabilities.html#capabilities-fields">below</a></td></tr>
</tbody></table>
</div>
<h3 id="capabilities-fields"><a class="header" href="#capabilities-fields">Capabilities Fields</a></h3>
<p>These fields are set underneath the <code>capabilities</code> property on the <code>CapabilitiesResponse</code> object:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mutation.explain</code></td><td>Whether the data connector is capable of <a href="specification/explain.html">describing mutation plans</a></td></tr>
<tr><td><code>mutation.transactional</code></td><td>Whether the data connector is capable of executing <a href="specification/mutations/README.html#multiple-operations">multiple mutations in a transaction</a></td></tr>
<tr><td><code>query.aggregates</code></td><td>Whether the data connector supports <a href="specification/queries/aggregates.html">aggregate queries</a>. The <a href="specification/schema/capabilities.html">schema <code>capabilities.query.aggregates</code></a> should also be returned.</td></tr>
<tr><td><code>query.aggregates.filter_by</code></td><td>Whether the data connector supports <a href="specification/queries/filtering.html#computing-an-aggregate">filtering by aggregated values</a></td></tr>
<tr><td><code>query.aggregates.group_by</code></td><td>Whether the data connector supports <a href="specification/queries/grouping.html">grouping operations</a></td></tr>
<tr><td><code>query.aggregates.group_by.filter</code></td><td>Whether the data connector supports <a href="specification/queries/grouping.html#filtering">filtering on groups</a></td></tr>
<tr><td><code>query.aggregates.group_by.order</code></td><td>Whether the data connector supports <a href="specification/queries/grouping.html#ordering">ordering on groups</a></td></tr>
<tr><td><code>query.aggregates.group_by.paginate</code></td><td>Whether the data connector supports <a href="specification/queries/grouping.html#pagination">pagination on groups</a></td></tr>
<tr><td><code>query.exists.named_scopes</code></td><td>Whether the data connector supports <a href="specification/queries/filtering.html#referencing-a-column-from-a-collection-in-scope">named scopes</a> in exists expressions</td></tr>
<tr><td><code>query.exists.nested_collections</code></td><td>Whether the data connector supports <a href="specification/queries/filtering.html#exists-expressions">exists expressions</a> against <a href="specification/queries/field-selection.html#nested-collections">nested collections</a></td></tr>
<tr><td><code>query.exists.nested_scalar_collections</code></td><td>Whether the data connector supports <a href="specification/queries/filtering.html#exists-expressions">exists expressions</a> against <a href="specification/queries/field-selection.html#nested-scalar-collections">nested scalar collections</a></td></tr>
<tr><td><code>query.exists.unrelated</code></td><td>Whether the data connector supports <a href="specification/queries/filtering.html#exists-expressions">exists expressions</a> against unrelated collections</td></tr>
<tr><td><code>query.explain</code></td><td>Whether the data connector is capable of <a href="specification/explain.html">describing query plans</a></td></tr>
<tr><td><code>query.nested_fields.aggregates</code></td><td>Whether the data connector is capable of <a href="specification/queries/aggregates.html">aggregating fields in nested objects</a></td></tr>
<tr><td><code>query.nested_fields.filter_by</code></td><td>Whether the data connector is capable of <a href="specification/queries/filtering.html#referencing-nested-fields-within-columns">filtering by nested fields</a></td></tr>
<tr><td><code>query.nested_fields.filter_by.nested_arrays</code></td><td>Whether the data connector is capable of filtering over nested arrays using <a href="specification/queries/filtering.html#nested-array-comparison-operators"><code>array_comparison</code> expressions</a></td></tr>
<tr><td><code>query.nested_fields.filter_by.nested_arrays.contains</code></td><td>Whether the data connector is capable of filtering over nested arrays using the <a href="specification/queries/filtering.html#nested-array-comparison-operators">contains operator</a></td></tr>
<tr><td><code>query.nested_fields.filter_by.nested_arrays.is_empty</code></td><td>Whether the data connector is capable of filtering over nested arrays using the is <a href="specification/queries/filtering.html#nested-array-comparison-operators">empty operator</a></td></tr>
<tr><td><code>query.nested_fields.nested_collections</code></td><td>Whether the data connector supports <a href="specification/queries/field-selection.html#nested-collections">nested collection field queries</a></td></tr>
<tr><td><code>query.nested_fields.order_by</code></td><td>Whether the data connector is capable of <a href="specification/queries/sorting.html#type-column">ordering by nested fields</a></td></tr>
<tr><td><code>query.variables</code></td><td>Whether the data connector supports <a href="specification/queries/variables.html">queries with variables</a></td></tr>
<tr><td><code>relationships</code></td><td>Whether the data connector supports <a href="specification/queries/relationships.html">relationships</a></td></tr>
<tr><td><code>relationships.nested</code></td><td>Whether the data connector supports relationships that can <a href="specification/queries/relationships.html#column-mappings">start from or end with columns in nested objects</a></td></tr>
<tr><td><code>relationships.nested.array</code></td><td>Whether the data connector supports relationships that can <a href="specification/queries/relationships.html#column-mappings">start from columns inside nested objects inside nested arrays</a></td></tr>
<tr><td><code>relationships.nested.filtering</code></td><td>Whether the data connector supports using relationships that can <a href="specification/queries/relationships.html#column-mappings">start from columns inside nested objects</a> while filtering</td></tr>
<tr><td><code>relationships.nested.ordering</code></td><td>Whether the data connector supports using relationships that can <a href="specification/queries/relationships.html#column-mappings">start from columns inside nested objects</a> while ordering</td></tr>
<tr><td><code>relationships.order_by_aggregate</code></td><td>Whether order by clauses can <a href="specification/queries/sorting.html#type-aggregate">include aggregates</a></td></tr>
<tr><td><code>relationships.relation_comparisons</code></td><td>Whether comparisons between two columns can include a <a href="specification/queries/filtering.html#values-in-binary-operators">value column</a> that is across a <a href="specification/queries/relationships.html">relationship</a></td></tr>
</tbody></table>
</div>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li>Type <a href="specification/../reference/types.html#capabilities"><code>Capabilities</code></a></li>
<li>Type <a href="specification/../reference/types.html#capabilitiesresponse"><code>CapabilitiesResponse</code></a></li>
<li>Type <a href="specification/../reference/types.html#querycapabilities"><code>QueryCapabilities</code></a></li>
<li>Type <a href="specification/../reference/types.html#nestedfieldcapabilities"><code>NestedFieldCapabilities</code></a></li>
<li>Type <a href="specification/../reference/types.html#mutationcapabilities"><code>MutationCapabilities</code></a></li>
<li>Type <a href="specification/../reference/types.html#relationshipcapabilities"><code>RelationshipCapabilities</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Several definitions in this specification make mention of <em>types</em>. Types are used to categorize the sorts of data returned and accepted by a data connector.</p>
<p>Scalar and named object types are defined in the <a href="specification/./schema/README.html">schema response
</a>, and referred to by name at the point of use.</p>
<p>Array types, nullable types and predicate types are constructed at the point of use.</p>
<h2 id="named-types"><a class="header" href="#named-types">Named Types</a></h2>
<p>To refer to a named (scalar or object) type, use the type <code>named</code>, and provide the name:</p>
<pre><code class="language-json">{
  "type": "named",
  "name": "String"
}
</code></pre>
<h2 id="array-types"><a class="header" href="#array-types">Array Types</a></h2>
<p>To refer to an array type, use the type <code>array</code>, and refer to the type of the elements of the array in the <code>element_type</code> field:</p>
<pre><code class="language-json">{
  "type": "array",
  "element_type": {
    "type": "named",
    "name": "String"
  }
}
</code></pre>
<h2 id="nullable-types"><a class="header" href="#nullable-types">Nullable Types</a></h2>
<p>To refer to a nullable type, use the type <code>nullable</code>, and refer to the type of the underlying (non-null) inhabitants in the <code>underlying_type</code> field:</p>
<pre><code class="language-json">{
  "type": "nullable",
  "underlying_type": {
    "type": "named",
    "name": "String"
  }
}
</code></pre>
<p>Nullable and array types can be nested. For example, to refer to a nullable array of nullable strings:</p>
<pre><code class="language-json">{
  "type": "nullable",
  "underlying_type": {
    "type": "array",
    "element_type": {
      "type": "nullable",
      "underlying_type": {
        "type": "named",
        "name": "String"
      }
    }
  }
}
</code></pre>
<h2 id="predicate-types"><a class="header" href="#predicate-types">Predicate Types</a></h2>
<p>A predicate type can be used to represent valid predicates (of type <a href="specification/../reference/types.html#expression"><code>Expression</code></a>) for an object type. A value of a predicate type is represented, in inputs and return values, as a JSON value which parses as an <code>Expression</code>. Valid expressions are those which refer to the columns of the object type.</p>
<p>To refer to a predicate type, use the type <code>predicate</code>, and provide the name of the object type:</p>
<pre><code class="language-json">{
  "type": "predicate",
  "object_type_name": "article"
}
</code></pre>
<p>Note: predicate types are intended primarily for use in <a href="specification/./queries/arguments.html">arguments</a> to functions and <a href="specification/./mutations/procedures.html">procedures</a>, but they can be used anywhere a <a href="specification/../reference/types.html"><code>Type</code></a> is expected, including in output types.</p>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li>Type <a href="specification/../reference/types.html#type"><code>Type</code></a></li>
<li><a href="specification/./schema/scalar-types.html">Scalar types</a></li>
<li><a href="specification/./schema/object-types.html">Object types</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-1"><a class="header" href="#schema-1">Schema</a></h1>
<p>The schema endpoint defines any types used by the data connector, and describes the collections and their columns, functions, and any procedures.</p>
<p>The schema endpoint is used to specify the behavior of a data connector, so that it can be tested, verified, and used by tools such as code generators. It is primarily provided by data connector implementors as a development and specification tool, and it is not expected to be used at "runtime", in the same sense that the <code>/query</code> and <code>/mutation</code> endpoints would be.</p>
<h2 id="request-3"><a class="header" href="#request-3">Request</a></h2>
<pre><code>GET /schema
</code></pre>
<h2 id="response-3"><a class="header" href="#response-3">Response</a></h2>
<p>See <a href="specification/schema/../../reference/types.html#schemaresponse"><code>SchemaResponse</code></a></p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-json">{
  "scalar_types": {
    "Date": {
      "representation": {
        "type": "date"
      },
      "aggregate_functions": {},
      "comparison_operators": {
        "eq": {
          "type": "equal"
        },
        "in": {
          "type": "in"
        }
      },
      "extraction_functions": {
        "day": {
          "type": "day",
          "result_type": "Int"
        },
        "month": {
          "type": "month",
          "result_type": "Int"
        },
        "year": {
          "type": "year",
          "result_type": "Int"
        }
      }
    },
    "Float": {
      "representation": {
        "type": "float64"
      },
      "aggregate_functions": {
        "avg": {
          "type": "average",
          "result_type": "Float"
        },
        "max": {
          "type": "max"
        },
        "min": {
          "type": "min"
        },
        "sum": {
          "type": "sum",
          "result_type": "Float"
        }
      },
      "comparison_operators": {
        "eq": {
          "type": "equal"
        },
        "gt": {
          "type": "greater_than"
        },
        "gte": {
          "type": "greater_than_or_equal"
        },
        "in": {
          "type": "in"
        },
        "lt": {
          "type": "less_than"
        },
        "lte": {
          "type": "less_than_or_equal"
        }
      },
      "extraction_functions": {}
    },
    "Int": {
      "representation": {
        "type": "int32"
      },
      "aggregate_functions": {
        "avg": {
          "type": "average",
          "result_type": "Float"
        },
        "max": {
          "type": "max"
        },
        "min": {
          "type": "min"
        },
        "sum": {
          "type": "sum",
          "result_type": "Int64"
        }
      },
      "comparison_operators": {
        "eq": {
          "type": "equal"
        },
        "gt": {
          "type": "greater_than"
        },
        "gte": {
          "type": "greater_than_or_equal"
        },
        "in": {
          "type": "in"
        },
        "lt": {
          "type": "less_than"
        },
        "lte": {
          "type": "less_than_or_equal"
        }
      },
      "extraction_functions": {}
    },
    "Int64": {
      "representation": {
        "type": "int64"
      },
      "aggregate_functions": {
        "avg": {
          "type": "average",
          "result_type": "Float"
        },
        "max": {
          "type": "max"
        },
        "min": {
          "type": "min"
        },
        "sum": {
          "type": "sum",
          "result_type": "Int64"
        }
      },
      "comparison_operators": {
        "eq": {
          "type": "equal"
        },
        "gt": {
          "type": "greater_than"
        },
        "gte": {
          "type": "greater_than_or_equal"
        },
        "in": {
          "type": "in"
        },
        "lt": {
          "type": "less_than"
        },
        "lte": {
          "type": "less_than_or_equal"
        }
      },
      "extraction_functions": {}
    },
    "String": {
      "representation": {
        "type": "string"
      },
      "aggregate_functions": {
        "max": {
          "type": "max"
        },
        "min": {
          "type": "min"
        }
      },
      "comparison_operators": {
        "contains": {
          "type": "contains"
        },
        "ends_with": {
          "type": "ends_with"
        },
        "eq": {
          "type": "equal"
        },
        "gt": {
          "type": "greater_than"
        },
        "gte": {
          "type": "greater_than_or_equal"
        },
        "icontains": {
          "type": "contains_insensitive"
        },
        "iends_with": {
          "type": "ends_with_insensitive"
        },
        "in": {
          "type": "in"
        },
        "istarts_with": {
          "type": "starts_with_insensitive"
        },
        "like": {
          "type": "custom",
          "argument_type": {
            "type": "named",
            "name": "String"
          }
        },
        "lt": {
          "type": "less_than"
        },
        "lte": {
          "type": "less_than_or_equal"
        },
        "starts_with": {
          "type": "starts_with"
        }
      },
      "extraction_functions": {}
    }
  },
  "object_types": {
    "article": {
      "description": "An article",
      "fields": {
        "author_id": {
          "description": "The article's author ID",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "id": {
          "description": "The article's primary key",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "published_date": {
          "description": "The article's date of publication",
          "type": {
            "type": "named",
            "name": "Date"
          }
        },
        "title": {
          "description": "The article's title",
          "type": {
            "type": "named",
            "name": "String"
          }
        }
      },
      "foreign_keys": {
        "Article_AuthorID": {
          "column_mapping": {
            "author_id": [
              "id"
            ]
          },
          "foreign_collection": "authors"
        }
      }
    },
    "author": {
      "description": "An author",
      "fields": {
        "first_name": {
          "description": "The author's first name",
          "type": {
            "type": "named",
            "name": "String"
          }
        },
        "id": {
          "description": "The author's primary key",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "last_name": {
          "description": "The author's last name",
          "type": {
            "type": "named",
            "name": "String"
          }
        }
      },
      "foreign_keys": {}
    },
    "city": {
      "description": "A city",
      "fields": {
        "name": {
          "description": "The institution's name",
          "type": {
            "type": "named",
            "name": "String"
          }
        }
      },
      "foreign_keys": {}
    },
    "country": {
      "description": "A country",
      "fields": {
        "area_km2": {
          "description": "The country's area size in square kilometers",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "cities": {
          "description": "The cities in the country",
          "type": {
            "type": "array",
            "element_type": {
              "type": "named",
              "name": "city"
            }
          },
          "arguments": {
            "limit": {
              "type": {
                "type": "nullable",
                "underlying_type": {
                  "type": "named",
                  "name": "Int"
                }
              }
            }
          }
        },
        "id": {
          "description": "The country's primary key",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "name": {
          "description": "The country's name",
          "type": {
            "type": "named",
            "name": "String"
          }
        }
      },
      "foreign_keys": {}
    },
    "institution": {
      "description": "An institution",
      "fields": {
        "departments": {
          "description": "The institution's departments",
          "type": {
            "type": "array",
            "element_type": {
              "type": "named",
              "name": "String"
            }
          },
          "arguments": {
            "limit": {
              "type": {
                "type": "nullable",
                "underlying_type": {
                  "type": "named",
                  "name": "Int"
                }
              }
            }
          }
        },
        "id": {
          "description": "The institution's primary key",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "location": {
          "description": "The institution's location",
          "type": {
            "type": "named",
            "name": "location"
          }
        },
        "name": {
          "description": "The institution's name",
          "type": {
            "type": "named",
            "name": "String"
          }
        },
        "staff": {
          "description": "The institution's staff",
          "type": {
            "type": "array",
            "element_type": {
              "type": "named",
              "name": "staff_member"
            }
          },
          "arguments": {
            "limit": {
              "type": {
                "type": "nullable",
                "underlying_type": {
                  "type": "named",
                  "name": "Int"
                }
              }
            }
          }
        }
      },
      "foreign_keys": {}
    },
    "location": {
      "description": "A location",
      "fields": {
        "campuses": {
          "description": "The location's campuses",
          "type": {
            "type": "array",
            "element_type": {
              "type": "named",
              "name": "String"
            }
          },
          "arguments": {
            "limit": {
              "type": {
                "type": "nullable",
                "underlying_type": {
                  "type": "named",
                  "name": "Int"
                }
              }
            }
          }
        },
        "city": {
          "description": "The location's city",
          "type": {
            "type": "named",
            "name": "String"
          }
        },
        "country": {
          "description": "The location's country",
          "type": {
            "type": "named",
            "name": "String"
          }
        },
        "country_id": {
          "description": "The location's country ID",
          "type": {
            "type": "named",
            "name": "Int"
          }
        }
      },
      "foreign_keys": {
        "Location_CountryID": {
          "column_mapping": {
            "country_id": [
              "id"
            ]
          },
          "foreign_collection": "countries"
        }
      }
    },
    "staff_member": {
      "description": "A staff member",
      "fields": {
        "born_country_id": {
          "description": "The ID of the country the staff member was born in",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "first_name": {
          "description": "The staff member's first name",
          "type": {
            "type": "named",
            "name": "String"
          }
        },
        "last_name": {
          "description": "The staff member's last name",
          "type": {
            "type": "named",
            "name": "String"
          }
        },
        "specialities": {
          "description": "The staff member's specialities",
          "type": {
            "type": "array",
            "element_type": {
              "type": "named",
              "name": "String"
            }
          },
          "arguments": {
            "limit": {
              "type": {
                "type": "nullable",
                "underlying_type": {
                  "type": "named",
                  "name": "Int"
                }
              }
            }
          }
        }
      },
      "foreign_keys": {
        "Staff_BornCountryID": {
          "column_mapping": {
            "born_country_id": [
              "id"
            ]
          },
          "foreign_collection": "countries"
        }
      }
    }
  },
  "collections": [
    {
      "name": "articles",
      "description": "A collection of articles",
      "arguments": {},
      "type": "article",
      "uniqueness_constraints": {
        "ArticleByID": {
          "unique_columns": [
            "id"
          ]
        }
      }
    },
    {
      "name": "authors",
      "description": "A collection of authors",
      "arguments": {},
      "type": "author",
      "uniqueness_constraints": {
        "AuthorByID": {
          "unique_columns": [
            "id"
          ]
        }
      }
    },
    {
      "name": "institutions",
      "description": "A collection of institutions",
      "arguments": {},
      "type": "institution",
      "uniqueness_constraints": {
        "InstitutionByID": {
          "unique_columns": [
            "id"
          ]
        }
      }
    },
    {
      "name": "countries",
      "description": "A collection of countries",
      "arguments": {},
      "type": "country",
      "uniqueness_constraints": {
        "CountryByID": {
          "unique_columns": [
            "id"
          ]
        }
      }
    },
    {
      "name": "articles_by_author",
      "description": "Articles parameterized by author",
      "arguments": {
        "author_id": {
          "type": {
            "type": "named",
            "name": "Int"
          }
        }
      },
      "type": "article",
      "uniqueness_constraints": {}
    }
  ],
  "functions": [
    {
      "name": "latest_article_id",
      "description": "Get the ID of the most recent article",
      "arguments": {},
      "result_type": {
        "type": "nullable",
        "underlying_type": {
          "type": "named",
          "name": "Int"
        }
      }
    },
    {
      "name": "latest_article",
      "description": "Get the most recent article",
      "arguments": {},
      "result_type": {
        "type": "nullable",
        "underlying_type": {
          "type": "named",
          "name": "article"
        }
      }
    }
  ],
  "procedures": [
    {
      "name": "upsert_article",
      "description": "Insert or update an article",
      "arguments": {
        "article": {
          "description": "The article to insert or update",
          "type": {
            "type": "named",
            "name": "article"
          }
        }
      },
      "result_type": {
        "type": "nullable",
        "underlying_type": {
          "type": "named",
          "name": "article"
        }
      }
    },
    {
      "name": "delete_articles",
      "description": "Delete articles which match a predicate",
      "arguments": {
        "where": {
          "description": "The predicate",
          "type": {
            "type": "predicate",
            "object_type_name": "article"
          }
        }
      },
      "result_type": {
        "type": "array",
        "element_type": {
          "type": "named",
          "name": "article"
        }
      }
    }
  ],
  "capabilities": {
    "query": {
      "aggregates": {
        "count_scalar_type": "Int"
      }
    }
  },
  "request_arguments": {
    "query_arguments": {},
    "mutation_arguments": {},
    "relational_query_arguments": {}
  }
}
</code></pre>
<h2 id="response-fields-1"><a class="header" href="#response-fields-1">Response Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>scalar_types</code></td><td><a href="specification/schema/scalar-types.html">Scalar types</a></td></tr>
<tr><td><code>object_types</code></td><td><a href="specification/schema/object-types.html">Object types</a></td></tr>
<tr><td><code>collections</code></td><td><a href="specification/schema/collections.html">Collection</a></td></tr>
<tr><td><code>functions</code></td><td><a href="specification/schema/functions.html">Functions</a></td></tr>
<tr><td><code>procedures</code></td><td><a href="specification/schema/procedures.html">Procedures</a></td></tr>
<tr><td><code>capabilities</code></td><td><a href="specification/schema/capabilities.html">Capability-specific information</a></td></tr>
<tr><td><code>arguments</code></td><td><a href="specification/schema/arguments.html">Request-level arguments</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<p>The schema should describe any irreducible <em>scalar types</em>. Scalar types can be used as the types of columns, or in general as the types of object fields.</p>
<p>Scalar types define several types of operations, which extend the capabilities of the query and mutation APIs: <em>comparison operators</em> and <em>aggregate functions</em>.</p>
<h2 id="type-representations"><a class="header" href="#type-representations">Type Representations</a></h2>
<p>A scalar type definition must include a <em>type representation</em>. The representation indicates to potential callers what values can be expected in responses, and what values are considered acceptable in requests.</p>
<h3 id="supported-representations"><a class="header" href="#supported-representations">Supported Representations</a></h3>
<div class="table-wrapper"><table><thead><tr><th><code>type</code></th><th>Description</th><th>JSON representation</th></tr></thead><tbody>
<tr><td><code>boolean</code></td><td>Boolean</td><td>Boolean</td></tr>
<tr><td><code>string</code></td><td>String</td><td>String</td></tr>
<tr><td><code>int8</code></td><td>An 8-bit signed integer with a minimum value of -2^7 and a maximum value of 2^7 - 1</td><td>Number</td></tr>
<tr><td><code>int16</code></td><td>A 16-bit signed integer with a minimum value of -2^15 and a maximum value of 2^15 - 1</td><td>Number</td></tr>
<tr><td><code>int32</code></td><td>A 32-bit signed integer with a minimum value of -2^31 and a maximum value of 2^31 - 1</td><td>Number</td></tr>
<tr><td><code>int64</code></td><td>A 64-bit signed integer with a minimum value of -2^63 and a maximum value of 2^63 - 1</td><td>String</td></tr>
<tr><td><code>float32</code></td><td>An IEEE-754 single-precision floating-point number</td><td>Number</td></tr>
<tr><td><code>float64</code></td><td>An IEEE-754 double-precision floating-point number</td><td>Number</td></tr>
<tr><td><code>biginteger</code></td><td>Arbitrary-precision integer string</td><td>String</td></tr>
<tr><td><code>bigdecimal</code></td><td>Arbitrary-precision decimal string</td><td>String</td></tr>
<tr><td><code>uuid</code></td><td>UUID string (8-4-4-4-12 format)</td><td>String</td></tr>
<tr><td><code>date</code></td><td>ISO 8601 date</td><td>String</td></tr>
<tr><td><code>timestamp</code></td><td>ISO 8601 timestamp</td><td>String</td></tr>
<tr><td><code>timestamptz</code></td><td>ISO 8601 timestamp-with-timezone</td><td>String</td></tr>
<tr><td><code>geography</code></td><td>GeoJSON, per RFC 7946</td><td>JSON</td></tr>
<tr><td><code>geometry</code></td><td>GeoJSON Geometry object, per RFC 7946</td><td>JSON</td></tr>
<tr><td><code>bytes</code></td><td>Base64-encoded bytes</td><td>String</td></tr>
<tr><td><code>json</code></td><td>Arbitrary JSON</td><td>JSON</td></tr>
</tbody></table>
</div>
<h3 id="enum-representations"><a class="header" href="#enum-representations">Enum Representations</a></h3>
<p>A scalar type with a representation of type <code>enum</code> accepts one of a set of string values, specified by the <code>one_of</code> argument.</p>
<p>For example, this representation indicates that the only three valid values are the strings <code>"foo"</code>, <code>"bar"</code> and <code>"baz"</code>:</p>
<pre><code class="language-json">{
  "type": "enum",
  "one_of": ["foo", "bar", "baz"]
}
</code></pre>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<p>Comparison operators extend the query AST with the ability to express new binary comparison expressions in the predicate.</p>
<p>For example, a data connector might augment a <code>String</code> scalar type with a <code>LIKE</code> operator which tests for a fuzzy match based on a regular expression.</p>
<p>A comparison operator is either a <em>standard</em> operator, or a custom operator.</p>
<p>To define a comparison operator, add a <a href="specification/schema/../../reference/types.html#comparisonoperatordefinition"><code>ComparisonOperatorDefinition</code></a> to the <code>comparison_operators</code> field of the schema response.</p>
<p>For example:</p>
<pre><code class="language-json">{
  "scalar_types": {
    "String": {
      "aggregate_functions": {},
      "comparison_operators": {
        "like": {
          "type": "custom",
          "argument_type": {
            "type": "named",
            "name": "String"
          }
        }
      }
    }
  },
  ...
}
</code></pre>
<h3 id="standard-comparison-operators"><a class="header" href="#standard-comparison-operators">Standard Comparison Operators</a></h3>
<h4 id="equal"><a class="header" href="#equal"><code>Equal</code></a></h4>
<p>An operator defined using type <code>equal</code> tests if a column value is equal to a scalar value, another column value, or a variable.</p>
<h5 id="note-syntactic-equality"><a class="header" href="#note-syntactic-equality">Note: syntactic equality</a></h5>
<p>Specifically, a predicate expression which uses an operator of type <code>equal</code> should implement <em>syntactic equality</em>:</p>
<ul>
<li>An expression which tests for equality of a column with a <em>scalar</em> value or <em>variable</em> should return that scalar value exactly (equal as JSON values) for all rows in each corresponding row set, whenever the same column is selected.</li>
<li>An expression which tests for equality of a column with <em>another column</em> should return the same values in both columns (equal as JSON values) for all rows in each corresponding row set, whenever both of those those columns are selected.</li>
</ul>
<p>This type of equality is quite strict, and it might not be possible to implement such an operator for all scalar types. For example, a case-insensitive string type's natural case-insensitive equality operator would not meet the criteria above. In such cases, the scalar type should <em>not</em> provide an <em>equal</em> operator.</p>
<h4 id="in"><a class="header" href="#in"><code>In</code></a></h4>
<p>An operator defined using type <code>in</code> tests if a column value is a member of an array of values. The array is specified either as a scalar, a variable, or as the value of another column.</p>
<p>It should accept an array type as its argument, whose element type is the scalar type for which it is defined. It should be equivalent to a disjunction of individual equality tests on the elements of the provided array, where the equality test is an equivalence relation in the same sense as above.</p>
<h4 id="less_than-greater_than-less_than_or_equal-greater_than_or_equal"><a class="header" href="#less_than-greater_than-less_than_or_equal-greater_than_or_equal"><code>less_than</code>, <code>greater_than</code>, <code>less_than_or_equal</code>, <code>greater_than_or_equal</code></a></h4>
<p>An operator defined using type <code>less_than</code> tests if a column value is less than a specified value. Similarly for the other comparisons here.</p>
<p>If a connector defines more than one of these standard operators, then they should be compatible:</p>
<ul>
<li>When using <code>less_than</code>, a row should be included in the generated row set if and only if it would <em>not</em> be returned in the corresponding <code>greater_than_or_equal</code> comparison, and vice versa. More succinctly, it is expected that <code>x &lt; y</code> holds exactly when <code>x &gt;= y</code> does not hold.</li>
<li>It is expected that <code>x &lt; y</code> holds exactly when <code>y &gt; x</code> holds.</li>
<li>It is expected that <code>x &lt;= y</code> holds exactly when <code>y &gt;= x</code> holds.</li>
</ul>
<p>The <code>less_than_or_equal</code> and <code>greater_than_or_equal</code> operators are expected to be <em>reflexive</em>. That is, they should return a superset of those rows returned by the corresponding <code>equal</code> (syntactic equality) operator.</p>
<p>Each of these four operators is expected to be <em>transitive</em>. That is, for example <code>x &lt; y</code> and <code>y &lt; z</code> together imply <code>x &lt; z</code>, and similarly for the other operators.</p>
<h4 id="contains-icontains-starts_with-istarts_with-ends_with-iends_with"><a class="header" href="#contains-icontains-starts_with-istarts_with-ends_with-iends_with"><code>contains</code>, <code>icontains</code>, <code>starts_with</code>, <code>istarts_with</code>, <code>ends_with</code>, <code>iends_with</code></a></h4>
<p>These operators must only apply to scalar types whose type representation is <code>string</code>.</p>
<p>An operator defined using type <code>contains</code> tests if a string-valued column on the left contains a string value on the right. <code>icontains</code> is the case-insensitive variant.</p>
<p>An operator defined using type <code>starts_with</code> tests if a string-valued column on the left starts with a string value on the right. <code>istarts_with</code> is the case-insensitive variant.</p>
<p>An operator defined using type <code>ends_with</code> tests if a string-valued column on the left ends with a string value on the right. <code>iends_with</code> is the case-insensitive variant.</p>
<h3 id="custom-comparison-operators"><a class="header" href="#custom-comparison-operators">Custom Comparison Operators</a></h3>
<p>Data connectors can also define custom comparison operators using type <code>custom</code>. A custom operator is defined by its argument type, and its semantics is undefined.</p>
<h2 id="aggregate-functions"><a class="header" href="#aggregate-functions">Aggregate Functions</a></h2>
<p>Aggregate functions extend the query AST with the ability to express new aggregates within the <code>aggregates</code> portion of a query. They also allow sorting the query results via the <code>order_by</code> query field.</p>
<p><em>Note</em>: data connectors are required to implement the <em>count</em> and <em>count-distinct</em> aggregations for columns of all scalar types, and those operator is distinguished in the query AST. There is no need to define these aggregates as aggregate functions.</p>
<p>For example, a data connector might augment a <code>Float</code> scalar type with a <code>SUM</code> function which aggregates a sum of a collection of floating-point numbers.</p>
<p>Just like for comparison operators, an aggregate function is either a <em>standard</em> function, or a custom function.</p>
<p>To define an aggregate function, add a <a href="specification/schema/../../reference/types.html#aggregatefunctiondefinition"><code>AggregateFunctionDefinition</code></a> to the <code>aggregate_functions</code> field of the schema response.</p>
<p>For example:</p>
<pre><code class="language-json">{
  "scalar_types": {
    "Float": {
      "aggregate_functions": {
        "sum": {
          "type": "sum",
          "result_type": "Float"
        },
        "stddev": {
          "type": "custom",
          "result_type": {
            "type": "named",
            "name": "Float"
          }
        }
      },
      "comparison_operators": {}
    }
  },
  ...
}
</code></pre>
<h3 id="standard-aggregate-functions"><a class="header" href="#standard-aggregate-functions">Standard Aggregate Functions</a></h3>
<h4 id="sum"><a class="header" href="#sum"><code>sum</code></a></h4>
<p>An aggregate function defined using type <code>sum</code> should return the numerical sum of its provided values.</p>
<p>The result type should be provided explicitly, in the <code>result_type</code> field, and should be a scalar type with a type representation of either <code>Int64</code> or <code>Float64</code>, depending on whether the scalar type defining this function has an integer representation or floating point representation.</p>
<p>A <code>sum</code> function should ignore the order of its input values, and should be invariant of partitioning, that is: <code>sum(x, sum(y, z))</code> = <code>sum(x, y, z)</code> for any partitioning <code>x, y, z</code> of the input values. It should return <code>0</code> for an empty set of input values.</p>
<h4 id="average"><a class="header" href="#average"><code>average</code></a></h4>
<p>An aggregate function defined using type <code>average</code> should return the average of its provided values.</p>
<p>The result type should be provided explicitly, in the <code>result_type</code> field, and should be a scalar type with a type representation of <code>Float64</code>.</p>
<p>An <code>average</code> function should ignore the order of its input values. It should return <code>null</code> for an empty set of input values.</p>
<h4 id="min-max"><a class="header" href="#min-max"><code>min</code>, <code>max</code></a></h4>
<p>An aggregate function defined using type <code>min</code> or <code>max</code> should return the minimal/maximal value from its provided values, according to some ordering.</p>
<p>Its implicit result type, i.e. the type of the aggregated values, is the same as the scalar type on which the function is defined, but with nulls allowed if not allowed already.</p>
<p>A <code>min</code>/<code>max</code> function should return null for an empty set of input values.</p>
<p>If the set of input values is a singleton, then the function should return the single value.</p>
<p>A <code>min</code>/<code>max</code> function should ignore the order of its input values, and should be invariant of partitioning, that is: <code>min(x, min(y, z))</code> = <code>min(x, y, z)</code> for any partitioning <code>x, y, z</code> of the input values.</p>
<h3 id="custom-aggregate-functions"><a class="header" href="#custom-aggregate-functions">Custom Aggregate Functions</a></h3>
<p>A custom aggregate function has type <code>custom</code> and is defined by its <em>result type</em> - that is, the type of the aggregated data. The result type can be any type, not just a scalar type.</p>
<h2 id="extraction-functions-1"><a class="header" href="#extraction-functions-1">Extraction Functions</a></h2>
<p>Extraction functions extend the query AST with the ability to <em>extract</em> components from a value with a scalar type. Extraction functions can be used to <a href="specification/schema/../queries/grouping.html#extraction-functions-and-complex-dimensions">group by components of a scalar type</a>.</p>
<p>For example, a <code>Date</code> scalar type might expose extraction functions which extract the individual year, month and day components as integers.</p>
<p>Just like for comparison operators and aggregate functions, an extraction function is either a <em>standard</em> function, or a custom function.</p>
<p>To define an extraction function, add a <a href="specification/schema/../../reference/types.html#extractionfunctiondefinition"><code>ExtractionFunctionDefinition</code></a> to the <code>extraction_functions</code> field of the schema response.</p>
<p>For example:</p>
<pre><code class="language-json">{
  "scalar_types": {
    "Date": {
      "extraction_functions": {
        "year": {
          "type": "year",
          "result_type": "Int"
        },
      }
      "aggregate_functions": {},
      "comparison_operators": {}
    }
  },
  ...
}
</code></pre>
<h3 id="standard-extraction-functions"><a class="header" href="#standard-extraction-functions">Standard Extraction Functions</a></h3>
<p>The following standard extraction functions are supported:</p>
<ul>
<li><code>Day</code></li>
<li><code>DayOfWeek</code></li>
<li><code>DayOfYear</code></li>
<li><code>Hour</code></li>
<li><code>Microsecond</code></li>
<li><code>Millisecond</code></li>
<li><code>Minute</code></li>
<li><code>Month</code></li>
<li><code>Nanosecond</code></li>
<li><code>Quarter</code></li>
<li><code>Second</code></li>
<li><code>Week</code></li>
<li><code>Year</code></li>
</ul>
<p>For each of these, the return type should be a scalar type whose representation is one of <code>int8</code>, <code>int16</code>, <code>int32</code>, or <code>int64</code>.</p>
<h3 id="custom-extraction-functions"><a class="header" href="#custom-extraction-functions">Custom Extraction Functions</a></h3>
<p>A custom extraction function has type <code>custom</code> and is defined by its <em>result type</em> - that is, the type of the extracted data. The result type can be any type, not just a scalar type.</p>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#scalartype"><code>ScalarType</code></a></li>
<li><a href="specification/schema/../queries/filtering.html"><code>Filtering</code></a></li>
<li><a href="specification/schema/../queries/sorting.html"><code>Sorting</code></a></li>
<li><a href="specification/schema/../queries/aggregates.html"><code>Aggregates</code></a></li>
<li><a href="specification/schema/../queries/grouping.html"><code>Grouping</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-types"><a class="header" href="#object-types">Object Types</a></h1>
<p>The schema should define any named <em>object types</em> which will be used as the types of <a href="specification/schema/./collections.html">collection</a> row sets, or <a href="specification/schema/./procedures.html">procedure</a> inputs or outputs.</p>
<p>An object type consists of a name and a collection of named fields. Each field is defined by its <a href="specification/schema/../types.html">type</a>, and any <a href="specification/schema/../queries/arguments.html">arguments</a>.</p>
<p><em>Note</em>: field arguments are only used in a query context. Objects with field arguments cannot be used as input types, and fields with arguments cannot be used to define <a href="specification/schema/../queries/relationships.html#column-mappings">column mappings</a>, or in <a href="specification/schema/../queries/filtering.html#referencing-nested-fields-within-columns">nested field references</a>.</p>
<p>Object types can also define "foreign keys", which are an indicator that a <a href="specification/schema/../queries/relationships.html">relationship</a> exists between columns on this object type and a row in a <code>collection</code>.</p>
<p>To define an object type, add an <a href="specification/schema/../../reference/types.html#objecttype"><code>ObjectType</code></a> to the <code>object_types</code> field of the schema response.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-json">{
  "object_types": {
    "coords": {
      "description": "Latitude and longitude",
      "fields": {
        "latitude": {
          "description": "Latitude in degrees north of the equator",
          "arguments": {},
          "type": {
            "type": "named",
            "name": "Float"
          }
        },
        "longitude": {
          "description": "Longitude in degrees east of the Greenwich meridian",
          "arguments": {},
          "type": {
            "type": "named",
            "name": "Float"
          }
        }
      },
      "foreign_keys": {}
    },
    ...
  },
  ...
}
</code></pre>
<h2 id="extended-example"><a class="header" href="#extended-example">Extended Example</a></h2>
<p>Object types can refer to other object types in the types of their fields, and make use of other <a href="specification/schema/../types.html">type structure</a> such as array types and nullable types.</p>
<p>In the context of array types, it can be useful to use <a href="specification/schema/../queries/arguments.html">arguments</a> on fields to allow the caller to customize the response.</p>
<p>For example, here we define a type <code>widget</code>, and a second type which contains a <code>widgets</code> field, parameterized by a <code>limit</code> argument:</p>
<pre><code class="language-json">{
  "object_types": {
    "widget": {
      "description": "Description of a widget",
      "fields": {
        "id": {
          "description": "Primary key",
          "arguments": {},
          "type": {
            "type": "named",
            "name": "ID"
          }
        },
        "name": {
          "description": "Name of this widget",
          "arguments": {},
          "type": {
            "type": "named",
            "name": "String"
          }
        }
      },
      "foreign_keys": {}
    },
    "inventory": {
      "description": "The items in stock",
      "fields": {
        "widgets": {
          "description": "Those widgets currently in stock",
          "arguments": {
            "limit": {
              "description": "The maximum number of widgets to fetch",
              "argument_type": {
                "type": "named",
                "name": "Int"
              }
            }
          },
          "type": {
            "type": "array",
            "element_type": {
              "type": "named",
              "name": "widget"
            }
          }
        }
      },
      "foreign_keys": {}
    }
  },
  ...
}
</code></pre>
<h2 id="foreign-keys-example"><a class="header" href="#foreign-keys-example">Foreign Keys Example</a></h2>
<p>Foreign keys can be defined on an object type to hint that a <a href="specification/schema/../queries/relationships.html">relationship</a> can be established between this object type and a collection. The column mapping maps fields from the object type to field paths on the foreign collection. The field path is an array of field names; an array of one field name simply indicates a field on the object type of the collection. More than one element in the array indicates a path through nested object types, following the field names in order.</p>
<pre><code class="language-json">{
  "object_types": {
    "article": {
      "description": "An article",
      "fields": {
        "author_id": {
          "description": "The article's author ID",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "id": {
          "description": "The article's primary key",
          "type": {
            "type": "named",
            "name": "Int"
          }
        },
        "title": {
          "description": "The article's title",
          "type": {
            "type": "named",
            "name": "String"
          }
        }
      },
      "foreign_keys": {
        "Article_AuthorID": {
          "column_mapping": {
            "author_id": ["id"]
          },
          "foreign_collection": "authors"
        }
      }
    }
  }
}
</code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#objecttype"><code>ObjectType</code></a></li>
<li>Type <a href="specification/schema/../../reference/types.html#objectfield"><code>ObjectField</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>The schema should define the metadata for any <em>collections</em> which can be queried using the query endpoint, or mutated using the mutation endpoint.</p>
<p>Each collection is defined by its name, any collection <a href="specification/schema/../queries/arguments.html">arguments</a>, the <a href="specification/schema/./object-types.html">object type</a> of its rows, and some additional metadata related to permissions and constraints.</p>
<p>To describe a collection, add a <a href="specification/schema/../../reference/types.html#collectioninfo"><code>CollectionInfo</code></a> structure to the <code>collections</code> field of the schema response.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>The <code>type</code> field should name an object type which is defined in the schema response.</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-json">{
  "collections": [
    {
      "name": "articles",
      "description": "A collection of articles",
      "arguments": {},
      "type": "article",
      "deletable": false,
      "uniqueness_constraints": {
        "ArticleByID": {
          "unique_columns": [
            "id"
          ]
        }
      }
    },
    {
      "name": "authors",
      "description": "A collection of authors",
      "arguments": {},
      "type": "author",
      "deletable": false,
      "uniqueness_constraints": {
        "AuthorByID": {
          "unique_columns": [
            "id"
          ]
        }
      }
    }
  ],
  ...
}
</code></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#collectioninfo"><code>CollectionInfo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Functions are a special case of <a href="specification/schema/./collections.html">collections</a>, which are identified separately in the schema for convenience.</p>
<p>A function is a collection which returns a single row and a single column, named <code>__value</code>. Like collections, functions can have arguments. Unlike collections, functions cannot be used by the mutations endpoint, do not describe constraints, and only provide a type for the <code>__value</code> column, not the name of an object type.</p>
<p><em>Note</em>: even though a function acts like a collection returning a row type with a single column, there is no need to define and name such a type in the <code>object_types</code> section of the schema response.</p>
<p>To describe a function, add a <a href="specification/schema/../../reference/types.html#FunctionInfo"><code>FunctionInfo</code></a> structure to the <code>functions</code> field of the schema response.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-json">{
  "functions": [
    {
      "name": "latest_article_id",
      "description": "Get the ID of the most recent article",
      "arguments": {},
      "result_type": {
        "type": "nullable",
        "underlying_type": {
          "type": "named",
          "name": "Int"
        }
      }
    }
  ],
  ...
}
</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#FunctionInfo"><code>FunctionInfo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures-1"><a class="header" href="#procedures-1">Procedures</a></h1>
<p>The schema should define metadata for each <em>procedure</em> which the data connector implements.</p>
<p>Each procedure is defined by its name, any arguments types and a result type.</p>
<p>To describe a procedure, add a <a href="specification/schema/../../reference/types.html#procedureinfo"><code>ProcedureInfo</code></a> structure to the <code>procedure</code> field of the schema response.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-json">{
  "procedures": [
    {
      "name": "upsert_article",
      "description": "Insert or update an article",
      "arguments": {
        "article": {
          "description": "The article to insert or update",
          "type": {
            "type": "named",
            "name": "article"
          }
        }
      },
      "result_type": {
        "type": "named",
        "name": "article"
      }
    }
  ],
  ...
}
</code></pre>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#procedureinfo"><code>ProcedureInfo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities-1"><a class="header" href="#capabilities-1">Capabilities</a></h1>
<p>The schema response should also provide any capability-specific data, based on the set of enabled <a href="specification/schema/../capabilities.html">capabilities</a>.</p>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<ul>
<li>If the <code>query.aggregates</code> capability is enabled, then the schema response should include the <code>capabilities.query.aggregates</code> object, which has type <a href="specification/schema/../../reference/types.html#aggregatecapabilitiesschemainfo"><code>AggregateCapabilitiesSchemaInfo</code></a>.
<ul>
<li>This object should indicate the scalar type used as count aggregate result type, in order to implement <a href="specification/schema/../queries/aggregates.html">aggregates</a>.</li>
</ul>
</li>
</ul>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><code class="language-json">{
  ...
  "capabilities": {
    "query": {
      "aggregates": {
        "count_scalar_type": "Int"
      }
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-level-arguments"><a class="header" href="#request-level-arguments">Request-level arguments</a></h1>
<p>Request-level arguments are arguments that are passed to the request itself, rather than to a specific query or procedure.</p>
<p>These can be used to pass things like authentication tokens that change dynamically.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><code class="language-json">{
  "query_arguments": {
    "connection_timeout": {
      "description": "Timeout for connecting to data source (ms)",
      "type": {
        "type": "named",
        "name": "int"
      }
    }
  },
  "mutation_arguments": {
    "use_transaction": {
      "description": "Whether to run the mutations in this request within a single transaction",
      "type": {
        "type": "named",
        "name": "bool"
      }
    }
  }
  ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>The query endpoint accepts a query request, containing expressions to be evaluated in the context the data source, and returns a response consisting of relevant rows of data.</p>
<p>The structure and requirements for specific fields listed below will be covered in subsequent chapters.</p>
<h2 id="request-4"><a class="header" href="#request-4">Request</a></h2>
<pre><code>POST /query
</code></pre>
<h2 id="request-5"><a class="header" href="#request-5">Request</a></h2>
<p>See <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a></p>
<h2 id="request-fields"><a class="header" href="#request-fields">Request Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>collection</code></td><td>The name of a collection to query</td></tr>
<tr><td><code>query</code></td><td>The query syntax tree</td></tr>
<tr><td><code>arguments</code></td><td>Values to be provided to any top-level <a href="specification/queries/./arguments.html">collection arguments</a></td></tr>
<tr><td><code>collection_relationships</code></td><td>Any <a href="specification/queries/./relationships.html">relationships</a> between collections involved in the query request</td></tr>
<tr><td><code>variables</code></td><td>One set of <a href="specification/queries/./variables.html">named variables</a> for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned.</td></tr>
<tr><td><code>request_arguments</code></td><td>Values to be provided to any request-level arguments, defined in the <code>query_arguments</code> section of the <a href="specification/queries/../schema/arguments.html">schema response</a>.</td></tr>
<tr><td></td><td></td></tr>
</tbody></table>
</div>
<h2 id="response-4"><a class="header" href="#response-4">Response</a></h2>
<p>See <a href="specification/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a></p>
<h2 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h2>
<ul>
<li>If the request specifies <code>variables</code>, then the response must contain one <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> for each collection of variables provided. If not, the data connector should respond as if <code>variables</code> were set to a single empty collection of variables: <code>[{}]</code>.</li>
<li>If the request specifies <code>fields</code>, then the response must contain <code>rows</code> according to the <a href="specification/queries/../schema/README.html">schema</a> advertised for the requested <code>collection</code>.</li>
<li>If the request specifies <code>aggregates</code> then the response must contain <code>aggregates</code>, with one response key per requested aggregate, using the same keys. See <a href="specification/queries/./aggregates.html">aggregates</a>.</li>
<li>If the request specifies <code>arguments</code>, then the implementation must validate the provided arguments against the types specified by the collection's <a href="specification/queries/../schema/README.html">schema</a>. See <a href="specification/queries/./arguments.html">arguments</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-selection"><a class="header" href="#field-selection">Field Selection</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> can specify which fields to fetch. The available fields are either</p>
<ul>
<li>the columns on the selected collection (i.e. those advertised in the corresponding <a href="specification/queries/../../reference/types.html#collectioninfo"><code>CollectionInfo</code></a> structure in the <a href="specification/queries/../schema/collections.html">schema response</a>), or</li>
<li>fields from <a href="specification/queries/./relationships.html">related collections</a></li>
</ul>
<p>The requested fields are specified as a collection of <a href="specification/queries/../../reference/types.html#field"><code>Field</code></a> structures in the <code>field</code> property on the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a>.</p>
<h2 id="field-arguments-1"><a class="header" href="#field-arguments-1">Field Arguments</a></h2>
<p>Arguments can be supplied to fields via the <code>arguments</code> key. These match the format described in <a href="specification/queries/../arguments.html">the arguments documentation</a>.</p>
<p>The <a href="specification/queries/../schema/object-types.html">schema response</a> will specify which fields take arguments via its respective <code>arguments</code> key.</p>
<p>If a field has any arguments defined, then the <code>arguments</code> field must be provided wherever that field is referenced. All fields are required, including nullable fields.</p>
<h2 id="nested-fields"><a class="header" href="#nested-fields">Nested Fields</a></h2>
<p>Queries can specify nested field selections for columns which have structured types (that is, not simply a scalar type or a nullable scalar type).</p>
<p>In order to specify nested field selections, the <code>fields</code> property of the <code>Field</code> structure, which is a <a href="specification/queries/../../reference/types.html#nestedfield"><code>NestedField</code></a> structure.</p>
<p>If <code>fields</code> is omitted, the entire structure of the column's data should be returned.</p>
<p>If <code>fields</code> is provided, its value should be compatible with the type of the column:</p>
<h3 id="nested-objects"><a class="header" href="#nested-objects">Nested objects</a></h3>
<p>For an object-typed column (whether nullable or not), the <code>fields</code> property should contain a <code>NestedField</code> with type <code>object</code>.</p>
<p>The <code>fields</code> property of the <code>NestedField</code> specifies a <a href="specification/queries/../../reference/types.html#field"><code>Field</code></a> structure for each requested nested field from the objects.</p>
<h3 id="nested-arrays"><a class="header" href="#nested-arrays">Nested arrays</a></h3>
<p>For an array-typed column (whether nullable or not), the <code>fields</code> property may contain a <code>NestedField</code> with type <code>array</code>.</p>
<p>The <code>fields</code> property of the <code>NestedField</code> should contain <em>another</em> <code>NestedField</code> structure, compatible with the type of the elements of the array. The selection function denoted by this nested <code>NestedField</code> structure should be applied to each element of each array.</p>
<h3 id="nested-collections-1"><a class="header" href="#nested-collections-1">Nested collections</a></h3>
<p>For a column whose type is an array of objects (whether nullable or not), the <code>fields</code> property may contain a <code>NestedField</code> with type <code>collection</code>.</p>
<p>A connector should handle such fields by treating the nested array of objects as a collection. Such a field will include a nested <code>Query</code>, and the connector should execute that query in the context of this nested collection.</p>
<p>A response for a field with a <code>fields</code> property of type <code>collection</code> should be a <code>RowSet</code> which is computed from the nested collection by executing the specified query.</p>
<p><em>Note</em>: support for nested collection queries is indicated by the <code>query.nested_fields.nested_collections</code> capability.</p>
<h3 id="nested-fields-and-relationships"><a class="header" href="#nested-fields-and-relationships">Nested fields and relationships</a></h3>
<p>Within the scope of a nested object, that object should be used as the "current row" wherever that concept is appropriate:</p>
<ul>
<li>In a <code>Field::Column</code> field, the column name points to a field of the nested object,</li>
<li>In a <code>Field::Relationship</code> field:
<ul>
<li>A <a href="specification/queries/./relationships.html#column-mappings">column mapping</a> refers to fields from the nested object,</li>
<li>A <a href="specification/queries/./arguments.html#relationships">relationship argument</a> which selects a column refers to fields of the nested object.</li>
</ul>
</li>
</ul>
<p>Note that only connectors that enable the <code>relationships.nested</code> capability will receive queries where relationships start from a nested object. Additionally, only connectors that enable the <code>relationships.nested.array</code> will receive queries where relationships start from nested objects inside nested arrays.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="simple-column-selection"><a class="header" href="#simple-column-selection">Simple column selection</a></h3>
<p>Here is an example of a query which selects some columns from the <code>articles</code> collection of the reference data connector:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h3 id="example-with-nested-object-types"><a class="header" href="#example-with-nested-object-types">Example with Nested Object Types</a></h3>
<p>Here is an example of a query which selects some columns from a nested object inside the rows of the <code>institutions</code> collection of the reference data connector:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "location": {
        "type": "column",
        "column": "location",
        "fields": {
          "type": "object",
          "fields": {
            "city": {
              "type": "column",
              "column": "city"
            },
            "campuses": {
              "type": "column",
              "column": "campuses",
              "arguments": {
                "limit": {
                  "type": "literal",
                  "value": null
                }
              }
            }
          }
        }
      },
      "location_all": {
        "type": "column",
        "column": "location"
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>Notice that the <code>location</code> column is fetched twice: once to illustrate the use of the <code>fields</code> property, to fetch a subset of data, and again in the <code>location_all</code> field, which omits the <code>fields</code> property and fetches the entire structure.</p>
<h3 id="example-with-nested-array-types"><a class="header" href="#example-with-nested-array-types">Example with Nested Array Types</a></h3>
<p>Here is an example of a query which selects some columns from a nested array inside the rows of the <code>institutions</code> collection of the reference data connector:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "staff": {
        "type": "column",
        "column": "staff",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        },
        "fields": {
          "type": "array",
          "fields": {
            "type": "object",
            "fields": {
              "last_name": {
                "type": "column",
                "column": "last_name"
              },
              "fields_of_study": {
                "type": "column",
                "column": "specialities",
                "arguments": {
                  "limit": {
                    "type": "literal",
                    "value": null
                  }
                }
              }
            }
          }
        }
      },
      "departments": {
        "type": "column",
        "column": "departments",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>Notice that the <code>staff</code> column is fetched using a <code>fields</code> property of type <code>array</code>. For each staff member in each institution row, we apply the selection function denoted by its <code>fields</code> property (of type <code>object</code>). Specifically, the <code>last_name</code> and <code>specialities</code> properties are selected for each staff member.</p>
<h3 id="example-with-a-nested-collection"><a class="header" href="#example-with-a-nested-collection">Example with a Nested Collection</a></h3>
<p>Here is an example of a query which computes aggregates over a nested collection inside the <code>staff</code> field of each row of the <code>institutions</code> collection:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "staff_aggregates": {
        "type": "column",
        "column": "staff",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        },
        "field_path": [],
        "fields": {
          "type": "collection",
          "query": {
            "aggregates": {
              "count": {
                "type": "star_count"
              }
            }
          }
        }
      },
      "staff": {
        "type": "column",
        "column": "staff",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        },
        "fields": {
          "type": "array",
          "fields": {
            "type": "object",
            "fields": {
              "last_name": {
                "type": "column",
                "column": "last_name"
              },
              "first_name": {
                "type": "column",
                "column": "first_name"
              }
            }
          }
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>Note the <code>staff_aggregates</code> field in particular, which has <code>fields</code> with type <code>collection</code>.</p>
<h3 id="example-with-nested-types-and-relationships"><a class="header" href="#example-with-nested-types-and-relationships">Example with Nested Types and Relationships</a></h3>
<p>This query selects <code>institution</code> data, and fetches <code>author</code> data if the first and last name fields match for any nested <code>staff</code> objects:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "name": {
        "type": "column",
        "column": "name"
      },
      "staff": {
        "type": "column",
        "column": "staff",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        },
        "fields": {
          "type": "array",
          "fields": {
            "type": "object",
            "fields": {
              "first_name": {
                "type": "column",
                "column": "first_name"
              },
              "last_name": {
                "type": "column",
                "column": "last_name"
              },
              "author": {
                "type": "relationship",
                "arguments": {},
                "query": {
                  "aggregates": null,
                  "fields": {
                    "id": {
                      "type": "column",
                      "column": "id"
                    },
                    "first_name": {
                      "type": "column",
                      "column": "first_name"
                    },
                    "last_name": {
                      "type": "column",
                      "column": "last_name"
                    }
                  }
                },
                "relationship": "author_by_first_and_last"
              }
            }
          }
        }
      }
    }
  },
  "collection_relationships": {
    "author_by_first_and_last": {
      "arguments": {},
      "column_mapping": {
        "first_name": ["first_name"],
        "last_name": ["last_name"]
      },
      "relationship_type": "object",
      "target_collection": "authors"
    }
  }
}
</code></pre>
<p>Note that the <code>first_name</code> and <code>last_name</code> properties in the column mapping are evaluated in the context of the nested <code>staff</code> object, and <em>not</em> in the context of the original <code>institution</code> row.</p>
<h3 id="example-with-field-arguments"><a class="header" href="#example-with-field-arguments">Example with Field Arguments</a></h3>
<p>Here is an example of a query which selects some columns from a nested array inside the rows of the <code>institutions</code> collection of the reference data connector and uses the <code>limit</code> field argument to limit the number of items returned:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "staff": {
        "type": "column",
        "column": "staff",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": 1
          }
        },
        "fields": {
          "type": "array",
          "fields": {
            "type": "object",
            "fields": {
              "last_name": {
                "type": "column",
                "column": "last_name"
              },
              "fields_of_study": {
                "type": "column",
                "column": "specialities",
                "arguments": {
                  "limit": {
                    "type": "literal",
                    "value": 2
                  }
                }
              }
            }
          }
        }
      },
      "departments": {
        "type": "column",
        "column": "departments",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h2 id="requirements-4"><a class="header" href="#requirements-4">Requirements</a></h2>
<ul>
<li>If the <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a> contains a <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> which specifies <code>fields</code>, then each <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> in the response should contain the <code>rows</code> property, and each row should contain all of the requested fields.</li>
</ul>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#rowfieldvalue"><code>RowFieldValue</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filtering"><a class="header" href="#filtering">Filtering</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> can specify a predicate expression which should be used to filter rows considered during <a href="specification/queries/../field-selection.html">field selection</a> for returning rows. The predicate expression also filters the rows that are <a href="specification/queries/../aggregates.html">aggregated across</a> and <a href="specification/queries/../grouping.html">grouped over</a> (ie. it filters the input rows to the aggregation/grouping operation).</p>
<p>A predicate expression can be one of</p>
<ul>
<li>An application of a <em>comparison operator</em> to a column and a value, or</li>
<li>An <code>EXISTS</code> expression, or</li>
<li>A <em>conjunction</em> of other expressions, or</li>
<li>A <em>disjunction</em> of other expressions, or</li>
<li>A <em>negation</em> of another expression</li>
</ul>
<p>The predicate expression is specified in the <code>predicate</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<h2 id="comparison-operators-1"><a class="header" href="#comparison-operators-1">Comparison Operators</a></h2>
<h3 id="unary-operators"><a class="header" href="#unary-operators">Unary Operators</a></h3>
<p>Unary comparison operators are denoted by expressions with a <code>type</code> field of <code>unary_comparison_operator</code>.</p>
<p>The only supported unary operator currently is <code>is_null</code>, which return <code>true</code> when a column value is <code>null</code>:</p>
<pre><code class="language-json">{
  "type": "unary_comparison_operator",
  "operator": "is_null",
  "column": {
    "name": "title"
  }
}
</code></pre>
<h3 id="binary-operators"><a class="header" href="#binary-operators">Binary Operators</a></h3>
<p>Binary comparison operators are denoted by expressions with a <code>type</code> field of <code>binary_comparison_operator</code>.</p>
<p>The set of available operators depends on the type of the column involved in the expression. The <code>operator</code> property should specify the name of one of the binary operators from the field's <a href="specification/queries/../schema/scalar-types.html">scalar type</a> definition.</p>
<p>The type <a href="specification/queries/../../reference/types.html#comparisonvalue"><code>ComparisonValue</code></a> describes the valid inhabitants of the <code>value</code> field. The <code>value</code> field should be an expression which evaluates to a value whose type is compatible with the definition of the comparison operator.</p>
<h4 id="equality-operators"><a class="header" href="#equality-operators">Equality Operators</a></h4>
<p>This example makes use of an <code>eq</code> operator, which is defined using the <code>equal</code> semantics, to test a single column for equality with a scalar value:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    },
    "predicate": {
      "type": "binary_comparison_operator",
      "column": {
        "type": "column",
        "name": "id"
      },
      "operator": "eq",
      "value": {
        "type": "scalar",
        "value": 1
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h4 id="set-membership-operators"><a class="header" href="#set-membership-operators">Set Membership Operators</a></h4>
<p>This example uses an <code>in</code> operator, which is defined using the <code>in</code> semantics, to test a single column for membership in a set of values:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    },
    "predicate": {
      "type": "binary_comparison_operator",
      "column": {
        "type": "column",
        "name": "author_id"
      },
      "operator": "in",
      "value": {
        "type": "scalar",
        "value": [1, 2]
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h4 id="custom-operators"><a class="header" href="#custom-operators">Custom Operators</a></h4>
<p>This example uses a custom <code>like</code> operator:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    },
    "predicate": {
      "type": "binary_comparison_operator",
      "column": {
        "type": "column",
        "name": "title"
      },
      "operator": "like",
      "value": {
        "type": "scalar",
        "value": "Functional"
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h3 id="nested-array-comparison-operators"><a class="header" href="#nested-array-comparison-operators">Nested Array Comparison Operators</a></h3>
<p>If the connector declares support for the <code>query.nested_fields.filter_by.nested_arrays</code> capability, it can receive expressions of type <code>array_comparison</code>. These expressions allow scalar array-specific comparisons against columns that contain an array of scalar values.</p>
<p>There are two supported comparison operators that connectors can declare support for:</p>
<ul>
<li><code>contains</code>: Whether or not the array contains the specified scalar value. This must be supported for all types that can be contained in an array that implement an 'eq' comparison operator.
<ul>
<li>Capability: <code>query.nested_fields.filter_by.nested_arrays.contains</code></li>
</ul>
</li>
<li><code>is_empty</code>: Whether or not the array is empty. This must be supported no matter what type is contained in the array.
<ul>
<li>Capability: <code>query.nested_fields.filter_by.nested_arrays.is_empty</code></li>
</ul>
</li>
</ul>
<p>This example finds <code>institutions</code> where the nested <code>location.campuses</code> array contains the <code>Lindholmen</code> value:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "name": {
        "type": "column",
        "column": "name"
      },
      "location": {
        "type": "column",
        "column": "location",
        "fields": {
          "type": "object",
          "fields": {
            "campuses": {
              "type": "column",
              "column": "campuses",
              "arguments": {
                "limit": {
                  "type": "literal",
                  "value": null
                }
              }
            }
          }
        }
      }
    },
    "predicate": {
      "type": "array_comparison",
      "column": {
        "type": "column",
        "name": "location",
        "field_path": ["campuses"]
      },
      "comparison": {
        "type": "contains",
        "value": {
          "type": "scalar",
          "value": "Lindholmen"
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>This example finds <code>countries</code> which have an empty <code>cities</code> array:</p>
<pre><code class="language-json">{
  "collection": "countries",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "name": {
        "type": "column",
        "column": "name"
      },
      "cities": {
        "type": "column",
        "column": "cities",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        }
      }
    },
    "predicate": {
      "type": "array_comparison",
      "column": {
        "type": "column",
        "name": "cities",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        }
      },
      "comparison": {
        "type": "is_empty"
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h3 id="columns-in-operators"><a class="header" href="#columns-in-operators">Columns in Operators</a></h3>
<p>Comparison operators compare values. The value on the left hand side of any operator is described by a <a href="specification/queries/../../reference/types.html#comparisontarget"><code>ComparisonTarget</code></a>, and the various cases will be explained next.</p>
<h4 id="referencing-a-column-from-the-same-collection"><a class="header" href="#referencing-a-column-from-the-same-collection">Referencing a column from the same collection</a></h4>
<p>If the <code>ComparisonTarget</code> has type <code>column</code>, then the <code>name</code> property refers to a column in the current collection. The <code>arguments</code> property allows clients to submit argument values for columns that require <a href="specification/queries/./arguments.html#field-arguments">arguments</a>.</p>
<h4 id="referencing-nested-fields-within-columns"><a class="header" href="#referencing-nested-fields-within-columns">Referencing nested fields within columns</a></h4>
<p>If the <code>field_path</code> property is empty or not present then the target is the value of the named column.</p>
<p>If <code>field_path</code> is non-empty then it refers to a path to a nested field within the named column</p>
<p><em>Note</em>: a <code>ComparisonTarget</code> may only have a non-empty <code>field_path</code> if the connector supports capability <code>query.nested_fields.filter_by</code>.</p>
<h4 id="computing-an-aggregate"><a class="header" href="#computing-an-aggregate">Computing an aggregate</a></h4>
<p>If the <code>ComparisonTarget</code> has type <code>aggregate</code>, then the target is an aggregate computed over a related collection. The relationship is described by the (non-empty) <code>path</code> field, and the aggregate to compute is specified in the <code>aggregate</code> field.</p>
<p>For example, this query finds authors who have written exactly 2 articles:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      }
    },
    "predicate": {
      "type": "binary_comparison_operator",
      "column": {
        "type": "aggregate",
        "aggregate": {
          "type": "star_count"
        },
        "path": [
          {
            "arguments": {},
            "relationship": "author_articles"
          }
        ]
      },
      "operator": "eq",
      "value": {
        "type": "scalar",
        "value": 2
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<p><em>Note</em>: type <code>aggregate</code> will only be sent if the <code>query.aggregates.filter_by</code> capability is turned on. If that capability is turned on, then the schema response should also contain the <code>capabilities.query.aggregates</code> object. That object should indicate the scalar type used for the result type of count aggregates (<code>star_count</code> and <code>column_count</code>), so that clients can know what comparison operators are valid.</p>
<h3 id="values-in-binary-operators"><a class="header" href="#values-in-binary-operators">Values in Binary Operators</a></h3>
<p>Binary (including array-valued) operators compare columns to <em>values</em>, but there are several types of valid values:</p>
<ul>
<li>Scalar values, as seen in the examples above, compare the column to a specific value,</li>
<li>Variable values compare the column to the current value of a <a href="specification/queries/./variables.html">variable</a>,</li>
<li>Column values compare the column to <em>another</em> column. The column may be on the same row, or it may be on a related row. Comparing against columns on related rows requires the connector to indicate support via the <code>relationships.relation_comparisons</code> capability.</li>
</ul>
<h4 id="referencing-a-column-from-a-collection-in-scope"><a class="header" href="#referencing-a-column-from-a-collection-in-scope">Referencing a column from a collection in scope</a></h4>
<p>When an expression appears inside one or more <a href="specification/queries/filtering.html#exists-expressions">exists expressions</a>, there are multiple collections in scope.</p>
<p>If the <code>query.exists.named_scopes</code> capability is enabled then these scopes can be named explicitly when referencing a column in an outer scope. The <code>scope</code> field of the <code>ComparisonValue</code> type can be used to specify the scope of a column reference.</p>
<p>Scopes are named by integers in the following manner:</p>
<ul>
<li>The scope named <code>0</code> refers to the current collection,</li>
<li>The scope named <code>1</code> refers to the collection under consideration outside the immediately-enclosing exists expression.</li>
<li>Scopes <code>2</code>, <code>3</code>, and so on, refer to the collections considered during the evaluation of expressions outside subsequently enclosing exists expressions.</li>
</ul>
<p>Therefore, the largest valid scope is the maximum nesting depth of exists expressions, up to the nearest enclosing <code>Query</code> object.</p>
<p>Put another way, we can consider a stack of scopes which grows as we descend into each nested exists expression. Each stack frame contains the collection currently under consideration. The named scopes are then the top-down indices of elements of this stack.</p>
<p>For example, we can express an equality between an <code>author_id</code> column and the <code>id</code> column of the enclosing <code>author</code> object (in scope <code>1</code>):</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "unrelated",
        "arguments": {},
        "collection": "articles"
      },
      "predicate": {
        "type": "and",
        "expressions": [
          {
            "type": "binary_comparison_operator",
            "column": {
              "type": "column",
              "name": "author_id"
            },
            "operator": "eq",
            "value": {
              "type": "column",
              "path": [],
              "name": "id",
              "scope": 1
            }
          },
          {
            "type": "binary_comparison_operator",
            "column": {
              "type": "column",
              "name": "title"
            },
            "operator": "like",
            "value": {
              "type": "scalar",
              "value": "Functional"
            }
          }
        ]
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h2 id="exists-expressions"><a class="header" href="#exists-expressions"><code>EXISTS</code> expressions</a></h2>
<p>An <code>EXISTS</code> expression tests whether a row exists in some possibly-related collection, and is denoted by an expression with a <code>type</code> field of <code>exists</code>.</p>
<p><code>EXISTS</code> expressions can query related or unrelated collections.</p>
<h3 id="related-collections"><a class="header" href="#related-collections">Related Collections</a></h3>
<p>Related collections are related to the original collection by a relationship in the <code>collection_relationships</code> field of the top-level <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a>.</p>
<p>For example, this query fetches authors who have written articles whose titles contain the string <code>"Functional"</code>:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "fields": {
            "id": {
              "type": "column",
              "column": "id"
            },
            "title": {
              "type": "column",
              "column": "title"
            }
          }
        }
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "related",
        "arguments": {},
        "relationship": "author_articles"
      },
      "predicate": {
        "type": "binary_comparison_operator",
        "column": {
          "type": "column",
          "name": "title"
        },
        "operator": "like",
        "value": {
          "type": "scalar",
          "value": "Functional"
        }
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<h4 id="nested-relationships-1"><a class="header" href="#nested-relationships-1">Nested relationships</a></h4>
<p>If the related collection is related from a field inside a nested object, then the field path to the nested object can be first descended through using <code>field_path</code> before the relationship is navigated.</p>
<p>Only connectors that enable the <code>relationships.nested.filtering</code> capability will receive these sorts of queries.</p>
<p>In this example, the relationship joins from the nested <code>location.country_id</code> across to the <code>id</code> column on the <code>countries</code> collection.</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "name": {
        "type": "column",
        "column": "name"
      },
      "location": {
        "type": "column",
        "column": "location",
        "fields": {
          "type": "object",
          "fields": {
            "country_id": {
              "type": "column",
              "column": "country_id"
            },
            "country": {
              "type": "relationship",
              "relationship": "location_country",
              "arguments": {},
              "query": {
                "fields": {
                  "id": {
                    "type": "column",
                    "column": "id"
                  },
                  "name": {
                    "type": "column",
                    "column": "name"
                  },
                  "area_km2": {
                    "type": "column",
                    "column": "area_km2"
                  }
                }
              }
            }
          }
        }
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "related",
        "field_path": ["location"],
        "relationship": "location_country",
        "arguments": {}
      },
      "predicate": {
        "type": "binary_comparison_operator",
        "column": {
          "type": "column",
          "name": "area_km2"
        },
        "operator": "gt",
        "value": {
          "type": "scalar",
          "value": 300000
        }
      }
    }
  },
  "collection_relationships": {
    "location_country": {
      "arguments": {},
      "column_mapping": {
        "country_id": ["id"]
      },
      "relationship_type": "object",
      "target_collection": "countries"
    }
  }
}
</code></pre>
<h3 id="unrelated-collections"><a class="header" href="#unrelated-collections">Unrelated Collections</a></h3>
<p>If the <code>query.exists.unrelated</code> capability is enabled, then exists expressions can reference unrelated collections.</p>
<p>Unrelated exists expressions can be useful when using collections with <a href="specification/queries/./arguments.html">arguments</a>. For example, this query uses the unrelated <code>author_articles</code> collection, providing its arguments via the source row's columns:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "unrelated",
        "arguments": {
          "author_id": {
            "type": "column",
            "name": "id"
          }
        },
        "collection": "articles_by_author"
      },
      "predicate": {
        "type": "and",
        "expressions": [
          {
            "type": "binary_comparison_operator",
            "column": {
              "type": "column",
              "name": "title"
            },
            "operator": "like",
            "value": {
              "type": "scalar",
              "value": "Functional"
            }
          }
        ]
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>It can also be useful to <a href="specification/queries/filtering.html#referencing-a-column-from-a-collection-in-scope">reference a column in another scope</a> when using unrelated exists expressions.</p>
<h3 id="nested-collections-2"><a class="header" href="#nested-collections-2">Nested Collections</a></h3>
<p>If the <code>query.exists.nested_collections</code> capability is enabled, then exists expressions can reference <a href="specification/queries/./field-selection.html#nested-collections">nested collections</a>.</p>
<p>For example, this query finds <code>institutions</code> which employ at least one staff member whose last name contains the letter <code>s</code>:</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "name": {
        "type": "column",
        "column": "name"
      },
      "staff": {
        "type": "column",
        "column": "staff",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        }
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "nested_collection",
        "arguments": {
          "limit": {
            "type": "literal",
            "value": null
          }
        },
        "column_name": "staff"
      },
      "predicate": {
        "type": "binary_comparison_operator",
        "column": {
          "type": "column",
          "name": "last_name"
        },
        "operator": "like",
        "value": {
          "type": "scalar",
          "value": "s"
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p><a href="specification/queries/filtering.html#referencing-a-column-from-a-collection-in-scope">References to columns in another scope</a> may be useful when using these sorts of expressions, in order to refer to columns from the outer (unnested) row.</p>
<h3 id="nested-scalar-collections"><a class="header" href="#nested-scalar-collections">Nested Scalar Collections</a></h3>
<p>If the <code>query.exists.nested_scalar_collections</code> capability is enabled, then exists expressions can reference columns that contain nested arrays of scalar values. In this case, each element of the nested array is lifted into a virtual row with the element value in a field called <code>__value</code>. This allows predicate applied to the exists to reference the <code>__value</code> column to compare against the scalar element.</p>
<p>For example, if there was a nested array such as <code>[1,2,3]</code>, it would be converted into a virtual rows <code>[{"__value": 1}, {"_value": 2}, {"_value": 3}]</code>.</p>
<p>For example, this query finds <code>institutions</code> that have at least one campus whose name contains the letter <code>d</code> (campuses are a string array nested inside location):</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "name": {
        "type": "column",
        "column": "name"
      },
      "location": {
        "type": "column",
        "column": "location",
        "fields": {
          "type": "object",
          "fields": {
            "campuses": {
              "type": "column",
              "column": "campuses",
              "arguments": {
                "limit": {
                  "type": "literal",
                  "value": null
                }
              }
            }
          }
        }
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "nested_scalar_collection",
        "column_name": "location",
        "field_path": ["campuses"],
        "arguments": {}
      },
      "predicate": {
        "type": "binary_comparison_operator",
        "column": {
          "type": "column",
          "name": "__value"
        },
        "operator": "like",
        "value": {
          "type": "scalar",
          "value": "d"
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h2 id="conjunction-of-expressions"><a class="header" href="#conjunction-of-expressions">Conjunction of expressions</a></h2>
<p>To express the conjunction of multiple expressions, specify a <code>type</code> field of <code>and</code>, and provide the expressions in the <code>expressions</code> field.</p>
<p>For example, to test if the <code>first_name</code> column is null <em>and</em> the <code>last_name</code> column is also null:</p>
<pre><code class="language-json">{
  "type": "and",
  "expressions": [
    {
      "type": "unary_comparison_operator",
      "operator": "is_null",
      "column": {
        "name": "first_name"
      }
    },
    {
      "type": "unary_comparison_operator",
      "operator": "is_null",
      "column": {
        "name": "last_name"
      }
    }
  ]
}
</code></pre>
<h2 id="disjunction-of-expressions"><a class="header" href="#disjunction-of-expressions">Disjunction of expressions</a></h2>
<p>To express the disjunction of multiple expressions, specify a <code>type</code> field of <code>or</code>, and provide the expressions in the <code>expressions</code> field.</p>
<p>For example, to test if the <code>first_name</code> column is null <em>or</em> the <code>last_name</code> column is also null:</p>
<pre><code class="language-json">{
  "type": "or",
  "expressions": [
    {
      "type": "unary_comparison_operator",
      "operator": "is_null",
      "column": {
        "name": "first_name"
      }
    },
    {
      "type": "unary_comparison_operator",
      "operator": "is_null",
      "column": {
        "name": "last_name"
      }
    }
  ]
}
</code></pre>
<h2 id="negation"><a class="header" href="#negation">Negation</a></h2>
<p>To express the negation of an expressions, specify a <code>type</code> field of <code>not</code>, and provide that expression in the <code>expression</code> field.</p>
<p>For example, to test if the <code>first_name</code> column is <em>not</em> null:</p>
<pre><code class="language-json">{
  "type": "not",
  "expression": {
    "type": "unary_comparison_operator",
    "operator": "is_null",
    "column": {
      "name": "first_name"
    }
  }
}
</code></pre>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#expression"><code>Expression</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> can specify how rows should be sorted in the response.</p>
<p>The requested ordering can be found in the <code>order_by</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<h2 id="computing-the-ordering"><a class="header" href="#computing-the-ordering">Computing the Ordering</a></h2>
<p>To compute the ordering from the <code>order_by</code> field, data connectors should implement the following ordering between rows:</p>
<ul>
<li>Consider each element of the <code>order_by.elements</code> array in turn.</li>
<li>For each <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>:
<ul>
<li>If <code>element.target.type</code> is <code>column</code>, then to compare two rows, compare the value in the selected column. See type <code>column</code> below.</li>
<li>If <code>element.target.type</code> is <code>aggregate</code>, compare two rows by comparing aggregates over a related collection. See type <code>aggregate</code> below.</li>
</ul>
</li>
</ul>
<h3 id="type-column"><a class="header" href="#type-column">Type <code>column</code></a></h3>
<p>The property <code>element.target.name</code> refers to a column name.
If the connector supports capability <code>query.nested_fields.order_by</code> then the target may also <a href="specification/queries/./filtering.html#referencing-nested-fields-within-columns">reference nested fields within a column</a> using the <code>field_path</code> property. If the column has <a href="specification/queries/./arguments.html#field-arguments">arguments</a>, the the <code>arguments</code> property is used to provide values for the arguments.</p>
<p>If <code>element.order_direction</code> is <code>asc</code>, then the row with the smaller column comes first.</p>
<p>If <code>element.order_direction</code> is <code>asc</code>, then the row with the smaller column comes second.</p>
<p>If the column values are incomparable, continue to the next <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>.</p>
<p>The data connector should document, for each scalar type, a comparison function to use for any two values of that scalar type.</p>
<p>For example, a data connector might choose to use the obvious ordering for a scalar integer-valued type, but to use the database-given ordering for a string-valued type, based on a certain choice of collation.</p>
<p>For example, the following <code>query</code> requests that a collection of articles be ordered by <code>title</code> descending:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    },
    "order_by": {
      "elements": [
        {
          "target": {
            "type": "column",
            "name": "title",
            "path": []
          },
          "order_direction": "desc"
        }
      ]
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>The selected column can be chosen from a related collection by specifying the <code>path</code> property. <code>path</code> consists of a list of named <a href="specification/queries/./relationships.html">relationships</a>.</p>
<p>For example, this query sorts articles by their author's last names, and then by their first names, by traversing the relationship from articles to authors:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      },
      "author": {
        "type": "relationship",
        "arguments": {},
        "relationship": "article_author",
        "query": {
          "fields": {
            "first_name": {
              "type": "column",
              "column": "first_name"
            },
            "last_name": {
              "type": "column",
              "column": "last_name"
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "target": {
            "type": "column",
            "name": "last_name",
            "path": [
              {
                "arguments": {},
                "relationship": "article_author",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          },
          "order_direction": "asc"
        },
        {
          "target": {
            "type": "column",
            "name": "first_name",
            "path": [
              {
                "arguments": {},
                "relationship": "article_author",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          },
          "order_direction": "asc"
        }
      ]
    }
  },
  "collection_relationships": {
    "article_author": {
      "arguments": {},
      "column_mapping": {
        "author_id": ["id"]
      },
      "relationship_type": "object",
      "source_collection_or_type": "article",
      "target_collection": "authors"
    }
  }
}
</code></pre>
<h4 id="nested-relationships-2"><a class="header" href="#nested-relationships-2">Nested relationships</a></h4>
<p>If the connector enables the <code>relationships.nested.ordering</code> capability, it may receive <code>path</code> relationships where the relationship starts from inside a nested object. The path to descend through the nested objects before navigating the relationship is specified by the <code>field_path</code> property.</p>
<p>For example, this query sorts <code>institutions</code> by their location's country's area. The relationship starts from within the <code>location</code> nested object and joins its <code>country_id</code> column to the <code>countries</code> collection's <code>id</code> column.</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "name": {
        "type": "column",
        "column": "name"
      },
      "location": {
        "type": "column",
        "column": "location",
        "fields": {
          "type": "object",
          "fields": {
            "country_id": {
              "type": "column",
              "column": "country_id"
            },
            "country": {
              "type": "relationship",
              "arguments": {},
              "relationship": "location_country",
              "query": {
                "fields": {
                  "id": {
                    "type": "column",
                    "column": "id"
                  },
                  "name": {
                    "type": "column",
                    "column": "name"
                  },
                  "area_km2": {
                    "type": "column",
                    "column": "area_km2"
                  }
                }
              }
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "desc",
          "target": {
            "type": "column",
            "path": [
              {
                "field_path": ["location"],
                "relationship": "location_country",
                "arguments": {},
                "predicate": null
              }
            ],
            "name": "area_km2",
            "field_path": []
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "location_country": {
      "arguments": {},
      "column_mapping": {
        "country_id": ["id"]
      },
      "relationship_type": "object",
      "target_collection": "countries"
    }
  }
}
</code></pre>
<h3 id="type-aggregate"><a class="header" href="#type-aggregate">Type <code>aggregate</code></a></h3>
<p>An ordering of type <code>aggregate</code> orders rows by aggregating rows in some <a href="specification/queries/./relationships.html">related collection</a>, and comparing aggregations for each of the two rows. The relationship path is specified by the <code>path</code> property. Connectors must enable the <code>relationships.order_by_aggregate</code> capability to receive this ordering type.</p>
<p>If the respective aggregates are incomparable, the ordering should continue to the next <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>.</p>
<p>If the connector enables the <code>relationships.nested.ordering</code> capability, it may receive <code>path</code> relationships where the relationship starts from inside a nested object. The path to descend through the nested objects before navigating the relationship is specified by the <code>field_path</code> property.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<p>For example, this query sorts article authors by their total article count:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles_aggregate": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "aggregates": {
            "count": {
              "type": "star_count"
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "desc",
          "target": {
            "type": "aggregate",
            "aggregate": {
              "type": "star_count"
            },
            "path": [
              {
                "arguments": {},
                "relationship": "author_articles",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<p>This query sorts article authors by their maximum article ID:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles_aggregate": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "aggregates": {
            "max_id": {
              "type": "single_column",
              "column": "id",
              "function": "max"
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "asc",
          "target": {
            "type": "aggregate",
            "aggregate": {
              "type": "single_column",
              "column": "id",
              "function": "max"
            },
            "path": [
              {
                "arguments": {},
                "relationship": "author_articles",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<p>This query sorts institutions first by those institutions that are in countries that have the most institutions in them, then by the institutions' name. This example navigates the nested relationship that begins in the <code>location</code> nested object and joins back onto the <code>institutions</code> collection, targeting the nested <code>location.country_id</code> property.</p>
<pre><code class="language-json">{
  "collection": "institutions",
  "arguments": {},
  "query": {
    "fields": {
      "name": {
        "type": "column",
        "column": "name"
      },
      "location": {
        "type": "column",
        "column": "location",
        "fields": {
          "type": "object",
          "fields": {
            "country_id": {
              "type": "column",
              "column": "country_id"
            },
            "country": {
              "type": "relationship",
              "arguments": {},
              "relationship": "location_institution_location_country",
              "query": {
                "fields": {
                  "name": {
                    "type": "column",
                    "column": "name"
                  },
                  "location": {
                    "type": "column",
                    "column": "location"
                  }
                }
              }
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "desc",
          "target": {
            "type": "aggregate",
            "path": [
              {
                "field_path": ["location"],
                "relationship": "location_institution_location_country",
                "arguments": {},
                "predicate": null
              }
            ],
            "aggregate": {
              "type": "star_count"
            }
          }
        },
        {
          "order_direction": "desc",
          "target": {
            "type": "column",
            "name": "name",
            "path": []
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "location_institution_location_country": {
      "arguments": {},
      "column_mapping": {
        "country_id": ["location", "country_id"]
      },
      "relationship_type": "array",
      "target_collection": "institutions"
    }
  }
}
</code></pre>
<h2 id="requirements-5"><a class="header" href="#requirements-5">Requirements</a></h2>
<ul>
<li>Rows in the response should be ordered according to the algorithm described above.</li>
<li>The <code>order_by</code> field should not affect the set of collection which are returned, except for their order.</li>
<li>If the <code>order_by</code> field is not provided then rows should be returned in an unspecified but deterministic order. For example, an implementation might choose to return rows in the order of their primary key or creation timestamp by default.</li>
</ul>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#orderby"><code>OrderBy</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#orderbytarget"><code>OrderByTarget</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagination"><a class="header" href="#pagination">Pagination</a></h1>
<p>The <code>limit</code> and <code>offset</code> parameters on the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object control pagination:</p>
<ul>
<li><code>limit</code> specifies the maximum number of rows that are considered during field selection and before aggregates and grouping are applied.</li>
<li><code>offset</code>: The index of the first row to consider during field selection and before aggregates and grouping are applied.</li>
</ul>
<p><code>limit</code> and <code>offset</code> are applied after the <a href="specification/queries/../filtering.html">predicate filter from the Query</a> is applied and after <a href="specification/queries/../sorting.html">sorting from the Query</a> is applied, but before <a href="specification/queries/../aggregates.html">aggregates</a> and <a href="specification/queries/../grouping.html">grouping</a> are applied. Both <code>limit</code> and <code>offset</code> affect the rows returned by field selection.</p>
<h2 id="requirements-6"><a class="header" href="#requirements-6">Requirements</a></h2>
<ul>
<li>If <code>limit</code> is specified, the response should contain at most that many rows, and aggregates and grouping should be applied to at most that many rows.</li>
</ul>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h1>
<p>In addition to fetching multiple rows of raw data from a collection, the query API supports fetching aggregated data. If a connector wants to support aggregates, it needs to enable the <code>query.aggregates</code> capability. It also needs to return the <a href="specification/queries/../schema/capabilities.html#requirements"><code>capabilities.query.aggregates</code></a> object from the schema to indicate which scalar type is used to return the result of count aggregates.</p>
<p>Aggregates are requested in the <code>aggregates</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<p>There are three types of aggregate:</p>
<ul>
<li><code>single_column</code> aggregates apply an aggregation function (as defined by the column's <a href="specification/queries/../schema/scalar-types.html">scalar type</a> in the schema response) to a column,</li>
<li><code>column_count</code> aggregates count the number of rows with non-null values in the specified columns. If the <code>distinct</code> flag is set, then the count should only count unique non-null values of those columns,</li>
<li><code>star_count</code> aggregates count all matched rows.</li>
</ul>
<p>If the connector supports capability <code>query.nested_fields.aggregates</code> then <code>single_column</code> and <code>column_count</code> aggregates may also <a href="specification/queries/./filtering.html#referencing-nested-fields-within-columns">reference nested fields within a column</a> using the <code>field_path</code> property.</p>
<p>If the column referenced in <code>single_column</code> and <code>column_count</code> aggregates has <a href="specification/queries/./arguments.html#field-arguments">arguments</a> defined for it in the schema, then the <code>arguments</code> property is used to provide values for those arguments.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<p>The following query object requests the aggregated sum of all order totals, along with the count of all orders, and the count of all orders which have associated invoices (via the nullable <code>invoice_id</code> column):</p>
<pre><code class="language-json">{
  "collection": ["orders"],
  "collection_relationships": {},
  "query": {
    "aggregates": {
      "orders_total": {
        "type": "single_column",
        "function": "sum",
        "column": "total"
      },
      "invoiced_orders_count": {
        "type": "column_count",
        "columns": ["invoice_id"]
      },
      "orders_count": {
        "type": "star_count"
      }
    }
  }
}
</code></pre>
<p>In this case, the query has no predicate function, so all three aggregates would be computed over all rows.</p>
<h2 id="requirements-7"><a class="header" href="#requirements-7">Requirements</a></h2>
<ul>
<li>Each aggregate should be computed over all rows that match the <code>Query</code>.</li>
<li>Each requested aggregate must be returned in the <code>aggregates</code> property on the <a href="specification/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a> object, using the same key as used to request it.</li>
</ul>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#aggregate"><code>Aggregate</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grouping-1"><a class="header" href="#grouping-1">Grouping</a></h1>
<p>If a connector supports <a href="specification/queries/./aggregates.html">aggregates</a>, it may also support <em>grouping</em> data and then aggregating data in those groups. This ability is tracked by the <code>query.aggregates.group_by</code> capability.</p>
<p>Grouping is requested in the query API alongside fields and aggregates, in the <code>groups</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<p>A grouping operation specifies one or more <em>dimensions</em> along which to partition the row set. Each dimension selects a column from which to draw values (see <a href="specification/queries/../../reference/types.html#dimension"><code>Dimension::Column</code></a>). For each group, every row should have equal values in each of those dimension columns.</p>
<p>If the dimension's column's schema defines <a href="specification/queries/./arguments.html#field-arguments">arguments</a>, then the <code>arguments</code> property is used to provide values for those arguments.</p>
<p>In addition, a grouping operation specifies <em>aggregates</em> which should be computed and returned for each group separately.</p>
<h2 id="dimensions"><a class="header" href="#dimensions">Dimensions</a></h2>
<p>Dimension columns can be:</p>
<ul>
<li>A column</li>
<li>A object-nested column</li>
<li>A column across an object relationship</li>
<li>A column across an object-nested object relationship</li>
</ul>
<p>A key property is that nested arrays or nested relationships cannot be traversed from the rows being grouped over when selecting a dimension column. Only nested objects or object relationships can be traversed.</p>
<h3 id="extraction-functions-and-complex-dimensions"><a class="header" href="#extraction-functions-and-complex-dimensions">Extraction Functions and Complex Dimensions</a></h3>
<p>We can also group by <em>components</em> of scalar types using <a href="specification/queries/../schema/scalar-types.html#extraction-functions">extraction functions</a>.</p>
<p>In order to apply an extraction function to the value of a dimension, the <code>Dimension</code> should specify an <code>extraction</code> property, which is the name of the extraction function to apply.</p>
<p>For example, this query groups articles by the <em>year</em> component of their published date:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "groups": {
      "aggregates": {
        "count": {
          "type": "star_count"
        }
      },
      "dimensions": [
        {
          "type": "column",
          "column_name": "published_date",
          "path": [],
          "extraction": "year"
        }
      ]
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h2 id="filtering-1"><a class="header" href="#filtering-1">Filtering</a></h2>
<p>Grouping operations have two types of filtering:</p>
<ul>
<li>The initial row set can be filtered <em>before the grouping operation</em>, using the <code>predicate</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object as usual, and</li>
<li>The <em>groups themselves</em> can be filtered <em>after the grouping operation</em>, using the <code>predicate</code> field of the <a href="specification/queries/../../reference/types.html#grouping"><code>Grouping</code></a> object. This is controlled by the <code>query.aggregates.group_by.filter</code> capability.</li>
</ul>
<p>Unlike regular predicates on rows, group predicates are not allowed to compare <em>columns</em>, but must instead compare values of <em>aggregates</em> over the group. For example, we can filter groups by comparing a <em>count</em> of rows in the group, but not by comparing values in individual rows.</p>
<h2 id="ordering"><a class="header" href="#ordering">Ordering</a></h2>
<p>As with filtering, group operations support two types of ordering:</p>
<ul>
<li>The initial row set can be ordered <em>before the grouping operation</em>, using the <code>order_by</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object as usual, and</li>
<li>The <em>groups themselves</em> can be ordered <em>after the grouping operation</em>, using the <code>order_by</code> field of the <a href="specification/queries/../../reference/types.html#grouping"><code>Grouping</code></a> object. This is controlled by the <code>query.aggregates.group_by.order</code> capability.</li>
</ul>
<p>Group sort orders are restricted to comparing aggregate values, similar to filtering. For example, we can order groups by a <em>count</em>, but not by the value of individual rows. However, we can also choose to sort by the selected grouping dimensions.</p>
<h2 id="pagination-1"><a class="header" href="#pagination-1">Pagination</a></h2>
<p>Pagination can also be applied both before and after grouping:</p>
<ul>
<li>The initial row set can be paginated <em>before the grouping operation</em>, using the <code>limit</code> and <code>offset</code> fields of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object as usual, and</li>
<li>The <em>groups themselves</em> can be paginated <em>after the grouping operation</em>, using the <code>limit</code> and <code>offset</code> fields of the <a href="specification/queries/../../reference/types.html#grouping"><code>Grouping</code></a> object. This is controlled by the <code>query.aggregates.group_by.paginate</code> capability.</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>This example partitions the <code>articles</code> collection by <code>author_id</code>, and then returns the row count for each group. That is, it computes the number of articles written by each author:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "groups": {
      "aggregates": {
        "article_count": {
          "type": "star_count"
        }
      },
      "dimensions": [
        {
          "type": "column",
          "column_name": "author_id",
          "path": []
        }
      ]
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h3 id="filtering-examples"><a class="header" href="#filtering-examples">Filtering examples</a></h3>
<p>This example applies a predicate to the rows <em>before grouping</em>:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "groups": {
      "aggregates": {
        "min_id": {
          "type": "single_column",
          "column": "id",
          "function": "min"
        },
        "max_id": {
          "type": "single_column",
          "column": "id",
          "function": "max"
        }
      },
      "dimensions": [
        {
          "type": "column",
          "column_name": "author_id",
          "path": []
        }
      ]
    },
    "predicate": {
      "type": "binary_comparison_operator",
      "column": {
        "type": "column",
        "name": "author_id",
        "path": []
      },
      "operator": "eq",
      "value": {
        "type": "scalar",
        "value": 1
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>This example applies a predicate to the groups themselves, <em>after grouping</em>. It computes some aggregates for author groups which have exactly two articles:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "groups": {
      "aggregates": {
        "min_id": {
          "type": "single_column",
          "column": "id",
          "function": "min"
        },
        "max_id": {
          "type": "single_column",
          "column": "id",
          "function": "max"
        }
      },
      "dimensions": [
        {
          "type": "column",
          "column_name": "author_id",
          "path": []
        }
      ],
      "predicate": {
        "type": "binary_comparison_operator",
        "target": {
          "type": "aggregate",
          "aggregate": {
            "type": "star_count"
          }
        },
        "operator": "eq",
        "value": {
          "type": "scalar",
          "value": 2
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h3 id="ordering-and-pagination"><a class="header" href="#ordering-and-pagination">Ordering and pagination</a></h3>
<p>This example computes the article count for the author with the most articles, by ordering the groups by article count, and then using pagination to select the first group:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "groups": {
      "aggregates": {
        "article_count": {
          "type": "star_count"
        }
      },
      "dimensions": [
        {
          "type": "column",
          "column_name": "author_id",
          "path": []
        }
      ],
      "limit": 1,
      "offset": 0,
      "order_by": {
        "elements": [
          {
            "order_direction": "desc",
            "target": {
              "type": "aggregate",
              "aggregate": {
                "type": "star_count"
              },
              "path": []
            }
          }
        ]
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>This example sorts the groups by the values of their dimensions. It groups articles by their <code>author_id</code>, and then sorts the groups by that <code>author_id</code> dimension, descending:</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "groups": {
      "aggregates": {
        "article_count": {
          "type": "star_count"
        }
      },
      "dimensions": [
        {
          "type": "column",
          "column_name": "author_id",
          "path": []
        }
      ],
      "order_by": {
        "elements": [
          {
            "order_direction": "desc",
            "target": {
              "type": "dimension",
              "index": 0,
              "path": []
            }
          }
        ]
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h2 id="requirements-8"><a class="header" href="#requirements-8">Requirements</a></h2>
<ul>
<li>If the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object specifies the <code>groups</code> field, then each correponding <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> object must contain a non-null <code>groups</code> field.</li>
<li>Each returned <a href="specification/queries/../../reference/types.html#group"><code>Group</code></a> object must contain values for each requested dimension, in the order in which they were requested:
<ul>
<li>The connector should effectively partition the <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> described by the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object into groups, such that the dimension tuples are unique within each group.</li>
</ul>
</li>
<li>Each returned <a href="specification/queries/../../reference/types.html#group"><code>Group</code></a> object must contain values for each requested aggregate, using the same key as used to request it:
<ul>
<li>Aggregates should be computed over the rows in each group in turn.</li>
</ul>
</li>
</ul>
<h2 id="see-also-12"><a class="header" href="#see-also-12">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#aggregate"><code>Aggregate</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#dimension"><code>Dimension</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#group"><code>Group</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#grouping"><code>Grouping</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arguments"><a class="header" href="#arguments">Arguments</a></h1>
<p><em>Request-level arguments</em> parameterize a request, and must be provided in every query request.</p>
<p><em>Collection arguments</em> parameterize an entire collection, and must be provided in queries wherever the collection is referenced, either directly, or via relationships.</p>
<p><em>Field</em> arguments parameterize a single field, and must be provided wherever that field is referenced.</p>
<h2 id="request-level-arguments-1"><a class="header" href="#request-level-arguments-1">Request-level Arguments</a></h2>
<p>Request-level arguments are specified in the <code>request_arguments</code> section of a <code>QueryRequest</code>. The set of provided arguments should be compatible with the list of arguments specified in the <code>query_arguments</code> section of the <a href="specification/queries/../schema/arguments.html">schema response</a>.</p>
<h2 id="collection-arguments-1"><a class="header" href="#collection-arguments-1">Collection Arguments</a></h2>
<p>Collection arguments should be provided in the <code>QueryRequest</code> anywhere a collection is referenced. The set of provided arguments should be compatible with the list of arguments required by the corresponding <a href="specification/queries/../schema/collections.html">collection in the schema response</a>.</p>
<h3 id="specifying-arguments-to-the-top-level-collection"><a class="header" href="#specifying-arguments-to-the-top-level-collection">Specifying arguments to the top-level collection</a></h3>
<p>Collection arguments should be provided as key-value pairs in the <code>arguments</code> property of the top-level <code>QueryRequest</code> object:</p>
<pre><code class="language-json">{
  "collection": "articles_by_author",
  "arguments": {
    "author_id": {
      "type": "literal",
      "value": 1
    }
  },
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<p><a href="specification/queries/./relationships.html">Relationships</a> can specify values for arguments on their target collection:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "fields": {
            "id": {
              "type": "column",
              "column": "id"
            },
            "title": {
              "type": "column",
              "column": "title"
            }
          }
        }
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {
        "author_id": {
          "type": "column",
          "name": "id"
        }
      },
      "column_mapping": {},
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles_by_author"
    }
  }
}
</code></pre>
<p>Any arguments which are not defined by the relationship itself should be specified where the relationship is used. For example, here the <code>author_id</code> argument can be moved from the relationship definition to the field which uses it:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles": {
        "type": "relationship",
        "arguments": {
          "author_id": {
            "type": "column",
            "name": "id"
          }
        },
        "relationship": "author_articles",
        "query": {
          "fields": {
            "id": {
              "type": "column",
              "column": "id"
            },
            "title": {
              "type": "column",
              "column": "title"
            }
          }
        }
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {},
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles_by_author"
    }
  }
}
</code></pre>
<h3 id="collection-arguments-in-predicates"><a class="header" href="#collection-arguments-in-predicates">Collection arguments in predicates</a></h3>
<p>Arguments must be specified in predicates whenever a reference to a secondary collection is required.</p>
<p>For example, in an <code>EXISTS</code> expression, if the target collection has arguments:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "related",
        "relationship": "author_articles",
        "arguments": {}
      },
      "predicate": {
        "type": "binary_comparison_operator",
        "column": {
          "type": "column",
          "name": "title"
        },
        "operator": "like",
        "value": {
          "type": "scalar",
          "value": "Functional"
        }
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {
        "author_id": {
          "type": "column",
          "name": "id"
        }
      },
      "column_mapping": {},
      "relationship_type": "array",
      "target_collection": "articles_by_author"
    }
  }
}
</code></pre>
<h3 id="collection-arguments-in-order_by"><a class="header" href="#collection-arguments-in-order_by">Collection arguments in <code>order_by</code></a></h3>
<p>Arguments must be specified when an <code>OrderByElement</code> references a related collection.</p>
<p>For example, when ordering by an aggregate of rows in a related collection, and that collection has arguments:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "desc",
          "target": {
            "type": "aggregate",
            "aggregate": {
              "type": "star_count"
            },
            "path": [
              {
                "arguments": {
                  "author_id": {
                    "type": "column",
                    "name": "id"
                  }
                },
                "relationship": "author_articles",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {},
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles_by_author"
    }
  }
}
</code></pre>
<h2 id="field-arguments-2"><a class="header" href="#field-arguments-2">Field Arguments</a></h2>
<blockquote>
<p><strong>CAUTION</strong></p>
<p>Field arguments considered somewhat unstable. Fields arguments are not well supported across all aspects of the specification. It is not recommended that field arguments are used, except for very specialized, advanced use cases.</p>
</blockquote>
<p>Field arguments can be provided to any field requested (in addition to those described for top-level collections).
These are specified in the <a href="specification/queries/../schema/object-types.html">schema response</a> and their use is described in <a href="specification/queries/./field-selection.html">field selection</a>. Their specification and usage matches that of collection arguments above.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationships-1"><a class="header" href="#relationships-1">Relationships</a></h1>
<p>Queries can request data from other collections via relationships. A relationship identifies rows in one collection (the "source collection") with possibly-many related rows in a second collection (the "target collection") in two ways:</p>
<ul>
<li>Columns in the two collections can be related via <em>column mappings</em>, and</li>
<li><a href="specification/queries/./arguments.html">Collection arguments</a> to the target collection can be computed via the row of the source collection.</li>
</ul>
<p>Connectors that support relationships should indicate so by enabling the <code>relationships</code> capability.</p>
<h2 id="defining-relationships"><a class="header" href="#defining-relationships">Defining Relationships</a></h2>
<p>Relationships are defined (and given names) in the top-level <code>QueryRequest</code> object, and then referred to by name everywhere they are used. To define a relationship, add a <a href="specification/queries/../../reference/types.html#relationship"><code>Relationship</code></a> object to the <code>collection_relationships</code> property of the <code>QueryRequest</code> object.</p>
<h2 id="column-mappings"><a class="header" href="#column-mappings">Column Mappings</a></h2>
<p>A column mapping is a set of pairs of columns - each consisting of one column from the source object type and one column from the target collection - which must be pairwise equal in order for a pair of rows to be considered equal.</p>
<p>What the source object type is depends on where the relationship is used. Often, a relationship will simply relate columns from one source collection's object type to a target collection's object type. However, at various locations such as field selection, filtering, ordering, grouping, queries can descend into nested objects and arrays before navigating the relationship. In these cases, the source column will be on the nested object type. Only connectors that enable the <code>relationships.nested</code> capability will encounter relationships that involve nested objects. Additionally, only connectors that enable the <code>relationships.nested.array</code> capability will encounter relationships that start from inside nested objects in nested arrays.</p>
<p>The column from the target collection may be an object-nested column, so it is specified using a field path to the column. An array of one field name specifies a column on the target collection's object type. Two field names specifies, firstly, the column on the target collection that contains a nested object, and secondly the column on the nested object type.</p>
<p>However, unless a connector enables the <code>relationships.nested</code> capability, it can expect to only receive field paths with only one entry in column mappings (ie. non-nested columns).</p>
<p>For example, we can fetch each <code>author</code> with its list of related <code>articles</code> by establishing a column mapping between the author's primary key and the article's <code>author_id</code> column:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "fields": {
            "id": {
              "type": "column",
              "column": "id"
            },
            "title": {
              "type": "column",
              "column": "title"
            }
          }
        }
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<h2 id="collection-arguments-2"><a class="header" href="#collection-arguments-2">Collection Arguments</a></h2>
<p>See <a href="specification/queries/./arguments.html">collection arguments</a> for examples.</p>
<h2 id="advanced-relationship-use-cases"><a class="header" href="#advanced-relationship-use-cases">Advanced relationship use cases</a></h2>
<p>Relationships are not used only for fetching data - they are used in practically all features of data connectors, as we will see below.</p>
<h3 id="relationships-in-predicates"><a class="header" href="#relationships-in-predicates">Relationships in predicates</a></h3>
<p><code>EXISTS</code> expressions in predicates can query related collections. Here we find all authors who have written any article with <code>"Functional"</code> in the title:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "fields": {
            "id": {
              "type": "column",
              "column": "id"
            },
            "title": {
              "type": "column",
              "column": "title"
            }
          }
        }
      }
    },
    "predicate": {
      "type": "exists",
      "in_collection": {
        "type": "related",
        "arguments": {},
        "relationship": "author_articles"
      },
      "predicate": {
        "type": "binary_comparison_operator",
        "column": {
          "type": "column",
          "name": "title"
        },
        "operator": "like",
        "value": {
          "type": "scalar",
          "value": "Functional"
        }
      }
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<h3 id="relationships-in-order_by"><a class="header" href="#relationships-in-order_by">Relationships in <code>order_by</code></a></h3>
<p>Sorting can be defined in terms of row counts and aggregates over related collections.</p>
<p>For example, here we order authors by the number of articles they have written:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles_aggregate": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "aggregates": {
            "count": {
              "type": "star_count"
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "desc",
          "target": {
            "type": "aggregate",
            "aggregate": {
              "type": "star_count"
            },
            "path": [
              {
                "arguments": {},
                "relationship": "author_articles",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<p>We can also order by custom aggregate functions applied to related collections. For example, here we order authors by their most recent (maximum) article ID:</p>
<pre><code class="language-json">{
  "collection": "authors",
  "arguments": {},
  "query": {
    "fields": {
      "first_name": {
        "type": "column",
        "column": "first_name"
      },
      "last_name": {
        "type": "column",
        "column": "last_name"
      },
      "articles_aggregate": {
        "type": "relationship",
        "arguments": {},
        "relationship": "author_articles",
        "query": {
          "aggregates": {
            "max_id": {
              "type": "single_column",
              "column": "id",
              "function": "max"
            }
          }
        }
      }
    },
    "order_by": {
      "elements": [
        {
          "order_direction": "asc",
          "target": {
            "type": "aggregate",
            "aggregate": {
              "type": "single_column",
              "column": "id",
              "function": "max"
            },
            "path": [
              {
                "arguments": {},
                "relationship": "author_articles",
                "predicate": {
                  "type": "and",
                  "expressions": []
                }
              }
            ]
          }
        }
      ]
    }
  },
  "collection_relationships": {
    "author_articles": {
      "arguments": {},
      "column_mapping": {
        "id": ["author_id"]
      },
      "relationship_type": "array",
      "source_collection_or_type": "author",
      "target_collection": "articles"
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a> can optionally specify one or more sets of variables which can be referenced throughout the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<p>Query variables will only be provided if the <code>query.variables</code> <a href="specification/queries/../capabilities.html">capability</a> is advertised in the capabilities response.</p>
<p>The intent is that the data connector should attempt to perform multiple versions of the query in parallel - one instance of the query for each set of variables. For each set of variables, each variable value should be substituted wherever it is referenced in the query - for example in a <a href="specification/queries/../../reference/types.html#comparisonvalue"><code>ComparisonValue</code></a>.</p>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<p>In the following query, we fetch two rowsets of article data. In each rowset, the rows are filtered based on the <code>author_id</code> column, and the prescribed <code>author_id</code> is determined by a variable. The choice of <code>author_id</code> varies between rowsets.</p>
<p>The result contains one rowset containing articles from the author with ID <code>1</code>, and a second for the author with ID <code>2</code>.</p>
<pre><code class="language-json">{
  "collection": "articles",
  "arguments": {},
  "query": {
    "fields": {
      "id": {
        "type": "column",
        "column": "id"
      },
      "title": {
        "type": "column",
        "column": "title"
      }
    },
    "predicate": {
      "type": "binary_comparison_operator",
      "column": {
        "type": "column",
        "name": "id"
      },
      "operator": "eq",
      "value": {
        "type": "variable",
        "name": "$article_id"
      }
    }
  },
  "collection_relationships": {},
  "variables": [
    {
      "$article_id": 1
    },
    {
      "$article_id": 2
    }
  ]
}
</code></pre>
<h2 id="requirements-9"><a class="header" href="#requirements-9">Requirements</a></h2>
<ul>
<li>If <code>variables</code> are provided in the <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a>, then the <a href="specification/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a> should contain one <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> for each set of variables, in the same order.</li>
<li>If <code>variables</code> are not provided, the data connector should return a single <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-2"><a class="header" href="#functions-2">Functions</a></h1>
<p>A <a href="specification/queries/../schema/functions.html">function</a> is invoked in a query request in exactly the same way as any other collection - recall that a function is simply a collection which returns a single row, and a single column, named <code>__value</code>.</p>
<p>Because a function returns a single row, many query capabilities are limited in their usefulness:</p>
<ul>
<li>It would not make sense to specify <code>limit</code> or <code>offset</code>,</li>
<li>Sorting has no effect</li>
<li>Filtering can only remove the whole result row, based on some condition expressed in terms of the <em>result</em>.</li>
</ul>
<p>However, some query functions are still useful in the context of functions:</p>
<ul>
<li>The caller can request a subset of the full result, by using <a href="specification/queries/./field-selection.html#nested-fields">nested field queries</a>,</li>
<li>A function can be the source or target of a <a href="specification/queries/./relationships.html">relationship</a>,</li>
<li>Function <a href="specification/queries/./arguments.html">arguments</a> are specified in the same way as collection arguments, and can also be specified using <a href="specification/queries/./variables.html">variables</a>.</li>
</ul>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<h3 id="a-function-returning-a-scalar-value"><a class="header" href="#a-function-returning-a-scalar-value">A function returning a scalar value</a></h3>
<p>This example uses the <code>latest_article_id</code> function, which returns a scalar type:</p>
<pre><code class="language-json">{
  "arguments": {},
  "query": {
    "fields": {
      "__value": {
        "type": "column",
        "column": "__value"
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>The response JSON includes the requested data in the special <code>__value</code> field:</p>
<pre><code class="language-json">[
  {
    "rows": [
      {
        "__value": 3
      }
    ]
  }
]
</code></pre>
<h3 id="a-function-returning-an-object-type"><a class="header" href="#a-function-returning-an-object-type">A function returning an object type</a></h3>
<p>This example uses the <code>latest_article</code> function instead, which returns the full <code>article</code> object. To query the object structure, it uses a <a href="specification/queries/./field-selection.html">nested field request</a>:</p>
<pre><code class="language-json">{
  "arguments": {},
  "query": {
    "fields": {
      "__value": {
        "type": "column",
        "column": "__value",
        "fields": {
          "type": "object",
          "fields": {
            "id": {
              "type": "column",
              "column": "id"
            },
            "title": {
              "type": "column",
              "column": "title"
            }
          }
        }
      }
    }
  },
  "collection_relationships": {}
}
</code></pre>
<p>Again, the response is sent in the <code>__value</code> field:</p>
<pre><code class="language-json">[
  {
    "rows": [
      {
        "__value": {
          "id": 3,
          "title": "The Design And Implementation Of Programming Languages"
        }
      }
    ]
  }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutations"><a class="header" href="#mutations">Mutations</a></h1>
<p>The mutation endpoint accepts a mutation request, containing a collection of mutation operations to be performed transactionally in the context the data source, and returns a response containing a result for each operation.</p>
<p>The structure and requirements for specific fields listed below will be covered in subsequent chapters.</p>
<h2 id="request-6"><a class="header" href="#request-6">Request</a></h2>
<pre><code>POST /mutation
</code></pre>
<h2 id="request-7"><a class="header" href="#request-7">Request</a></h2>
<p>See <a href="specification/mutations/../../reference/types.html#mutationrequest"><code>MutationRequest</code></a></p>
<h2 id="request-fields-1"><a class="header" href="#request-fields-1">Request Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>operations</code></td><td>A list of mutation operations to perform</td></tr>
<tr><td><code>collection_relationships</code></td><td>Any <a href="specification/mutations/../queries/relationships.html">relationships</a> between collections involved in the mutation request</td></tr>
<tr><td><code>request_arguments</code></td><td>Any arguments to be passed to the mutation request</td></tr>
</tbody></table>
</div>
<h2 id="mutation-operations"><a class="header" href="#mutation-operations">Mutation Operations</a></h2>
<p>Each operation is described by a <a href="specification/mutations/../../reference/types.html#mutationoperation"><code>MutationOperation</code></a> structure, which can be one of several types. However, currently <a href="specification/mutations/./procedures.html">procedures</a> are the only supported operation type.</p>
<h2 id="request-level-arguments-2"><a class="header" href="#request-level-arguments-2">Request-level Arguments</a></h2>
<p>Request-level arguments are specified in the <code>request_arguments</code> section of a <code>MutationRequest</code>. The set of provided arguments should be compatible with the list of arguments specified in the <code>mutation_arguments</code> section of the <a href="specification/mutations/../schema/arguments.html">schema response</a>.</p>
<h3 id="multiple-operations"><a class="header" href="#multiple-operations">Multiple Operations</a></h3>
<p>If the <code>mutation.transactional</code> capability is enabled, then the caller may provide multiple operations in a single request.
Otherwise, the caller must provide exactly one operation.</p>
<p>The intent is that multiple operations ought to be performed together in a single transaction.
That is, they should all succeed, or all fail together. If any operation fails, then a single <code>ErrorResponse</code> should capture
the failure, and none of the operations should effect any changes to the data source.</p>
<h2 id="response-5"><a class="header" href="#response-5">Response</a></h2>
<p>See <a href="specification/mutations/../../reference/types.html#mutationresponse"><code>MutationResponse</code></a></p>
<h2 id="requirements-10"><a class="header" href="#requirements-10">Requirements</a></h2>
<ul>
<li>The <code>operation_results</code> field of the <a href="specification/mutations/../../reference/types.html#mutationresponse"><code>MutationResponse</code></a> should contain one <a href="specification/mutations/../../reference/types.html#mutationoperationresults"><code>MutationOperationResults</code></a> structure for each requested operation in the <a href="specification/mutations/../../reference/types.html#mutationrequest"><code>MutationRequest</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures-2"><a class="header" href="#procedures-2">Procedures</a></h1>
<p>A procedure which is <a href="specification/mutations/../schema/procedures.html">described in the schema</a> can be invoked using a <a href="specification/mutations/../../reference/types.html#mutationoperation"><code>MutationOperation</code></a>.</p>
<p>The operation should specify the procedure name, any arguments, and a list of <a href="specification/mutations/../../reference/types.html#field"><code>Field</code></a>s to be returned.</p>
<p><em>Note</em>: just as for <a href="specification/mutations/../queries/functions.html">functions</a>, fields to return can include <a href="specification/mutations/../queries/relationships.html">relationships</a> or <a href="specification/mutations/../queries/field-selection.html#nested-fields">nested fields</a>. However, unlike functions, procedures do not need to wrap their result in a <code>__value</code> field, so top-level fields can be extracted without use of nested field queries.</p>
<h2 id="requirements-11"><a class="header" href="#requirements-11">Requirements</a></h2>
<ul>
<li>The <a href="specification/mutations/../../reference/types.html#mutationresponse"><code>MutationResponse</code></a> structure will contain a <a href="specification/mutations/../../reference/types.html#mutationoperationresults"><code>MutationOperationResults</code></a> structure for the procedure response. This structure should have type <code>procedure</code> and contain a <code>result</code> field with a result of the type indicated in the <a href="specification/mutations/../schema/procedures.html">schema response</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain"><a class="header" href="#explain">Explain</a></h1>
<p>There are two endpoints related to explain:</p>
<ul>
<li>The <code>/query/explain</code> endpoint, which accepts a <a href="specification/./queries/README.html">query</a> request.</li>
<li>The <code>/mutation/explain</code> endpoint, which accepts a <a href="specification/./mutation/README.html">mutation</a> request.</li>
</ul>
<p>Both endpoints return a representation of the <em>execution plan</em> without actually executing the query or mutation.</p>
<p>Connectors that wish to support these endpoints should indicate this in their capabilities; specifically with the <code>query.explain</code> capability and the <code>mutation.explain</code> capability.</p>
<h2 id="request-8"><a class="header" href="#request-8">Request</a></h2>
<pre><code>POST /query/explain
</code></pre>
<p>See <a href="specification/../reference/types.html#queryrequest"><code>QueryRequest</code></a></p>
<h2 id="request-9"><a class="header" href="#request-9">Request</a></h2>
<pre><code>POST /mutation/explain
</code></pre>
<p>See <a href="specification/../reference/types.html#mutationrequest"><code>MutationRequest</code></a></p>
<h2 id="response-6"><a class="header" href="#response-6">Response</a></h2>
<p>See <a href="specification/../reference/types.html#explainresponse"><code>ExplainResponse</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>In this tutorial, we will walk through the <em>reference implementation</em> of the specification, which will illustrate how to implement data connectors from scratch.</p>
<p>The reference implementation is written in Rust, but it should be possible to follow along using any language of your choice, as long as you can implement a basic web server and implement serializers and deserializers for the data formats involved.</p>
<p>It is recommended that you follow along chapter-by-chapter, as each will build on the last.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>To compile and run the reference implementation, you will need to install a Rust toolchain, and then run:</p>
<pre><code class="language-bash">git clone git@github.com:hasura/ndc-spec.git
cd ndc-spec/ndc-reference
cargo build
cargo run
</code></pre>
<p>Alternatively, you can run the reference implementation entirely inside a Docker container:</p>
<pre><code class="language-bash">git clone git@github.com:hasura/ndc-spec.git
cd ndc-spec
docker build -t reference_connector .
docker run -it reference_connector
</code></pre>
<p>Either way, you should have a working data connector running on <a href="http://localhost:8100/">http://localhost:8100/</a>, which you can test as follows:</p>
<pre><code class="language-bash">curl http://localhost:8100/schema
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Testing tools are provided in the specification repository to aid in the development of connectors.</p>
<h2 id="ndc-test-5"><a class="header" href="#ndc-test-5"><code>ndc-test</code></a></h2>
<p>The <code>ndc-test</code> executable performs basic validation of the data returned by the capabilities and schema endpoints, and performs some basic queries.</p>
<p>To test a connector, provide its endpoint to <code>ndc-test</code> on the command line:</p>
<pre><code class="language-sh">ndc-test --endpoint &lt;ENDPOINT&gt;
</code></pre>
<p>For example, running the reference connector and passing its URL to <code>ndc-test</code>, we will see that it issues test queries against the <code>articles</code> and <code>authors</code> collections:</p>
<pre><code class="language-text">ndc-test test --endpoint http://localhost:8100

Capabilities
├ Fetching /capabilities ... ... OK
├ Validating capabilities ... OK
Schema
├ Fetching /schema ... OK
├ Validating schema ...
│ ├ object_types ... OK
│ ├ Collections ...
│ │ ├ articles ...
│ │ │ ├ Arguments ... OK
│ │ │ ├ Collection type ... OK
│ │ ├ authors ...
│ │ │ ├ Arguments ... OK
│ │ │ ├ Collection type ... OK
│ │ ├ articles_by_author ...
│ │ │ ├ Arguments ... OK
│ │ │ ├ Collection type ... OK
│ ├ Functions ...
│ │ ├ latest_article_id ...
│ │ │ ├ Result type ... OK
│ │ │ ├ Arguments ... OK
│ │ ├ Procedures ...
│ │ │ ├ upsert_article ...
│ │ │ │ ├ Result type ... OK
│ │ │ │ ├ Arguments ... OK
Query
├ articles ...
│ ├ Simple queries ...
│ │ ├ Select top N ... OK
│ │ ├ Predicates ... OK
│ ├ Aggregate queries ...
│ │ ├ star_count ... OK
├ authors ...
│ ├ Simple queries ...
│ │ ├ Select top N ... OK
│ │ ├ Predicates ... OK
│ ├ Aggregate queries ...
│ │ ├ star_count ... OK
├ articles_by_author ...
</code></pre>
<p>However, <code>ndc-test</code> cannot validate the entire schema. For example, it will not issue queries against the <code>articles_by_author</code> collection, because it does not have any way to synthesize inputs for its required collection argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>The reference implementation will serve queries and mutations based on in-memory data read from newline-delimited JSON files.</p>
<p>First, we will define some types to represent the data in the newline-delimited JSON files. Rows of JSON data will be stored in memory as ordered maps:</p>
<pre><code class="language-rust no_run noplayground">type Row = BTreeMap&lt;models::FieldName, serde_json::Value&gt;;</code></pre>
<p>Our application state will consist of collections of various types of rows:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone)]
pub struct AppState {
    pub articles: BTreeMap&lt;i32, Row&gt;,
    pub authors: BTreeMap&lt;i32, Row&gt;,
    pub institutions: BTreeMap&lt;i32, Row&gt;,
    pub countries: BTreeMap&lt;i32, Row&gt;,
    pub metrics: Metrics,
}</code></pre>
<p>In our <code>main</code> function, the data connector reads the initial data from the newline-delimited JSON files, and creates the <code>AppState</code>:</p>
<pre><code class="language-rust no-run noplayground">fn init_app_state() -&gt; AppState {
    // Read the JSON data files
    let articles = read_json_lines(ARTICLES_JSON).unwrap();
    let authors = read_json_lines(AUTHORS_JSON).unwrap();
    let institutions = read_json_lines(INSTITUTIONS_JSON).unwrap();
    let countries = read_json_lines(COUNTRIES_JSON).unwrap();

    let metrics = Metrics::new().unwrap();

    AppState {
        articles,
        authors,
        institutions,
        countries,
        metrics,
    }
}</code></pre>
<p>Finally, we start a web server with the endpoints which are required by this specification:</p>
<pre><code class="language-rust no_run noplayground">#[tokio::main]
async fn main() -&gt; std::result::Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let app_state = Arc::new(Mutex::new(init_app_state()));

    let app = Router::new()
        .route("/health", get(get_health))
        .route("/metrics", get(get_metrics))
        .route("/capabilities", get(get_capabilities))
        .route("/schema", get(get_schema))
        .route("/query", post(post_query))
        .route("/query/explain", post(post_query_explain))
        .route("/mutation", post(post_mutation))
        .route("/mutation/explain", post(post_mutation_explain))
        .layer(axum::middleware::from_fn(check_version_header))
        .layer(axum::middleware::from_fn_with_state(
            Arc::clone(&amp;app_state),
            metrics_middleware,
        ))
        .with_state(app_state);

    // Start the server on `localhost:&lt;PORT&gt;`.
    // This says it's binding to an IPv6 address, but will actually listen to
    // any IPv4 or IPv6 address.
    let host = net::IpAddr::V6(net::Ipv6Addr::UNSPECIFIED);
    let port = env::var("PORT")
        .map(|s| s.parse())
        .unwrap_or(Ok(DEFAULT_PORT))?;
    let addr = net::SocketAddr::new(host, port);

    let listener = tokio::net::TcpListener::bind(addr).await?;
    println!("Serving on {}", listener.local_addr()?);
    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_handler())
        .await?;

    Ok(())
}</code></pre>
<p><em>Note</em>: the application state is stored in an <code>Arc&lt;Mutex&lt;_&gt;&gt;</code>, so that we can perform locking reads and writes in multiple threads.</p>
<p>In the next chapters, we will look at the implementation of each of these endpoints in turn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities-2"><a class="header" href="#capabilities-2">Capabilities</a></h1>
<p>The <a href="tutorial/../specification/capabilities.html">capabilities endpoint</a> should return data describing which features the data connector can implement, along with the version of this specification that the data connector claims to implement.</p>
<p>The reference implementation returns a static <code>CapabilitiesResponse</code>:</p>
<pre><code class="language-rust no_run noplayground">async fn get_capabilities() -&gt; Json&lt;models::CapabilitiesResponse&gt; {
    Json(models::CapabilitiesResponse {
        version: models::VERSION.into(),
        capabilities: models::Capabilities {
            query: models::QueryCapabilities {
                aggregates: Some(models::AggregateCapabilities {
                    filter_by: Some(models::LeafCapability {}),
                    group_by: Some(models::GroupByCapabilities {
                        filter: Some(models::LeafCapability {}),
                        order: Some(models::LeafCapability {}),
                        paginate: Some(models::LeafCapability {}),
                    }),
                }),
                variables: Some(models::LeafCapability {}),
                exists: models::ExistsCapabilities {
                    named_scopes: Some(models::LeafCapability {}),
                    unrelated: Some(models::LeafCapability {}),
                    nested_collections: Some(models::LeafCapability {}),
                    nested_scalar_collections: Some(models::LeafCapability {}),
                },
                explain: None,
                nested_fields: models::NestedFieldCapabilities {
                    filter_by: Some(models::NestedFieldFilterByCapabilities {
                        nested_arrays: Some(models::NestedArrayFilterByCapabilities {
                            contains: Some(models::LeafCapability {}),
                            is_empty: Some(models::LeafCapability {}),
                        }),
                    }),
                    order_by: Some(models::LeafCapability {}),
                    aggregates: Some(models::LeafCapability {}),
                    nested_collections: Some(models::LeafCapability {}),
                },
            },
            mutation: models::MutationCapabilities {
                transactional: None,
                explain: None,
            },
            relationships: Some(models::RelationshipCapabilities {
                order_by_aggregate: Some(models::LeafCapability {}),
                relation_comparisons: Some(models::LeafCapability {}),
                nested: Some(models::NestedRelationshipCapabilities {
                    array: Some(models::LeafCapability {}),
                    filtering: Some(models::LeafCapability {}),
                    ordering: Some(models::LeafCapability {}),
                }),
            }),
            relational_query: None,
            relational_mutation: None,
        },
    })
}</code></pre>
<p><em>Note</em>: the reference implementation supports all capabilities with the exception of <code>query.explain</code> and <code>mutation.explain</code>. This is because all queries are run in memory by naively interpreting the query request - there is no better description of the query plan than the raw query request itself!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-2"><a class="header" href="#schema-2">Schema</a></h1>
<p>The schema endpoint should return data describing the data connector's scalar and object types, along with any collections, functions and procedures which are exposed.</p>
<pre><code class="language-rust no_run noplayground">async fn get_schema() -&gt; Json&lt;models::SchemaResponse&gt; {
    // ...
    Json(models::SchemaResponse {
        scalar_types,
        object_types,
        collections,
        functions,
        procedures,
        capabilities,
        request_arguments,
    })
}</code></pre>
<h2 id="scalar-types-1"><a class="header" href="#scalar-types-1">Scalar Types</a></h2>
<p>We define two scalar types: <code>String</code> and <code>Int</code>.</p>
<p><code>String</code> supports a custom <code>like</code> comparison operator, and <code>Int</code> supports the standard aggregation operators <code>min</code> and <code>max</code>.</p>
<pre><code class="language-rust no_run noplayground">    let scalar_types = BTreeMap::from_iter([
        (
            "String".into(),
            models::ScalarType {
                representation: models::TypeRepresentation::String,
                aggregate_functions: BTreeMap::from_iter([
                    ("max".into(), models::AggregateFunctionDefinition::Max),
                    ("min".into(), models::AggregateFunctionDefinition::Min),
                ]),
                comparison_operators: BTreeMap::from_iter([
                    ("eq".into(), models::ComparisonOperatorDefinition::Equal),
                    (
                        "gt".into(),
                        models::ComparisonOperatorDefinition::GreaterThan,
                    ),
                    (
                        "gte".into(),
                        models::ComparisonOperatorDefinition::GreaterThanOrEqual,
                    ),
                    ("lt".into(), models::ComparisonOperatorDefinition::LessThan),
                    (
                        "lte".into(),
                        models::ComparisonOperatorDefinition::LessThanOrEqual,
                    ),
                    (
                        "contains".into(),
                        models::ComparisonOperatorDefinition::Contains,
                    ),
                    (
                        "icontains".into(),
                        models::ComparisonOperatorDefinition::ContainsInsensitive,
                    ),
                    (
                        "starts_with".into(),
                        models::ComparisonOperatorDefinition::StartsWith,
                    ),
                    (
                        "istarts_with".into(),
                        models::ComparisonOperatorDefinition::StartsWithInsensitive,
                    ),
                    (
                        "ends_with".into(),
                        models::ComparisonOperatorDefinition::EndsWith,
                    ),
                    (
                        "iends_with".into(),
                        models::ComparisonOperatorDefinition::EndsWithInsensitive,
                    ),
                    ("in".into(), models::ComparisonOperatorDefinition::In),
                    (
                        "like".into(),
                        models::ComparisonOperatorDefinition::Custom {
                            argument_type: models::Type::Named {
                                name: "String".into(),
                            },
                        },
                    ),
                ]),
                extraction_functions: BTreeMap::new(),
            },
        ),
        (
            "Int".into(),
            models::ScalarType {
                representation: models::TypeRepresentation::Int32,
                aggregate_functions: BTreeMap::from_iter([
                    ("max".into(), models::AggregateFunctionDefinition::Max),
                    ("min".into(), models::AggregateFunctionDefinition::Min),
                    (
                        "sum".into(),
                        models::AggregateFunctionDefinition::Sum {
                            result_type: models::ScalarTypeName::from("Int64"),
                        },
                    ),
                    (
                        "avg".into(),
                        models::AggregateFunctionDefinition::Average {
                            result_type: models::ScalarTypeName::from("Float"),
                        },
                    ),
                ]),
                comparison_operators: BTreeMap::from_iter([
                    ("eq".into(), models::ComparisonOperatorDefinition::Equal),
                    ("in".into(), models::ComparisonOperatorDefinition::In),
                    (
                        "gt".into(),
                        models::ComparisonOperatorDefinition::GreaterThan,
                    ),
                    (
                        "gte".into(),
                        models::ComparisonOperatorDefinition::GreaterThanOrEqual,
                    ),
                    ("lt".into(), models::ComparisonOperatorDefinition::LessThan),
                    (
                        "lte".into(),
                        models::ComparisonOperatorDefinition::LessThanOrEqual,
                    ),
                ]),
                extraction_functions: BTreeMap::new(),
            },
        ),
        (
            "Int64".into(),
            models::ScalarType {
                representation: models::TypeRepresentation::Int64,
                aggregate_functions: BTreeMap::from_iter([
                    ("max".into(), models::AggregateFunctionDefinition::Max),
                    ("min".into(), models::AggregateFunctionDefinition::Min),
                    (
                        "sum".into(),
                        models::AggregateFunctionDefinition::Sum {
                            result_type: models::ScalarTypeName::from("Int64"),
                        },
                    ),
                    (
                        "avg".into(),
                        models::AggregateFunctionDefinition::Average {
                            result_type: models::ScalarTypeName::from("Float"),
                        },
                    ),
                ]),
                comparison_operators: BTreeMap::from_iter([
                    ("eq".into(), models::ComparisonOperatorDefinition::Equal),
                    ("in".into(), models::ComparisonOperatorDefinition::In),
                    (
                        "gt".into(),
                        models::ComparisonOperatorDefinition::GreaterThan,
                    ),
                    (
                        "gte".into(),
                        models::ComparisonOperatorDefinition::GreaterThanOrEqual,
                    ),
                    ("lt".into(), models::ComparisonOperatorDefinition::LessThan),
                    (
                        "lte".into(),
                        models::ComparisonOperatorDefinition::LessThanOrEqual,
                    ),
                ]),
                extraction_functions: BTreeMap::new(),
            },
        ),
        (
            "Float".into(),
            models::ScalarType {
                representation: models::TypeRepresentation::Float64,
                aggregate_functions: BTreeMap::from_iter([
                    ("max".into(), models::AggregateFunctionDefinition::Max),
                    ("min".into(), models::AggregateFunctionDefinition::Min),
                    (
                        "sum".into(),
                        models::AggregateFunctionDefinition::Sum {
                            result_type: models::ScalarTypeName::from("Float"),
                        },
                    ),
                    (
                        "avg".into(),
                        models::AggregateFunctionDefinition::Average {
                            result_type: models::ScalarTypeName::from("Float"),
                        },
                    ),
                ]),
                comparison_operators: BTreeMap::from_iter([
                    ("eq".into(), models::ComparisonOperatorDefinition::Equal),
                    ("in".into(), models::ComparisonOperatorDefinition::In),
                    (
                        "gt".into(),
                        models::ComparisonOperatorDefinition::GreaterThan,
                    ),
                    (
                        "gte".into(),
                        models::ComparisonOperatorDefinition::GreaterThanOrEqual,
                    ),
                    ("lt".into(), models::ComparisonOperatorDefinition::LessThan),
                    (
                        "lte".into(),
                        models::ComparisonOperatorDefinition::LessThanOrEqual,
                    ),
                ]),
                extraction_functions: BTreeMap::new(),
            },
        ),
        (
            "Date".into(),
            models::ScalarType {
                representation: models::TypeRepresentation::Date,
                aggregate_functions: BTreeMap::new(),
                comparison_operators: BTreeMap::from_iter([
                    ("eq".into(), models::ComparisonOperatorDefinition::Equal),
                    ("in".into(), models::ComparisonOperatorDefinition::In),
                ]),
                extraction_functions: BTreeMap::from_iter([
                    (
                        "year".into(),
                        models::ExtractionFunctionDefinition::Year {
                            result_type: models::ScalarTypeName::from("Int"),
                        },
                    ),
                    (
                        "month".into(),
                        models::ExtractionFunctionDefinition::Month {
                            result_type: models::ScalarTypeName::from("Int"),
                        },
                    ),
                    (
                        "day".into(),
                        models::ExtractionFunctionDefinition::Day {
                            result_type: models::ScalarTypeName::from("Int"),
                        },
                    ),
                ]),
            },
        ),
    ]);</code></pre>
<h2 id="object-types-1"><a class="header" href="#object-types-1">Object Types</a></h2>
<p>For each collection, we define an object type for its rows. In addition, we define object types for any nested types which we use:</p>
<pre><code class="language-rust no_run noplayground">    let object_types = BTreeMap::from_iter([
        ("article".into(), article_type),
        ("author".into(), author_type),
        ("institution".into(), institution_type),
        ("location".into(), location_type),
        ("staff_member".into(), staff_member_type),
        ("country".into(), country_type),
        ("city".into(), city_type),
    ]);</code></pre>
<h3 id="author"><a class="header" href="#author">Author</a></h3>
<pre><code class="language-rust no_run noplayground">    let author_type = models::ObjectType {
        description: Some("An author".into()),
        fields: BTreeMap::from_iter([
            (
                "id".into(),
                models::ObjectField {
                    description: Some("The author's primary key".into()),
                    r#type: models::Type::Named { name: "Int".into() },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "first_name".into(),
                models::ObjectField {
                    description: Some("The author's first name".into()),
                    r#type: models::Type::Named {
                        name: "String".into(),
                    },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "last_name".into(),
                models::ObjectField {
                    description: Some("The author's last name".into()),
                    r#type: models::Type::Named {
                        name: "String".into(),
                    },
                    arguments: BTreeMap::new(),
                },
            ),
        ]),
        foreign_keys: BTreeMap::new(),
    };</code></pre>
<h3 id="article"><a class="header" href="#article">Article</a></h3>
<pre><code class="language-rust no_run noplayground">    let article_type = models::ObjectType {
        description: Some("An article".into()),
        fields: BTreeMap::from_iter([
            (
                "id".into(),
                models::ObjectField {
                    description: Some("The article's primary key".into()),
                    r#type: models::Type::Named { name: "Int".into() },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "title".into(),
                models::ObjectField {
                    description: Some("The article's title".into()),
                    r#type: models::Type::Named {
                        name: "String".into(),
                    },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "author_id".into(),
                models::ObjectField {
                    description: Some("The article's author ID".into()),
                    r#type: models::Type::Named { name: "Int".into() },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "published_date".into(),
                models::ObjectField {
                    description: Some("The article's date of publication".into()),
                    r#type: models::Type::Named {
                        name: "Date".into(),
                    },
                    arguments: BTreeMap::new(),
                },
            ),
        ]),
        foreign_keys: BTreeMap::from_iter([(
            "Article_AuthorID".into(),
            models::ForeignKeyConstraint {
                foreign_collection: "authors".into(),
                column_mapping: BTreeMap::from_iter([("author_id".into(), vec!["id".into()])]),
            },
        )]),
    };</code></pre>
<h3 id="institution"><a class="header" href="#institution">Institution</a></h3>
<p><em>Note</em>: the fields with array types have field-level arguments (<code>array_arguments</code>) in order to support nested array operations.</p>
<pre><code class="language-rust no_run noplayground">    let institution_type = models::ObjectType {
        description: Some("An institution".into()),
        fields: BTreeMap::from_iter([
            (
                "id".into(),
                models::ObjectField {
                    description: Some("The institution's primary key".into()),
                    r#type: models::Type::Named { name: "Int".into() },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "name".into(),
                models::ObjectField {
                    description: Some("The institution's name".into()),
                    r#type: models::Type::Named {
                        name: "String".into(),
                    },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "location".into(),
                models::ObjectField {
                    description: Some("The institution's location".into()),
                    r#type: models::Type::Named {
                        name: "location".into(),
                    },
                    arguments: BTreeMap::new(),
                },
            ),
            (
                "staff".into(),
                models::ObjectField {
                    description: Some("The institution's staff".into()),
                    r#type: models::Type::Array {
                        element_type: Box::new(models::Type::Named {
                            name: "staff_member".into(),
                        }),
                    },
                    arguments: array_arguments.clone(),
                },
            ),
            (
                "departments".into(),
                models::ObjectField {
                    description: Some("The institution's departments".into()),
                    r#type: models::Type::Array {
                        element_type: Box::new(models::Type::Named {
                            name: "String".into(),
                        }),
                    },
                    arguments: array_arguments.clone(),
                },
            ),
        ]),
        foreign_keys: BTreeMap::new(),
    };</code></pre>
<h2 id="collections-1"><a class="header" href="#collections-1">Collections</a></h2>
<p>We define each collection's schema using the type information defined above:</p>
<pre><code class="language-rust no_run noplayground">    let collections = vec![
        articles_collection,
        authors_collection,
        institutions_collection,
        countries_collection,
        articles_by_author_collection,
    ];</code></pre>
<h3 id="author-1"><a class="header" href="#author-1">Author</a></h3>
<pre><code class="language-rust no_run noplayground">    let authors_collection = models::CollectionInfo {
        name: "authors".into(),
        description: Some("A collection of authors".into()),
        collection_type: "author".into(),
        arguments: BTreeMap::new(),
        uniqueness_constraints: BTreeMap::from_iter([(
            "AuthorByID".into(),
            models::UniquenessConstraint {
                unique_columns: vec!["id".into()],
            },
        )]),
        relational_mutations: None,
    };</code></pre>
<h3 id="article-1"><a class="header" href="#article-1">Article</a></h3>
<pre><code class="language-rust no_run noplayground">    let articles_collection = models::CollectionInfo {
        name: "articles".into(),
        description: Some("A collection of articles".into()),
        collection_type: "article".into(),
        arguments: BTreeMap::new(),
        uniqueness_constraints: BTreeMap::from_iter([(
            "ArticleByID".into(),
            models::UniquenessConstraint {
                unique_columns: vec!["id".into()],
            },
        )]),
        relational_mutations: None,
    };</code></pre>
<h3 id="articles_by_author"><a class="header" href="#articles_by_author"><code>articles_by_author</code></a></h3>
<p>We define one additional collection, <code>articles_by_author</code>, which is provided as an example of a collection with an argument:</p>
<pre><code class="language-rust no_run noplayground">    let articles_by_author_collection = models::CollectionInfo {
        name: "articles_by_author".into(),
        description: Some("Articles parameterized by author".into()),
        collection_type: "article".into(),
        arguments: BTreeMap::from_iter([(
            "author_id".into(),
            models::ArgumentInfo {
                argument_type: models::Type::Named { name: "Int".into() },
                description: None,
            },
        )]),
        uniqueness_constraints: BTreeMap::new(),
        relational_mutations: None,
    };</code></pre>
<h3 id="institution-1"><a class="header" href="#institution-1">Institution</a></h3>
<pre><code class="language-rust no_run noplayground">    let institutions_collection = models::CollectionInfo {
        name: "institutions".into(),
        description: Some("A collection of institutions".into()),
        collection_type: "institution".into(),
        arguments: BTreeMap::new(),
        uniqueness_constraints: BTreeMap::from_iter([(
            "InstitutionByID".into(),
            models::UniquenessConstraint {
                unique_columns: vec!["id".into()],
            },
        )]),
        relational_mutations: None,
    };</code></pre>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<p>The schema defines a list of <a href="tutorial/../specification/schema/functions.html">functions</a>, each including its input and output <a href="tutorial/../specification/types.html">types</a>.</p>
<h3 id="get-latest-article"><a class="header" href="#get-latest-article">Get Latest Article</a></h3>
<p>As an example, we define a <code>latest_article_id</code> function, which returns a single integer representing the maximum article ID.</p>
<pre><code class="language-rust no_run noplayground">    let latest_article_id_function = models::FunctionInfo {
        name: "latest_article_id".into(),
        description: Some("Get the ID of the most recent article".into()),
        result_type: models::Type::Nullable {
            underlying_type: Box::new(models::Type::Named { name: "Int".into() }),
        },
        arguments: BTreeMap::new(),
    };</code></pre>
<p>A second example returns the full corresponding article, to illustrate functions returning structured types:</p>
<pre><code class="language-rust no_run noplayground">    let latest_article_function = models::FunctionInfo {
        name: "latest_article".into(),
        description: Some("Get the most recent article".into()),
        result_type: models::Type::Nullable {
            underlying_type: Box::new(models::Type::Named {
                name: "article".into(),
            }),
        },
        arguments: BTreeMap::new(),
    };</code></pre>
<h2 id="procedures-3"><a class="header" href="#procedures-3">Procedures</a></h2>
<p>The schema defines a list of <a href="tutorial/../specification/schema/procedures.html">procedures</a>, each including its input and output <a href="tutorial/../specification/types.html">types</a>.</p>
<h3 id="upsert-article"><a class="header" href="#upsert-article">Upsert Article</a></h3>
<p>As an example, we define an <em>upsert</em> procedure for the article collection defined above. The procedure will accept an input argument of type <code>article</code>, and returns a nulcollection <code>article</code>, representing the state of the article before the update, if it were already present.</p>
<pre><code class="language-rust no_run noplayground">    let upsert_article = models::ProcedureInfo {
        name: "upsert_article".into(),
        description: Some("Insert or update an article".into()),
        arguments: BTreeMap::from_iter([(
            "article".into(),
            models::ArgumentInfo {
                description: Some("The article to insert or update".into()),
                argument_type: models::Type::Named {
                    name: "article".into(),
                },
            },
        )]),
        result_type: models::Type::Nullable {
            underlying_type: Box::new(models::Type::Named {
                name: "article".into(),
            }),
        },
    };</code></pre>
<h2 id="capability-specific-information"><a class="header" href="#capability-specific-information">Capability-specific information</a></h2>
<p>The schema response includes required <a href="tutorial/../specification/schema/capabilities.html">capability-specific information</a>:</p>
<pre><code class="language-rust no_run noplayground">    let capabilities = Some(models::CapabilitySchemaInfo {
        query: Some(models::QueryCapabilitiesSchemaInfo {
            aggregates: Some(ndc_models::AggregateCapabilitiesSchemaInfo {
                count_scalar_type: "Int".into(),
            }),
        }),
    });</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries-1"><a class="header" href="#queries-1">Queries</a></h1>
<p>The reference implementation of the <code>/query</code> endpoint may seem complicated, because there is a lot of functionality packed into a single endpoint. However, we will break the implementation down into small sections, each of which should be easily understood.</p>
<p>We start by looking at the type signature of the <code>post_query</code> function, which is the top-level function implementing the query endpoint:</p>
<pre><code class="language-rust no_run noplayground">pub async fn post_query(
    State(state): State&lt;Arc&lt;Mutex&lt;AppState&gt;&gt;&gt;,
    Json(request): Json&lt;models::QueryRequest&gt;,
) -&gt; Result&lt;Json&lt;models::QueryResponse&gt;&gt; {</code></pre>
<p>This function accepts a <a href="tutorial/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a> and must produce a <a href="tutorial/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a>.</p>
<p>In the next section, we will start to break down this problem step-by-step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="query-variables"><a class="header" href="#query-variables">Query Variables</a></h1>
<p>The first step in <code>post_query</code> is to reduce the problem from a query with multiple sets of <a href="tutorial/queries/../../specification/queries/variables.html">query variables</a> to only a single set.</p>
<p>The <code>post_query</code> function iterates over all variable sets, and for each one, produces a <a href="tutorial/queries/../../reference/types.html#rowset"><code>RowSet</code></a> of rows corresponding to that set of variables. Each <code>RowSet</code> is then added to the final <code>QueryResponse</code>:</p>
<pre><code class="language-rust no_run noplayground">pub async fn post_query(
    State(state): State&lt;Arc&lt;Mutex&lt;AppState&gt;&gt;&gt;,
    Json(request): Json&lt;models::QueryRequest&gt;,
) -&gt; Result&lt;Json&lt;models::QueryResponse&gt;&gt; {
    let state = state.lock().await;

    let variable_sets = request.variables.unwrap_or(vec![BTreeMap::new()]);

    let mut row_sets = vec![];

    for variables in &amp;variable_sets {
        let row_set = execute_query_with_variables(
            &amp;request.collection,
            &amp;request.arguments,
            &amp;request.collection_relationships,
            &amp;request.query,
            variables,
            &amp;state,
        )?;
        row_sets.push(row_set);
    }

    Ok(Json(models::QueryResponse(row_sets)))
}</code></pre>
<p>In order to compute the <code>RowSet</code> for a given set of variables, the function delegates to a function named <code>execute_query_with_variables</code>:</p>
<pre><code class="language-rust no_run noplayground">fn execute_query_with_variables(
    collection: &amp;models::CollectionName,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, models::Argument&gt;,
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    query: &amp;models::Query,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
) -&gt; Result&lt;models::RowSet&gt; {</code></pre>
<p>In the next section, we will break down the implementation of this function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evaluating-arguments"><a class="header" href="#evaluating-arguments">Evaluating Arguments</a></h1>
<p>Now that we have reduced the problem to a single set of query variables, we must evaluate any <a href="tutorial/queries/../../specification/queries/arguments.html">collection arguments</a>, and in turn, evaluate the <em>collection</em> of rows that we will be working with.</p>
<p>From there, we will be able to apply predicates, sort and paginate rows. But one step at a time!</p>
<p>The first step is to evaluate each argument, which the <code>execute_query_with_variables</code> function does by delegating to the <code>eval_argument</code> function:</p>
<pre><code class="language-rust no_run noplayground">fn execute_query_with_variables(
    collection: &amp;models::CollectionName,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, models::Argument&gt;,
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    query: &amp;models::Query,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
) -&gt; Result&lt;models::RowSet&gt; {
    let mut argument_values = BTreeMap::new();

    for (argument_name, argument_value) in arguments {
        if argument_values
            .insert(
                argument_name.clone(),
                eval_argument(variables, argument_value)?,
            )
            .is_some()
        {
            return Err((
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "duplicate argument names".into(),
                    details: serde_json::Value::Null,
                }),
            ));
        }
    }

    let collection = get_collection_by_name(collection, &amp;argument_values, state)?;

    execute_query(
        collection_relationships,
        variables,
        state,
        query,
        Root::Reset,
        collection,
    )
}</code></pre>
<p>Once this is complete, and we have a collection of evaluated <code>argument_values</code>, we can delegate to the <code>get_collection_by_name</code> function. This function peforms the work of computing the full collection, by pattern matching on the name of the collection:</p>
<pre><code class="language-rust no_run noplayground">fn get_collection_by_name(
    collection_name: &amp;models::CollectionName,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, serde_json::Value&gt;,
    state: &amp;AppState,
) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {
    match collection_name.as_str() {
        "articles" =&gt; Ok(state.articles.values().cloned().collect()),
        "authors" =&gt; Ok(state.authors.values().cloned().collect()),
        "institutions" =&gt; Ok(state.institutions.values().cloned().collect()),
        "countries" =&gt; Ok(state.countries.values().cloned().collect()),
        "articles_by_author" =&gt; {
            let author_id = arguments.get("author_id").ok_or((
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "missing argument author_id".into(),
                    details: serde_json::Value::Null,
                }),
            ))?;
            let author_id_int: i32 = author_id
                .as_i64()
                .ok_or((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "author_id must be an integer".into(),
                        details: serde_json::Value::Null,
                    }),
                ))?
                .try_into()
                .map_err(|_| {
                    (
                        StatusCode::BAD_REQUEST,
                        Json(models::ErrorResponse {
                            message: "author_id out of range".into(),
                            details: serde_json::Value::Null,
                        }),
                    )
                })?;

            let mut articles_by_author = vec![];

            for article in state.articles.values() {
                let article_author_id = article.get("author_id").ok_or((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(models::ErrorResponse {
                        message: "author_id not found".into(),
                        details: serde_json::Value::Null,
                    }),
                ))?;
                let article_author_id_int: i32 = article_author_id
                    .as_i64()
                    .ok_or((
                        StatusCode::INTERNAL_SERVER_ERROR,
                        Json(models::ErrorResponse {
                            message: "author_id must be an integer".into(),
                            details: serde_json::Value::Null,
                        }),
                    ))?
                    .try_into()
                    .map_err(|_| {
                        (
                            StatusCode::BAD_REQUEST,
                            Json(models::ErrorResponse {
                                message: "author_id out of range".into(),
                                details: serde_json::Value::Null,
                            }),
                        )
                    })?;
                if article_author_id_int == author_id_int {
                    articles_by_author.push(article.clone());
                }
            }

            Ok(articles_by_author)
        }
        "latest_article_id" =&gt; {
            let latest_id = state.articles.keys().max();
            let latest_id_value = serde_json::to_value(latest_id).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(models::ErrorResponse {
                        message: "unable to encode value".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })?;
            Ok(vec![BTreeMap::from_iter([(
                "__value".into(),
                latest_id_value,
            )])])
        }
        "latest_article" =&gt; {
            let latest = state
                .articles
                .iter()
                .max_by_key(|(&amp;id, _)| id)
                .map(|(_, article)| article);
            let latest_value = serde_json::to_value(latest).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(models::ErrorResponse {
                        message: "unable to encode value".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })?;
            Ok(vec![BTreeMap::from_iter([(
                "__value".into(),
                latest_value,
            )])])
        }
        _ =&gt; Err((
            StatusCode::BAD_REQUEST,
            Json(models::ErrorResponse {
                message: "invalid collection name".into(),
                details: serde_json::Value::Null,
            }),
        )),
    }
}</code></pre>
<p><em>Note 1</em>: the <code>articles_by_author</code> collection is the only example here which has to apply any arguments. It is provided as an example of a collection which accepts an <code>author_id</code> argument, and it must validate that the argument is present, and that it is an integer.</p>
<p><em>Note 2</em>: the <code>latest_article_id</code> collection is provided as an example of a <a href="tutorial/queries/../../specification/schema/functions.html">function</a>. It is a collection like all the others, but must follow the rules for functions: it must consist of a single row, with a single column named <code>__value</code>.</p>
<p>In the next section, we will break down the implementation of <code>execute_query</code>.
Once we have computed the full collection, we can move onto evaluating the query in the context of that collection, using the <code>execute_query</code> function:</p>
<pre><code class="language-rust no_run noplayground">fn execute_query(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    query: &amp;models::Query,
    root: Root,
    collection: Vec&lt;Row&gt;,
) -&gt; Result&lt;models::RowSet&gt; {</code></pre>
<p>In the next section, we will break down the implementation of <code>execute_query</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executing-queries"><a class="header" href="#executing-queries">Executing Queries</a></h1>
<p>In this section, we will break down the implementation of the <code>execute_query</code> function:</p>
<pre><code class="language-rust no_run noplayground">fn execute_query(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    query: &amp;models::Query,
    root: Root,
    collection: Vec&lt;Row&gt;,
) -&gt; Result&lt;models::RowSet&gt; {</code></pre>
<p>At this point, we have already computed the full collection, which is passed via the <code>collection</code> argument. Now, we need to evaluate the <a href="tutorial/queries/execute/../../../reference/types.html#query"><code>Query</code></a> in the context of this collection.</p>
<p>The <code>Query</code> describes the predicate which should be applied to all rows, the sort order, pagination options, along with any aggregates to compute and fields to return.</p>
<p>The first step is to sort the collection.</p>
<p><em>Note</em>: we could also start by filtering, and then sort the filtered rows. Which is more efficient depends on the data and the query, and choosing between these approaches would be the job of a <em>query planner</em> in a real database engine. However, this is out of scope here, so we make an arbitrary choice, and sort the data first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting-1"><a class="header" href="#sorting-1">Sorting</a></h1>
<p>The first step is to sort the rows in the full collection:</p>
<pre><code class="language-rust no_run noplayground">    let sorted = sort(
        collection_relationships,
        variables,
        state,
        collection,
        &amp;query.order_by,
    )?;</code></pre>
<p>The <a href="tutorial/queries/execute/../../../reference/types.html#query"><code>Query</code></a> object defines the sort order in terms of a list of <a href="tutorial/queries/execute/../../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>s. See the <a href="tutorial/queries/execute/../../../specification/queries/sorting.html">sorting specification</a> for details on how this ought to be interpreted.</p>
<h2 id="the-sort-function"><a class="header" href="#the-sort-function">The <code>sort</code> function</a></h2>
<p>The <code>sort</code> function implements a simple insertion sort, computing the ordering for each pair of rows, and inserting each row at the correct place:</p>
<pre><code class="language-rust no_run noplayground">fn sort(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    collection: Vec&lt;Row&gt;,
    order_by: &amp;Option&lt;models::OrderBy&gt;,
) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {
    match order_by {
        None =&gt; Ok(collection),
        Some(order_by) =&gt; {
            let mut copy = vec![];
            for item_to_insert in collection {
                let mut index = 0;
                for other in &amp;copy {
                    if let Ordering::Greater = eval_order_by(
                        collection_relationships,
                        variables,
                        state,
                        order_by,
                        other,
                        &amp;item_to_insert,
                    )? {
                        break;
                    }
                    index += 1;
                }
                copy.insert(index, item_to_insert);
            }
            Ok(copy)
        }
    }
}</code></pre>
<p><code>sort</code> delegates to the <code>eval_order_by</code> function to compute the ordering between two rows:</p>
<h2 id="evaluating-the-ordering"><a class="header" href="#evaluating-the-ordering">Evaluating the Ordering</a></h2>
<p>To compare two rows, the <code>eval_order_by</code> computes each <code>OrderByElement</code> in turn, and compares the rows in order, or in reverse order, depending on whether the ordering is <em>ascending</em> or <em>descending</em>.</p>
<p>The function returns the first <code>Ordering</code> which makes the two rows distinct (if any):</p>
<pre><code class="language-rust no_run noplayground">fn eval_order_by(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    order_by: &amp;models::OrderBy,
    t1: &amp;Row,
    t2: &amp;Row,
) -&gt; Result&lt;Ordering&gt; {
    let mut result = Ordering::Equal;

    for element in &amp;order_by.elements {
        let v1 = eval_order_by_element(collection_relationships, variables, state, element, t1)?;
        let v2 = eval_order_by_element(collection_relationships, variables, state, element, t2)?;
        let x = match element.order_direction {
            models::OrderDirection::Asc =&gt; compare(v1, v2)?,
            models::OrderDirection::Desc =&gt; compare(v2, v1)?,
        };
        result = result.then(x);
    }

    Ok(result)
}</code></pre>
<p>The ordering for a single <code>OrderByElement</code> is computed by the <code>eval_order_by_element</code> function.</p>
<p>We won't cover every branch of this function in detail here, but it works by pattern matching on the type of ordering being used.</p>
<h3 id="ordering-by-a-column"><a class="header" href="#ordering-by-a-column">Ordering by a column</a></h3>
<p>As an example, here is the function <code>eval_order_by_column</code> which evaluates <em>ordering by a column</em>:</p>
<pre><code class="language-rust no_run noplayground"></code></pre>
<p>This code computes the target table, possibly by traversing relationships using <code>eval_path</code> (we will cover this function later when we cover relationships), and validates that we computed a single row before selecting the value of the chosen column.</p>
<p>Now that we have sorted the full collection, we can apply the predicate to filter down the collection of rows. We will cover this in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filtering-2"><a class="header" href="#filtering-2">Filtering</a></h1>
<p>The next step is to filter the rows based on the provided predicate expression:</p>
<pre><code class="language-rust no_run noplayground">    let filtered: Vec&lt;Row&gt; = (match &amp;query.predicate {
        None =&gt; Ok(sorted),
        Some(expr) =&gt; {
            let mut filtered: Vec&lt;Row&gt; = vec![];
            for item in sorted {
                let scopes: Vec&lt;&amp;Row&gt; = match root {
                    Root::PushCurrentRow(scopes) =&gt; {
                        let mut scopes = scopes.to_vec();
                        scopes.push(&amp;item);
                        scopes
                    }
                    Root::Reset =&gt; vec![&amp;item],
                };
                if eval_expression(
                    collection_relationships,
                    variables,
                    state,
                    expr,
                    &amp;scopes,
                    &amp;item,
                )? {
                    filtered.push(item);
                }
            }
            Ok(filtered)
        }
    })?;</code></pre>
<p>As we can see, the function delegates to the <code>eval_expression</code> function in order to evaluate the predicate on each row.</p>
<h2 id="evaluating-expressions"><a class="header" href="#evaluating-expressions">Evaluating expressions</a></h2>
<p>The <code>eval_expression</code> function evaluates a predicate by pattern matching on the type of the expression <code>expr</code>, and returns a boolean value indicating whether the current row matches the predicate:</p>
<pre><code class="language-rust no_run noplayground">fn eval_expression(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    expr: &amp;models::Expression,
    scopes: &amp;[&amp;Row],
    item: &amp;Row,
) -&gt; Result&lt;bool&gt; {</code></pre>
<h3 id="logical-expressions"><a class="header" href="#logical-expressions">Logical expressions</a></h3>
<p>The first category of expression types are the <em>logical expressions</em> - <em>and</em> (conjunction), <em>or</em> (disjunction) and <em>not</em> (negation) - whose evaluators are straightforward:</p>
<ul>
<li>To evaluate a conjunction/disjunction of subexpressions, we evaluate all of the subexpressions to booleans, and find the conjunction/disjunction of those boolean values respectively.</li>
<li>To evaluate the negation of a subexpression, we evaluate the subexpression to a boolean value, and negate the boolean.</li>
</ul>
<pre><code class="language-rust no_run noplayground">    match expr {
        models::Expression::And { expressions } =&gt; {
            for expr in expressions {
                if !eval_expression(
                    collection_relationships,
                    variables,
                    state,
                    expr,
                    scopes,
                    item,
                )? {
                    return Ok(false);
                }
            }
            Ok(true)
        }
        models::Expression::Or { expressions } =&gt; {
            for expr in expressions {
                if eval_expression(
                    collection_relationships,
                    variables,
                    state,
                    expr,
                    scopes,
                    item,
                )? {
                    return Ok(true);
                }
            }
            Ok(false)
        }
        models::Expression::Not { expression } =&gt; {
            let b = eval_expression(
                collection_relationships,
                variables,
                state,
                expression,
                scopes,
                item,
            )?;
            Ok(!b)
        }</code></pre>
<h3 id="unary-operators-1"><a class="header" href="#unary-operators-1">Unary Operators</a></h3>
<p>The next category of expressions are the <em>unary operators</em>. The only unary operator is the <code>IsNull</code> operator, which is evaluated by evaluating the operator's <em>comparison target</em>, and then comparing the result to <code>null</code>:</p>
<pre><code class="language-rust no_run noplayground">        models::Expression::UnaryComparisonOperator { column, operator } =&gt; match operator {
            models::UnaryComparisonOperator::IsNull =&gt; {
                let vals = eval_comparison_target(
                    collection_relationships,
                    variables,
                    state,
                    column,
                    item,
                )?;
                Ok(vals.is_null())
            }
        },</code></pre>
<p>To evaluate the comparison target, we delegate to the <code>eval_comparison_target</code> function, which pattern matches:</p>
<ul>
<li>A column is evaluated using the <code>eval_column_field_path</code> function.</li>
<li>An aggregate is evaluated using <code>eval_path</code> (which we will talk more about when we get to <a href="tutorial/queries/execute/./relationships.html">relationships</a>) and <code>eval_aggregate</code> (which we will talk about when we get to <a href="tutorial/queries/execute/./aggregates.html">aggregates</a>).</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn eval_comparison_target(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    target: &amp;models::ComparisonTarget,
    item: &amp;Row,
) -&gt; Result&lt;serde_json::Value&gt; {
    match target {
        models::ComparisonTarget::Column {
            name,
            arguments,
            field_path,
        } =&gt; eval_column_field_path(variables, item, name, field_path.as_deref(), arguments),
        models::ComparisonTarget::Aggregate { aggregate, path } =&gt; {
            let rows: Vec&lt;Row&gt; = eval_path(
                collection_relationships,
                variables,
                state,
                path,
                &amp;[item.clone()],
            )?;
            eval_aggregate(variables, aggregate, &amp;rows)
        }
    }
}</code></pre>
<h3 id="binary-operators-1"><a class="header" href="#binary-operators-1">Binary Operators</a></h3>
<p>The next category of expressions are the <em>binary operators</em>. Binary operators can be <em>standard</em> or <em>custom</em>.</p>
<p>Binary operators are evaluated by evaluating their <em>comparison target</em> and <em>comparison value</em>, and comparing them using a specific <em>comparison operator</em>:</p>
<pre><code class="language-rust no_run noplayground">        models::Expression::BinaryComparisonOperator {
            column,
            operator,
            value,
        } =&gt; {
            let left_val =
                eval_comparison_target(collection_relationships, variables, state, column, item)?;
            let right_vals = eval_comparison_value(
                collection_relationships,
                variables,
                value,
                state,
                scopes,
                item,
            )?;
            eval_comparison_operator(operator, &amp;left_val, &amp;right_vals)
        }</code></pre>
<p>The standard binary comparison operators are:</p>
<ul>
<li>The equality operator, <code>equal</code>,</li>
<li>The set membership operator, <code>in</code>,</li>
<li>Comparison operators <code>less_than</code>, <code>less_than_or_equal</code>, <code>greater_than</code>, and <code>greater_than_or_equal</code>,</li>
<li>String comparisons <code>contains</code>, <code>icontains</code>, <code>starts_with</code>, <code>istarts_with</code>, <code>ends_with</code>, <code>iends_with</code> and <code>like</code>.</li>
</ul>
<p><code>equal</code> is evaluated by evaluating its <em>comparison target</em> and <em>comparison value</em>, and comparing them for equality:</p>
<pre><code class="language-rust no_run noplayground">        "eq" =&gt; {
            for right_val in right_vals {
                if left_val == right_val {
                    return Ok(true);
                }
            }

            Ok(false)
        }</code></pre>
<p>The ordering comparisons (<code>less_than</code>, <code>less_than_or_equal</code>, <code>greater_than</code>, and <code>greater_than_or_equal</code>) depend on their type, so first we need to determine the type of the comparison target and dispatch on it to <code>eval_partial_ord_comparison</code> to perform the actual comparisons:</p>
<pre><code class="language-rust no_run noplayground">        "gt" | "lt" | "gte" | "lte" =&gt; {
            if let Some(column_int) = left_val.as_i64() {
                eval_partial_ord_comparison(operator, &amp;column_int, right_vals, |right_val| {
                    right_val.as_i64().ok_or_else(|| {
                        (
                            StatusCode::BAD_REQUEST,
                            Json(models::ErrorResponse {
                                message: "value is not an integer".into(),
                                details: serde_json::Value::Null,
                            }),
                        )
                    })
                })
            } else if let Some(column_float) = left_val.as_f64() {
                eval_partial_ord_comparison(operator, &amp;column_float, right_vals, |right_val| {
                    right_val.as_f64().ok_or_else(|| {
                        (
                            StatusCode::BAD_REQUEST,
                            Json(models::ErrorResponse {
                                message: "value is not a float".into(),
                                details: serde_json::Value::Null,
                            }),
                        )
                    })
                })
            } else if let Some(column_string) = left_val.as_str() {
                eval_partial_ord_comparison(operator, &amp;column_string, right_vals, |right_val| {
                    right_val.as_str().ok_or_else(|| {
                        (
                            StatusCode::BAD_REQUEST,
                            Json(models::ErrorResponse {
                                message: "value is not a string".into(),
                                details: serde_json::Value::Null,
                            }),
                        )
                    })
                })
            } else {
                Err((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: format!(
                            "column is does not support comparison operator {operator}"
                        ),
                        details: serde_json::Value::Null,
                    }),
                ))
            }
        }</code></pre>
<pre><code class="language-rust no_run noplayground">fn eval_partial_ord_comparison&lt;'a, T, FConvert&gt;(
    operator: &amp;ndc_models::ComparisonOperatorName,
    left_value: &amp;T,
    right_values: &amp;'a [serde_json::Value],
    convert: FConvert,
) -&gt; Result&lt;bool&gt;
where
    T: PartialOrd,
    FConvert: Fn(&amp;'a serde_json::Value) -&gt; Result&lt;T&gt;,
{
    for right_val in right_values {
        let right_val = convert(right_val)?;

        let op = operator.as_str();
        if op == "gt" &amp;&amp; *left_value &gt; right_val
            || op == "lt" &amp;&amp; *left_value &lt; right_val
            || op == "gte" &amp;&amp; *left_value &gt;= right_val
            || op == "lte" &amp;&amp; *left_value &lt;= right_val
        {
            return Ok(true);
        }
    }

    Ok(false)
}</code></pre>
<p>The <code>in</code> operator is evaluated by evaluating its comparison target, and all of its comparison values, and testing whether the evaluated target appears in the list of evaluated values:</p>
<pre><code class="language-rust no_run noplayground">        "in" =&gt; {
            for comparison_value in right_vals {
                let right_vals = comparison_value.as_array().ok_or((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "expected array".into(),
                        details: serde_json::Value::Null,
                    }),
                ))?;

                for right_val in right_vals {
                    if left_val == right_val {
                        return Ok(true);
                    }
                }
            }
            Ok(false)
        }</code></pre>
<p>String comparison operators are evaluated similarly:</p>
<pre><code class="language-rust no_run noplayground">        "contains" | "icontains" | "starts_with" | "istarts_with" | "ends_with" | "iends_with" =&gt; {
            if let Some(left_str) = left_val.as_str() {
                for right_val in right_vals {
                    let right_str = right_val.as_str().ok_or_else(|| {
                        (
                            StatusCode::BAD_REQUEST,
                            Json(models::ErrorResponse {
                                message: "value is not a string".into(),
                                details: serde_json::Value::Null,
                            }),
                        )
                    })?;

                    let op = operator.as_str();
                    let left_str_lower = left_str.to_lowercase();
                    let right_str_lower = right_str.to_lowercase();

                    if op == "contains" &amp;&amp; left_str.contains(right_str)
                        || op == "icontains" &amp;&amp; left_str_lower.contains(&amp;right_str_lower)
                        || op == "starts_with" &amp;&amp; left_str.starts_with(right_str)
                        || op == "istarts_with" &amp;&amp; left_str_lower.starts_with(&amp;right_str_lower)
                        || op == "ends_with" &amp;&amp; left_str.ends_with(right_str)
                        || op == "iends_with" &amp;&amp; left_str_lower.ends_with(&amp;right_str_lower)
                    {
                        return Ok(true);
                    }
                }

                Ok(false)
            } else {
                Err((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: format!(
                            "comparison operator {operator} is only supported on strings"
                        ),
                        details: serde_json::Value::Null,
                    }),
                ))
            }
        }</code></pre>
<p>The reference implementation provides a single custom binary operator as an example, which is the <code>like</code> operator on strings:</p>
<pre><code class="language-rust no_run noplayground">        "like" =&gt; {
            for regex_val in right_vals {
                let column_str = left_val.as_str().ok_or((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "regex is not a string".into(),
                        details: serde_json::Value::Null,
                    }),
                ))?;
                let regex_str = regex_val.as_str().ok_or((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "regex is invalid".into(),
                        details: serde_json::Value::Null,
                    }),
                ))?;
                let regex = Regex::new(regex_str).map_err(|_| {
                    (
                        StatusCode::BAD_REQUEST,
                        Json(models::ErrorResponse {
                            message: "invalid regular expression".into(),
                            details: serde_json::Value::Null,
                        }),
                    )
                })?;
                if regex.is_match(column_str) {
                    return Ok(true);
                }
            }

            Ok(false)
        }</code></pre>
<h3 id="scalar-array-comparison-operators"><a class="header" href="#scalar-array-comparison-operators">Scalar Array Comparison Operators</a></h3>
<p>The next category of expressions are the <em>scalar array comparison operators</em>. First we must evaluate the <em>comparison target</em> and then we can evaluate the array comparison itself.</p>
<pre><code class="language-rust no_run noplayground">        models::Expression::ArrayComparison { column, comparison } =&gt; {
            let left_val =
                eval_comparison_target(collection_relationships, variables, state, column, item)?;
            eval_array_comparison(
                collection_relationships,
                variables,
                &amp;left_val,
                comparison,
                state,
                scopes,
                item,
            )
        }</code></pre>
<p>Evaluating the array comparison is done using <code>eval_array_comparison</code>. In it, we can evaluate the two standard operators we have: <code>contains</code> and <code>is_empty</code>.</p>
<p><code>contains</code> simply evaluates the comparison value and then tests whether the array from the comparison target contains any of the comparison values.</p>
<pre><code class="language-rust no_run noplayground">        models::ArrayComparison::Contains { value } =&gt; {
            let right_vals = eval_comparison_value(
                collection_relationships,
                variables,
                value,
                state,
                scopes,
                item,
            )?;

            for right_val in right_vals {
                if left_val_array.contains(&amp;right_val) {
                    return Ok(true);
                }
            }

            Ok(false)
        }</code></pre>
<p><code>is_empty</code> simply checks is the comparison target array is empty:</p>
<pre><code class="language-rust no_run noplayground">        models::ArrayComparison::IsEmpty =&gt; Ok(left_val_array.is_empty()),</code></pre>
<h3 id="exists-expressions-1"><a class="header" href="#exists-expressions-1"><code>EXISTS</code> expressions</a></h3>
<p>An <code>EXISTS</code> expression is evaluated by recursively evaluating a <code>Query</code> on another source of rows, and testing to see whether the resulting <code>RowSet</code> contains any rows.</p>
<pre><code class="language-rust no_run noplayground">        models::Expression::Exists {
            in_collection,
            predicate,
        } =&gt; {
            let query = models::Query {
                aggregates: None,
                fields: Some(IndexMap::new()),
                limit: None,
                offset: None,
                order_by: None,
                predicate: predicate.clone().map(|e| *e),
                groups: None,
            };
            let collection = eval_in_collection(
                collection_relationships,
                item,
                variables,
                state,
                in_collection,
            )?;
            let row_set = execute_query(
                collection_relationships,
                variables,
                state,
                &amp;query,
                Root::PushCurrentRow(scopes),
                collection,
            )?;
            let rows: Vec&lt;IndexMap&lt;_, _&gt;&gt; = row_set.rows.ok_or((
                StatusCode::INTERNAL_SERVER_ERROR,
                Json(models::ErrorResponse {
                    message: "expected 'rows'".into(),
                    details: serde_json::Value::Null,
                }),
            ))?;
            Ok(!rows.is_empty())</code></pre>
<p>Note in particular, we push the current row onto the stack of <code>scopes</code> before executing the inner query, so that <a href="tutorial/queries/execute/../../../specification/queries/filtering.html#referencing-a-column-from-a-collection-in-scope">references to columns in those scopes</a> can be resolved correctly.</p>
<p>The source of the rows is defined by <code>in_collection</code>, which we evaluate with <code>eval_in_collection</code> in order to get the rows to evaluate the inner query against. There are four different sources of rows.</p>
<h4 id="existsincollectionrelated"><a class="header" href="#existsincollectionrelated"><code>ExistsInCollection::Related</code></a></h4>
<p>The first source of rows is a related collection. We first find the specified relationship, and then use <code>eval_path_element</code> to get the rows across that relationship from the current row:</p>
<pre><code class="language-rust no_run noplayground">        models::ExistsInCollection::Related {
            field_path,
            relationship,
            arguments,
        } =&gt; {
            let relationship = collection_relationships.get(relationship).ok_or((
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "relationship is undefined".into(),
                    details: serde_json::Value::Null,
                }),
            ))?;
            let source = vec![item.clone()];
            eval_path_element(
                collection_relationships,
                variables,
                state,
                relationship,
                arguments,
                &amp;source,
                field_path.as_deref(),
                &amp;None,
            )
        }</code></pre>
<h4 id="existsincollectionunrelated"><a class="header" href="#existsincollectionunrelated"><code>ExistsInCollection::Unrelated</code></a></h4>
<p>The second source of rows is an unrelated collection. This simply returns all rows in that collection by using <code>get_collection_by_name</code>:</p>
<pre><code class="language-rust no_run noplayground">        models::ExistsInCollection::Unrelated {
            collection,
            arguments,
        } =&gt; {
            let arguments = arguments
                .iter()
                .map(|(k, v)| Ok((k.clone(), eval_relationship_argument(variables, item, v)?)))
                .collect::&lt;Result&lt;BTreeMap&lt;_, _&gt;&gt;&gt;()?;

            get_collection_by_name(collection, &amp;arguments, state)
        }</code></pre>
<h4 id="existsincollectionnestedcollection"><a class="header" href="#existsincollectionnestedcollection"><code>ExistsInCollection::NestedCollection</code></a></h4>
<p>The third source of rows is a nested collection. This allows us to source our rows from a nested array of objects in a column on the current row. We do this using <code>eval_column_field_path</code>.</p>
<pre><code class="language-rust no_run noplayground">        ndc_models::ExistsInCollection::NestedCollection {
            column_name,
            field_path,
            arguments,
        } =&gt; {
            let value =
                eval_column_field_path(variables, item, column_name, Some(field_path), arguments)?;
            serde_json::from_value(value).map_err(|_| {
                (
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "nested collection must be an array of objects".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })
        }</code></pre>
<h4 id="existsincollectionnestedscalarcollection"><a class="header" href="#existsincollectionnestedscalarcollection"><code>ExistsInCollection::NestedScalarCollection</code></a></h4>
<p>The fourth source of rows is a nested scalar collection. This allows us to read a nested array of scalars from a column on the current row (using <code>eval_column_field_path</code>) and create a virtual row for each element in the array, placing the array element into a <code>__value</code> field on the row:</p>
<pre><code class="language-rust no_run noplayground">        models::ExistsInCollection::NestedScalarCollection {
            field_path,
            column_name,
            arguments,
        } =&gt; {
            let value =
                eval_column_field_path(variables, item, column_name, Some(field_path), arguments)?;
            let value_array = value.as_array().ok_or_else(|| {
                (
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "nested scalar collection column value must be an array".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })?;
            let wrapped_array_values = value_array
                .iter()
                .map(|v| BTreeMap::from([(models::FieldName::from("__value"), v.clone())]))
                .collect();
            Ok(wrapped_array_values)</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagination-2"><a class="header" href="#pagination-2">Pagination</a></h1>
<p>Once the irrelevant rows have been filtered out, the <code>execute_query</code> function applies the <code>limit</code> and <code>offset</code> arguments by calling the `paginate function:</p>
<pre><code class="language-rust no_run noplayground">    let paginated: Vec&lt;Row&gt; = paginate(filtered.into_iter(), query.limit, query.offset);</code></pre>
<p>The <code>paginate</code> function is implemented using the <code>skip</code> and <code>take</code> functions on iterators:</p>
<pre><code class="language-rust no_run noplayground">fn paginate&lt;I: Iterator&gt;(collection: I, limit: Option&lt;u32&gt;, offset: Option&lt;u32&gt;) -&gt; Vec&lt;I::Item&gt; {
    let start = offset.unwrap_or(0).try_into().unwrap();
    match limit {
        Some(n) =&gt; collection.skip(start).take(n.try_into().unwrap()).collect(),
        None =&gt; collection.skip(start).collect(),
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates-1"><a class="header" href="#aggregates-1">Aggregates</a></h1>
<p>Now that we have computed the sorted, filtered, and paginated rows of the original collection, we can compute any aggregates over those rows.</p>
<p>Each aggregate is computed in turn by the <code>eval_aggregate</code> function, and added to the list of all aggregates to return:</p>
<pre><code class="language-rust no_run noplayground">    let aggregates = query
        .aggregates
        .as_ref()
        .map(|aggregates| eval_aggregates(variables, aggregates, &amp;paginated))
        .transpose()?;</code></pre>
<p>The <code>eval_aggregate</code> function works by pattern matching on the type of the aggregate being computed:</p>
<ul>
<li>A <code>star_count</code> aggregate simply counts all rows,</li>
<li>A <code>column_count</code> aggregate computes the subset of rows where the named column is non-null, and returns the count of only those rows,</li>
<li>A <code>single_column</code> aggregate is computed by delegating to the <code>eval_aggregate_function</code> function, which computes a custom aggregate operator over the values of the selected column taken from all rows.</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn eval_aggregate(
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    aggregate: &amp;models::Aggregate,
    rows: &amp;[Row],
) -&gt; Result&lt;serde_json::Value&gt; {
    match aggregate {
        models::Aggregate::StarCount {} =&gt; Ok(serde_json::Value::from(rows.len())),
        models::Aggregate::ColumnCount {
            column,
            arguments,
            field_path,
            distinct,
        } =&gt; {
            let values = rows
                .iter()
                .map(|row| {
                    eval_column_field_path(variables, row, column, field_path.as_deref(), arguments)
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;

            let non_null_values = values.iter().filter(|value| !value.is_null());

            let agg_value = if *distinct {
                non_null_values
                    .map(|value| {
                        serde_json::to_string(value).map_err(|_| {
                            (
                                StatusCode::INTERNAL_SERVER_ERROR,
                                Json(models::ErrorResponse {
                                    message: "unable to encode value".into(),
                                    details: serde_json::Value::Null,
                                }),
                            )
                        })
                    })
                    .collect::&lt;Result&lt;HashSet&lt;_&gt;&gt;&gt;()?
                    .len()
            } else {
                non_null_values.count()
            };
            serde_json::to_value(agg_value).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(models::ErrorResponse {
                        message: "unable to encode value".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })
        }
        models::Aggregate::SingleColumn {
            column,
            arguments,
            field_path,
            function,
        } =&gt; {
            let values = rows
                .iter()
                .map(|row| {
                    eval_column_field_path(variables, row, column, field_path.as_deref(), arguments)
                })
                .collect::&lt;Result&lt;Vec&lt;_&gt;&gt;&gt;()?;
            eval_aggregate_function(function, &amp;values)
        }
    }
}</code></pre>
<p>The <code>eval_aggregate_function</code> function discovers the type of data being aggregated and then dispatches to a specific function that implements aggregation for that type.</p>
<pre><code class="language-rust no_run noplayground">fn eval_aggregate_function(
    function: &amp;models::AggregateFunctionName,
    values: &amp;[serde_json::Value],
) -&gt; Result&lt;serde_json::Value&gt; {
    if let Some(first_value) = values.iter().next() {
        if first_value.is_i64() {
            let int_values = values
                .iter()
                .map(|value| {
                    value.as_i64().ok_or_else(|| {
                        (
                            StatusCode::BAD_REQUEST,
                            Json(models::ErrorResponse {
                                message: "column is not an integer".into(),
                                details: serde_json::Value::Null,
                            }),
                        )
                    })
                })
                .collect::&lt;Result&lt;Vec&lt;i64&gt;&gt;&gt;()?;

            eval_integer_aggregate_function(function, int_values)
        }
...</code></pre>
<p>For example, integer aggregation is implemented by <code>eval_integer_aggregate_function</code>. In it, the <code>min</code>, <code>max</code>, <code>sum</code>, and <code>avg</code> functions are implemented.</p>
<pre><code class="language-rust no_run noplayground">#[allow(clippy::cast_precision_loss)]
fn eval_integer_aggregate_function(
    function: &amp;models::AggregateFunctionName,
    int_values: Vec&lt;i64&gt;,
) -&gt; Result&lt;serde_json::Value&gt; {
    match function.as_str() {
        "min" =&gt; Ok(serde_json::Value::from(int_values.into_iter().min())),
        "max" =&gt; Ok(serde_json::Value::from(int_values.into_iter().max())),
        "sum" =&gt; Ok(serde_json::Value::from(int_values.into_iter().sum::&lt;i64&gt;())),
        "avg" =&gt; {
            let count: f64 = int_values.len() as f64; // Potential precision loss (u64 -&gt; f64)
            let sum: f64 = int_values.into_iter().sum::&lt;i64&gt;() as f64; // Potential precision loss (i64 -&gt; f64)
            let avg = sum / count;
            Ok(serde_json::Value::from(avg))
        }
        _ =&gt; Err((
            StatusCode::BAD_REQUEST,
            Json(models::ErrorResponse {
                message: "invalid integer aggregation function".into(),
                details: serde_json::Value::Null,
            }),
        )),
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-selection-1"><a class="header" href="#field-selection-1">Field Selection</a></h1>
<p>In addition to computing aggregates, we can also return fields selected directly from the rows themselves.</p>
<p>This is done by mapping over the computed rows, and using the <code>eval_field</code> function to evaluate each selected field in turn:</p>
<pre><code class="language-rust no_run noplayground">    let rows = query
        .fields
        .as_ref()
        .map(|fields| {
            let mut rows: Vec&lt;IndexMap&lt;models::FieldName, models::RowFieldValue&gt;&gt; = vec![];
            for item in &amp;paginated {
                let row = eval_row(fields, collection_relationships, variables, state, item)?;
                rows.push(row);
            }
            Ok(rows)
        })
        .transpose()?;</code></pre>
<p>The <code>eval_field</code> function works by pattern matching on the field type:</p>
<ul>
<li>A <code>column</code> is selected using the <code>eval_column</code> function (or <code>eval_nested_field</code> if there are nested fields to fetch)</li>
<li>A <code>relationship</code> field is selected by evaluating the related collection using <code>eval_path_element</code> (we will cover this in the next section), and then recursively executing a query using <code>execute_query</code>:</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn eval_field(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    field: &amp;models::Field,
    item: &amp;Row,
) -&gt; Result&lt;models::RowFieldValue&gt; {
    match field {
        models::Field::Column {
            column,
            fields,
            arguments,
        } =&gt; {
            let col_val = eval_column(variables, item, column, arguments)?;
            match fields {
                None =&gt; Ok(models::RowFieldValue(col_val)),
                Some(nested_field) =&gt; eval_nested_field(
                    collection_relationships,
                    variables,
                    state,
                    col_val,
                    nested_field,
                ),
            }
        }
        models::Field::Relationship {
            relationship,
            arguments,
            query,
        } =&gt; {
            let relationship = collection_relationships.get(relationship).ok_or((
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "relationship is undefined".into(),
                    details: serde_json::Value::Null,
                }),
            ))?;
            let source = vec![item.clone()];
            let collection = eval_path_element(
                collection_relationships,
                variables,
                state,
                relationship,
                arguments,
                &amp;source,
                None,
                &amp;None,
            )?;
            let row_set = execute_query(
                collection_relationships,
                variables,
                state,
                query,
                Root::Reset,
                collection,
            )?;
            let row_set_json = serde_json::to_value(row_set).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(models::ErrorResponse {
                        message: "cannot encode rowset".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })?;
            Ok(models::RowFieldValue(row_set_json))
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grouping-2"><a class="header" href="#grouping-2">Grouping</a></h1>
<p>In addition to <a href="tutorial/queries/execute/./field-selection.html">field selection</a> and <a href="tutorial/queries/execute/./aggregates.html">computing aggregates</a>, we also need to return the results of any requested <a href="tutorial/queries/execute/../../../specification/queries/grouping.html">grouping operations</a>.</p>
<p>This is done by delegating to the <code>eval_groups</code> function:</p>
<pre><code class="language-rust no_run noplayground">    let groups = query
        .groups
        .as_ref()
        .map(|grouping| {
            eval_groups(
                collection_relationships,
                variables,
                state,
                grouping,
                &amp;paginated,
            )
        })
        .transpose()?;</code></pre>
<p><code>eval_groups</code> takes a set of rows, and proceeds largely like <code>execute_query</code> itself.</p>
<p>First, rows are partitioned into groups:</p>
<pre><code class="language-rust no_run noplayground">fn eval_groups(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, ndc_models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    grouping: &amp;ndc_models::Grouping,
    paginated: &amp;[Row],
) -&gt; Result&lt;Vec&lt;ndc_models::Group&gt;&gt; {
    let chunks: Vec&lt;Chunk&gt; = paginated
        .iter()
        .chunk_by(|row| {
            eval_dimensions(
                collection_relationships,
                variables,
                state,
                row,
                &amp;grouping.dimensions,
            )
            .expect("cannot eval dimensions")
        })
        .into_iter()
        .map(|(dimensions, rows)| Chunk {
            dimensions,
            rows: rows.cloned().collect(),
        })
        .collect();</code></pre>
<p>The <code>eval_dimensions</code> function computes a vector of dimensions for each row:</p>
<pre><code class="language-rust no_run noplayground">fn eval_dimensions(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    row: &amp;Row,
    dimensions: &amp;[ndc_models::Dimension],
) -&gt; Result&lt;Vec&lt;serde_json::Value&gt;&gt; {
    let mut values = vec![];
    for dimension in dimensions {
        let value = eval_dimension(collection_relationships, variables, state, row, dimension)?;
        values.push(value);
    }
    Ok(values)
}</code></pre>
<p>The only type of dimension we need to handle is a column. First the value of the column is computed by delegating to <code>eval_column_field_path</code>, and then any <a href="tutorial/queries/execute/../../../specification/schema/scalar-types.html#extraction-functions">extraction function</a> is evaluated using the <code>eval_extraction</code> function:</p>
<pre><code class="language-rust no_run noplayground">fn eval_dimension(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    row: &amp;Row,
    dimension: &amp;models::Dimension,
) -&gt; Result&lt;serde_json::Value&gt; {
    match dimension {
        models::Dimension::Column {
            column_name,
            arguments,
            field_path,
            path,
            extraction,
        } =&gt; {
            let value = eval_column_at_path(
                collection_relationships,
                variables,
                state,
                row,
                path,
                column_name,
                arguments,
                field_path.as_deref(),
            )?;

            eval_extraction(extraction, value)
        }
    }
}</code></pre>
<p>Next, the partitions are sorted, using the <code>group_sort</code> function which is very similar to its row-based counterpart <code>sort</code>:</p>
<pre><code class="language-rust no_run noplayground">    let sorted = group_sort(variables, chunks, &amp;grouping.order_by)?;</code></pre>
<p>Next, groups are aggregated and filtered:</p>
<pre><code class="language-rust no_run noplayground">    let mut groups: Vec&lt;models::Group&gt; = vec![];

    for chunk in &amp;sorted {
        let dimensions = chunk.dimensions.clone();

        let mut aggregates: IndexMap&lt;models::FieldName, serde_json::Value&gt; = IndexMap::new();
        for (aggregate_name, aggregate) in &amp;grouping.aggregates {
            aggregates.insert(
                aggregate_name.clone(),
                eval_aggregate(variables, aggregate, &amp;chunk.rows)?,
            );
        }
        if let Some(predicate) = &amp;grouping.predicate {
            if eval_group_expression(variables, predicate, &amp;chunk.rows)? {
                groups.push(models::Group {
                    dimensions: dimensions.clone(),
                    aggregates,
                });
            }
        } else {
            groups.push(models::Group {
                dimensions: dimensions.clone(),
                aggregates,
            });
        }
    }</code></pre>
<p>The <code>eval_group_expression</code> function is also very similar to the <code>eval_expression</code> function which performs a similar operation on rows.</p>
<p>Finally, the groups are paginated and returned:</p>
<pre><code class="language-rust no_run noplayground">    let paginated: Vec&lt;models::Group&gt; =
        paginate(groups.into_iter(), grouping.limit, grouping.offset);

    Ok(paginated)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationships-2"><a class="header" href="#relationships-2">Relationships</a></h1>
<p>Relationships appear in many places in the <a href="tutorial/queries/execute/../../../reference/types.html#queryrequest"><code>QueryRequest</code></a>, but are always computed using the <code>eval_path</code> function.</p>
<p><code>eval_path</code> accepts a list of <a href="tutorial/queries/execute/../../../reference/types.html#pathelement"><code>PathElement</code></a>s, each of which describes the traversal of a single edge of the collection-relationship graph. <code>eval_path</code> computes the collection at the final node of this path through the graph.</p>
<p>It does this by successively evaluating each edge in turn using the <code>eval_path_element</code> function:</p>
<pre><code class="language-rust no_run noplayground">fn eval_path(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    path: &amp;[models::PathElement],
    items: &amp;[Row],
) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {
    let mut result: Vec&lt;Row&gt; = items.to_vec();

    for path_element in path {
        let relationship = collection_relationships
            .get(&amp;path_element.relationship)
            .ok_or((
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "invalid relationship name in path".into(),
                    details: serde_json::Value::Null,
                }),
            ))?;
        result = eval_path_element(
            collection_relationships,
            variables,
            state,
            relationship,
            &amp;path_element.arguments,
            &amp;result,
            path_element.field_path.as_deref(),
            &amp;path_element.predicate,
        )?;
    }

    Ok(result)
}</code></pre>
<p>The <code>eval_path_element</code> function computes a collection from a single relationship, one source row at a time. If a <code>field_path</code> exists, the source row is replaced by descending through the nested objects as specified by the field path (using <code>eval_row_field_path</code>). Once this is done, all relationship arguments are evaluated, and the target collection is computed by using <code>get_collection_by_name</code>. Finally the column mapping is evaluated on any resulting rows.</p>
<pre><code class="language-rust no_run noplayground">fn eval_path_element(
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    variables: &amp;BTreeMap&lt;models::VariableName, serde_json::Value&gt;,
    state: &amp;AppState,
    relationship: &amp;models::Relationship,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, models::RelationshipArgument&gt;,
    source: &amp;[Row],
    field_path: Option&lt;&amp;[models::FieldName]&gt;,
    predicate: &amp;Option&lt;Box&lt;models::Expression&gt;&gt;,
) -&gt; Result&lt;Vec&lt;Row&gt;&gt; {
    let mut matching_rows: Vec&lt;Row&gt; = vec![];

    // Note: Join strategy
    //
    // Rows can be related in two ways: 1) via a column mapping, and
    // 2) via collection arguments. Because collection arguments can be computed
    // using the columns on the source side of a relationship, in general
    // we need to compute the target collection once for each source row.
    // This join strategy can result in some target rows appearing in the
    // resulting row set more than once, if two source rows are both related
    // to the same target row.
    //
    // In practice, this is not an issue, either because a) the relationship
    // is computed in the course of evaluating a predicate, and all predicates are
    // implicitly or explicitly existentially quantified, or b) if the
    // relationship is computed in the course of evaluating an ordering, the path
    // should consist of all object relationships, and possibly terminated by a
    // single array relationship, so there should be no double counting.

    for src_row in source {
        let src_row = eval_row_field_path(field_path, src_row)?;

        let mut all_arguments = BTreeMap::new();

        for (argument_name, argument_value) in &amp;relationship.arguments {
            if all_arguments
                .insert(
                    argument_name.clone(),
                    eval_relationship_argument(variables, &amp;src_row, argument_value)?,
                )
                .is_some()
            {
                return Err((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "duplicate argument names".into(),
                        details: serde_json::Value::Null,
                    }),
                ));
            }
        }

        for (argument_name, argument_value) in arguments {
            if all_arguments
                .insert(
                    argument_name.clone(),
                    eval_relationship_argument(variables, &amp;src_row, argument_value)?,
                )
                .is_some()
            {
                return Err((
                    StatusCode::BAD_REQUEST,
                    Json(models::ErrorResponse {
                        message: "duplicate argument names".into(),
                        details: serde_json::Value::Null,
                    }),
                ));
            }
        }

        let target =
            get_collection_by_name(&amp;relationship.target_collection, &amp;all_arguments, state)?;

        for tgt_row in &amp;target {
            if eval_column_mapping(relationship, &amp;src_row, tgt_row)?
                &amp;&amp; if let Some(expression) = predicate {
                    eval_expression(
                        collection_relationships,
                        variables,
                        state,
                        expression,
                        &amp;[],
                        tgt_row,
                    )?
                } else {
                    true
                }
            {
                matching_rows.push(tgt_row.clone());
            }
        }
    }

    Ok(matching_rows)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutations-1"><a class="header" href="#mutations-1">Mutations</a></h1>
<p>In this section, we will break down the implementation of the <code>/mutation</code> endpoint.</p>
<p>The mutation endpoint is handled by the <code>post_mutation</code> function:</p>
<pre><code class="language-rust no_run noplayground">async fn post_mutation(
    State(state): State&lt;Arc&lt;Mutex&lt;AppState&gt;&gt;&gt;,
    Json(request): Json&lt;models::MutationRequest&gt;,
) -&gt; Result&lt;Json&lt;models::MutationResponse&gt;&gt; {</code></pre>
<p>This function receives the application state, and the <a href="tutorial/mutations/../../reference/types.html#mutationrequest"><code>MutationRequest</code></a> structure.</p>
<p>The function iterates over the collection of requested <a href="tutorial/mutations/../../reference/types.html#mutationoperation"><code>MutationOperation</code></a> structures, and handles each one in turn, adding each result to the <code>operation_results</code> field in the response:</p>
<pre><code class="language-rust no_run noplayground">    if request.operations.len() &gt; 1 {
        Err((
            StatusCode::NOT_IMPLEMENTED,
            Json(models::ErrorResponse {
                message: "transactional mutations are not supported".into(),
                details: serde_json::Value::Null,
            }),
        ))
    } else {
        let mut state = state.lock().await;

        let mut operation_results = vec![];

        for operation in &amp;request.operations {
            let operation_result = execute_mutation_operation(
                &amp;mut state,
                &amp;request.collection_relationships,
                operation,
            )?;
            operation_results.push(operation_result);
        }

        Ok(Json(models::MutationResponse { operation_results }))
    }
}</code></pre>
<p>The <code>execute_mutation_operation</code> function is responsible for executing an individual operation. In the next section, we'll break that function down.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-operations"><a class="header" href="#handling-operations">Handling Operations</a></h1>
<p>The <code>execute_mutation_operation</code> function is responsible for handling a single <a href="tutorial/mutations/../../reference/types.html#mutationoperation"><code>MutationOperation</code></a>, and returning the corresponding <a href="tutorial/mutations/../../reference/types.html#mutationoperationresults"><code>MutationOperationResults</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn execute_mutation_operation(
    state: &amp;mut AppState,
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
    operation: &amp;models::MutationOperation,
) -&gt; Result&lt;models::MutationOperationResults&gt; {
    match operation {
        models::MutationOperation::Procedure {
            name,
            arguments,
            fields,
        } =&gt; execute_procedure(state, name, arguments, fields, collection_relationships),
    }
}</code></pre>
<p>The function matches on the type of the operation, and delegates to the appropriate function. Currently, the only type of operation is <code>Procedure</code>, so the function delegates to the <code>execute_procedure</code> function. In the next section, we will break down the implementation of that function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures-4"><a class="header" href="#procedures-4">Procedures</a></h1>
<p>The <code>execute_procedure</code> function is responsible for executing a single procedure:</p>
<pre><code class="language-rust no_run noplayground">fn execute_procedure(
    state: &amp;mut AppState,
    name: &amp;models::ProcedureName,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, serde_json::Value&gt;,
    fields: &amp;Option&lt;models::NestedField&gt;,
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
) -&gt; std::result::Result&lt;models::MutationOperationResults, (StatusCode, Json&lt;models::ErrorResponse&gt;)&gt;</code></pre>
<p>The function receives the application <code>state</code>, along with the <code>name</code> of the procedure to invoke, a list of <code>arguments</code>, a list of <code>fields</code> to return, and a list of <code>collection_relationships</code>.</p>
<p>The function matches on the name of the procedure, and fails if the name is not recognized. We will walk through each procedure in turn.</p>
<pre><code class="language-rust no_run noplayground">{
    match name.as_str() {
        "upsert_article" =&gt; {
            execute_upsert_article(state, arguments, fields, collection_relationships)
        }
        "delete_articles" =&gt; {
            execute_delete_articles(state, arguments, fields, collection_relationships)
        }
        _ =&gt; Err((
            StatusCode::BAD_REQUEST,
            Json(models::ErrorResponse {
                message: "unknown procedure".into(),
                details: serde_json::Value::Null,
            }),
        )),
    }
}</code></pre>
<h2 id="upsert_article"><a class="header" href="#upsert_article"><code>upsert_article</code></a></h2>
<p>The <code>upsert_article</code> procedure is implemented by the <code>execute_upsert_article</code> function.</p>
<p>The <code>execute_upsert_article</code> function reads the <code>article</code> argument from the <code>arguments</code> list, failing if it is not found or invalid.</p>
<p>It then inserts or updates that article in the application state, depending on whether or not an article with that <code>id</code> already exists or not.</p>
<p>Finally, it delegates to the <code>eval_nested_field</code> function to evaluate any nested fields, and returns the selected fields in the result:</p>
<pre><code class="language-rust no_run noplayground">fn execute_upsert_article(
    state: &amp;mut AppState,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, serde_json::Value&gt;,
    fields: &amp;Option&lt;models::NestedField&gt;,
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
) -&gt; std::result::Result&lt;models::MutationOperationResults, (StatusCode, Json&lt;models::ErrorResponse&gt;)&gt;
{
    let article = arguments.get("article").ok_or((
        StatusCode::BAD_REQUEST,
        Json(models::ErrorResponse {
            message: "Expected argument 'article'".into(),
            details: serde_json::Value::Null,
        }),
    ))?;
    let article_obj: Row = serde_json::from_value(article.clone()).map_err(|_| {
        (
            StatusCode::BAD_REQUEST,
            Json(models::ErrorResponse {
                message: "article must be an object".into(),
                details: serde_json::Value::Null,
            }),
        )
    })?;
    let id = article_obj.get("id").ok_or((
        StatusCode::BAD_REQUEST,
        Json(models::ErrorResponse {
            message: "article missing field 'id'".into(),
            details: serde_json::Value::Null,
        }),
    ))?;
    let id_int = id
        .as_i64()
        .ok_or((
            StatusCode::BAD_REQUEST,
            Json(models::ErrorResponse {
                message: "id must be an integer".into(),
                details: serde_json::Value::Null,
            }),
        ))?
        .try_into()
        .map_err(|_| {
            (
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "id out of range".into(),
                    details: serde_json::Value::Null,
                }),
            )
        })?;
    let old_row = state.articles.insert(id_int, article_obj);

    Ok(models::MutationOperationResults::Procedure {
        result: old_row.map_or(Ok(serde_json::Value::Null), |old_row| {
            let old_row_value = serde_json::to_value(old_row).map_err(|_| {
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    Json(models::ErrorResponse {
                        message: "cannot encode response".into(),
                        details: serde_json::Value::Null,
                    }),
                )
            })?;

            let old_row_fields = match fields {
                None =&gt; Ok(models::RowFieldValue(old_row_value)),
                Some(nested_field) =&gt; eval_nested_field(
                    collection_relationships,
                    &amp;BTreeMap::new(),
                    state,
                    old_row_value,
                    nested_field,
                ),
            }?;

            Ok(old_row_fields.0)
        })?,
    })
}</code></pre>
<h2 id="delete_articles"><a class="header" href="#delete_articles"><code>delete_articles</code></a></h2>
<p>The <code>delete_articles</code> procedure is implemented by the <code>execute_delete_articles</code> function.</p>
<p>It is provided as an example of a procedure with a <a href="tutorial/mutations/../../specification/types.html#predicate-types">predicate type</a> as the type of an argument.</p>
<p>The <code>execute_delete_articles</code> function reads the <code>where</code> argument from the <code>arguments</code> list, failing if it is not found or invalid.</p>
<p>It then deletes all articles in the application state which match the predicate, and returns a list of the deleted rows.</p>
<p>This function delegates to the <code>eval_nested_field</code> function to evaluate any nested fields, and returns the selected fields in the result:</p>
<pre><code class="language-rust no_run noplayground">fn execute_delete_articles(
    state: &amp;mut AppState,
    arguments: &amp;BTreeMap&lt;models::ArgumentName, serde_json::Value&gt;,
    fields: &amp;Option&lt;models::NestedField&gt;,
    collection_relationships: &amp;BTreeMap&lt;models::RelationshipName, models::Relationship&gt;,
) -&gt; std::result::Result&lt;models::MutationOperationResults, (StatusCode, Json&lt;models::ErrorResponse&gt;)&gt;
{
    let predicate_value = arguments.get("where").ok_or((
        StatusCode::BAD_REQUEST,
        Json(models::ErrorResponse {
            message: "Expected argument 'where'".into(),
            details: serde_json::Value::Null,
        }),
    ))?;
    let predicate: models::Expression =
        serde_json::from_value(predicate_value.clone()).map_err(|_| {
            (
                StatusCode::BAD_REQUEST,
                Json(models::ErrorResponse {
                    message: "Bad predicate".into(),
                    details: serde_json::Value::Null,
                }),
            )
        })?;

    let mut removed: Vec&lt;Row&gt; = vec![];

    let state_snapshot = state.clone();

    for article in state.articles.values_mut() {
        if eval_expression(
            &amp;BTreeMap::new(),
            &amp;BTreeMap::new(),
            &amp;state_snapshot,
            &amp;predicate,
            &amp;[],
            article,
        )? {
            removed.push(article.clone());
        }
    }

    let removed_value = serde_json::to_value(removed).map_err(|_| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(models::ErrorResponse {
                message: "cannot encode response".into(),
                details: serde_json::Value::Null,
            }),
        )
    })?;

    let removed_fields = match fields {
        None =&gt; Ok(models::RowFieldValue(removed_value)),
        Some(nested_field) =&gt; eval_nested_field(
            collection_relationships,
            &amp;BTreeMap::new(),
            &amp;state_snapshot,
            removed_value,
            nested_field,
        ),
    }?;

    Ok(models::MutationOperationResults::Procedure {
        result: removed_fields.0,
    })
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain-1"><a class="header" href="#explain-1">Explain</a></h1>
<p>The <code>/query/explain</code> and <code>/mutation/explain</code> endpoints are not implemented in the reference implementation, because their respective request objects are interpreted directly. There is no intermediate representation (such as SQL) which could be described as an "execution plan".</p>
<p>The <code>query.explain</code> and <code>mutation.explain</code> capabilities are turned off in the <a href="tutorial/./capabilities.html">capabilities endpoint</a>,
and the <code>/query/explain</code> and <code>/mutation/explain</code> endpoints throw an error:</p>
<pre><code class="language-rust no_run noplayground">async fn post_query_explain(
    Json(_request): Json&lt;models::QueryRequest&gt;,
) -&gt; Result&lt;Json&lt;models::ExplainResponse&gt;&gt; {
    Err((
        StatusCode::NOT_IMPLEMENTED,
        Json(models::ErrorResponse {
            message: "explain is not supported".into(),
            details: serde_json::Value::Null,
        }),
    ))
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="health-and-metrics"><a class="header" href="#health-and-metrics">Health and Metrics</a></h1>
<h2 id="service-health-1"><a class="header" href="#service-health-1">Service Health</a></h2>
<p>The <code>/health</code> endpoint has nothing to check, because the reference implementation does not need to connect to any other services. Therefore, once the reference implementation is running, it can always report a healthy status:</p>
<pre><code class="language-rust no_run noplayground">async fn get_health() -&gt; StatusCode {
    StatusCode::OK
}</code></pre>
<p>In practice, a connector should make sure that any upstream services can be successfully contacted, and respond accordingly.</p>
<h2 id="metrics-1"><a class="header" href="#metrics-1">Metrics</a></h2>
<p>The reference implementation maintains some generic access metrics in its application state:</p>
<ul>
<li><code>metrics.total_requests</code> counts the number of requests ever served, and</li>
<li><code>metrics.active_requests</code> counts the number of requests <em>currently</em> being served.</li>
</ul>
<p>The <a href="tutorial/../specification/metrics.html">metrics endpoint</a> reports these metrics using the Rust <a href="https://docs.rs/prometheus/latest/prometheus/">prometheus</a> crate:</p>
<pre><code class="language-rust no_run noplayground">async fn get_metrics(State(state): State&lt;Arc&lt;Mutex&lt;AppState&gt;&gt;&gt;) -&gt; Result&lt;String&gt; {
    let state = state.lock().await;
    state.metrics.as_text().ok_or((
        StatusCode::INTERNAL_SERVER_ERROR,
        Json(models::ErrorResponse {
            message: "cannot encode metrics".into(),
            details: serde_json::Value::Null,
        }),
    ))
}</code></pre>
<p>To maintain these metrics, it uses a simple metrics middleware:</p>
<pre><code class="language-rust no_run noplayground">async fn metrics_middleware(
    state: State&lt;Arc&lt;Mutex&lt;AppState&gt;&gt;&gt;,
    request: axum::extract::Request,
    next: axum::middleware::Next,
) -&gt; axum::response::Response {
    // Don't hold the lock to update metrics, since the
    // lock doesn't protect the metrics anyway.
    let metrics = {
        let state = state.lock().await;
        state.metrics.clone()
    };

    metrics.total_requests.inc();
    metrics.active_requests.inc();
    let response = next.run(request).await;
    metrics.active_requests.dec();
    response
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-1"><a class="header" href="#types-1">Types</a></h1>
<h2 id="aggregate"><a class="header" href="#aggregate"><code>Aggregate</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[skip_serializing_none]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Aggregate")]
pub enum Aggregate {
    ColumnCount {
        /// The column to apply the count aggregate function to
        column: FieldName,
        /// Arguments to satisfy the column specified by 'column'
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested field within an object column
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
        /// Whether or not only distinct items should be counted
        distinct: bool,
    },
    SingleColumn {
        /// The column to apply the aggregation function to
        column: FieldName,
        /// Arguments to satisfy the column specified by 'column'
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested field within an object column
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
        /// Single column aggregate function name.
        function: AggregateFunctionName,
    },
    StarCount {},
}</code></pre>
<h2 id="aggregatecapabilities"><a class="header" href="#aggregatecapabilities"><code>AggregateCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Aggregate Capabilities")]
pub struct AggregateCapabilities {
    /// Does the connector support filtering based on aggregated values
    pub filter_by: Option&lt;LeafCapability&gt;,
    /// Does the connector support aggregations over groups
    pub group_by: Option&lt;GroupByCapabilities&gt;,
}</code></pre>
<h2 id="aggregatecapabilitiesschemainfo"><a class="header" href="#aggregatecapabilitiesschemainfo"><code>AggregateCapabilitiesSchemaInfo</code></a></h2>
<pre><code class="language-rust norun noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Aggregate Capabilities Schema Info")]
pub struct AggregateCapabilitiesSchemaInfo {
    /// The scalar type which should be used for the return type of count
    /// (star_count and column_count) operations.
    pub count_scalar_type: ScalarTypeName,
}</code></pre>
<h2 id="aggregatefunctiondefinition"><a class="header" href="#aggregatefunctiondefinition"><code>AggregateFunctionDefinition</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an aggregation function on a scalar type
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Aggregate Function Definition")]
pub enum AggregateFunctionDefinition {
    Min,
    Max,
    Sum {
        /// The scalar type of the result of this function, which should have
        /// one of the type representations Int64 or Float64, depending on
        /// whether this function is defined on a scalar type with an integer or
        /// floating-point representation, respectively.
        result_type: ScalarTypeName,
    },
    Average {
        /// The scalar type of the result of this function, which should have
        /// the type representation Float64
        result_type: ScalarTypeName,
    },
    Custom {
        /// The scalar or object type of the result of this function
        result_type: Type,
    },
}</code></pre>
<h2 id="argument"><a class="header" href="#argument"><code>Argument</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Argument")]
pub enum Argument {
    /// The argument is provided by reference to a variable.
    /// Only used if the 'query.variables' capability is supported.
    Variable { name: VariableName },
    /// The argument is provided as a literal value
    Literal { value: serde_json::Value },
}</code></pre>
<h2 id="argumentinfo"><a class="header" href="#argumentinfo"><code>ArgumentInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Argument Info")]
pub struct ArgumentInfo {
    /// Argument description
    pub description: Option&lt;String&gt;,
    /// The name of the type of this argument
    #[serde(rename = "type")]
    pub argument_type: Type,
}</code></pre>
<h2 id="arraycomparison"><a class="header" href="#arraycomparison"><code>ArrayComparison</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Array Comparison")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ArrayComparison {
    /// Check if the array contains the specified value.
    /// Only used if the 'query.nested_fields.filter_by.nested_arrays.contains' capability is supported.
    Contains { value: ComparisonValue },
    /// Check is the array is empty.
    /// Only used if the 'query.nested_fields.filter_by.nested_arrays.is_empty' capability is supported.
    IsEmpty,
}</code></pre>
<h2 id="capabilities-3"><a class="header" href="#capabilities-3"><code>Capabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground"></code></pre>
<h2 id="capabilitiesresponse"><a class="header" href="#capabilitiesresponse"><code>CapabilitiesResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Capabilities Response")]
pub struct CapabilitiesResponse {
    pub version: String,
    pub capabilities: Capabilities,
}</code></pre>
<h2 id="capabilityschemainfo"><a class="header" href="#capabilityschemainfo"><code>CapabilitySchemaInfo</code></a></h2>
<pre><code class="language-rust norun noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Capability Schema Info")]
pub struct CapabilitySchemaInfo {
    /// Schema information relevant to query capabilities
    pub query: Option&lt;QueryCapabilitiesSchemaInfo&gt;,
}</code></pre>
<h2 id="comparisonoperatordefinition"><a class="header" href="#comparisonoperatordefinition"><code>ComparisonOperatorDefinition</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of a comparison operator on a scalar type
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Comparison Operator Definition")]
pub enum ComparisonOperatorDefinition {
    Equal,
    In,
    LessThan,
    LessThanOrEqual,
    GreaterThan,
    GreaterThanOrEqual,
    Contains,
    ContainsInsensitive,
    StartsWith,
    StartsWithInsensitive,
    EndsWith,
    EndsWithInsensitive,
    Custom {
        /// The type of the argument to this operator
        argument_type: Type,
    },
}</code></pre>
<h2 id="comparisontarget"><a class="header" href="#comparisontarget"><code>ComparisonTarget</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Comparison Target")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ComparisonTarget {
    /// The comparison targets a column.
    Column {
        /// The name of the column
        name: FieldName,
        /// Arguments to satisfy the column specified by 'name'
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested field within an object column.
        /// Only non-empty if the 'query.nested_fields.filter_by' capability is supported.
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
    },
    /// The comparison targets the result of aggregation.
    /// Only used if the 'query.aggregates.filter_by' capability is supported.
    Aggregate {
        /// Non-empty collection of relationships to traverse
        path: Vec&lt;PathElement&gt;,
        /// The aggregation method to use
        aggregate: Aggregate,
    },
}</code></pre>
<h2 id="comparisonvalue"><a class="header" href="#comparisonvalue"><code>ComparisonValue</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Comparison Value")]
pub enum ComparisonValue {
    /// The value to compare against should be drawn from another column
    Column {
        /// Any relationships to traverse to reach this column.
        /// Only non-empty if the 'relationships.relation_comparisons' is supported.
        path: Vec&lt;PathElement&gt;,
        /// The name of the column
        name: FieldName,
        /// Arguments to satisfy the column specified by 'name'
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested field within an object column.
        /// Only non-empty if the 'query.nested_fields.filter_by' capability is supported.
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
        /// The scope in which this column exists, identified
        /// by an top-down index into the stack of scopes.
        /// The stack grows inside each `Expression::Exists`,
        /// so scope 0 (the default) refers to the current collection,
        /// and each subsequent index refers to the collection outside
        /// its predecessor's immediately enclosing `Expression::Exists`
        /// expression.
        /// Only used if the 'query.exists.named_scopes' capability is supported.
        scope: Option&lt;usize&gt;,
    },
    /// A scalar value to compare against
    Scalar { value: serde_json::Value },
    /// A value to compare against that is to be drawn from the query's variables.
    /// Only used if the 'query.variables' capability is supported.
    Variable { name: VariableName },
}</code></pre>
<h2 id="dimension"><a class="header" href="#dimension"><code>Dimension</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[skip_serializing_none]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Dimension")]
pub enum Dimension {
    Column {
        /// Any (object) relationships to traverse to reach this column.
        /// Only non-empty if the 'relationships' capability is supported.
        path: Vec&lt;PathElement&gt;,
        /// The name of the column
        column_name: FieldName,
        /// Arguments to satisfy the column specified by 'column_name'
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested field within an object column
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
        /// The name of the extraction function to apply to the selected value, if any
        extraction: Option&lt;ExtractionFunctionName&gt;,
    },
}</code></pre>
<h2 id="errorresponse"><a class="header" href="#errorresponse"><code>ErrorResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Error Response")]
pub struct ErrorResponse {
    /// A human-readable summary of the error
    pub message: String,
    /// Any additional structured information about the error
    pub details: serde_json::Value,
}</code></pre>
<h2 id="existscapabilities"><a class="header" href="#existscapabilities"><code>ExistsCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Exists Capabilities")]
pub struct ExistsCapabilities {
    /// Does the connector support named scopes in column references inside
    /// EXISTS predicates
    pub named_scopes: Option&lt;LeafCapability&gt;,
    /// Does the connector support ExistsInCollection::Unrelated
    pub unrelated: Option&lt;LeafCapability&gt;,
    /// Does the connector support ExistsInCollection::NestedCollection
    pub nested_collections: Option&lt;LeafCapability&gt;,
    /// Does the connector support filtering over nested scalar arrays using existential quantification.
    /// This means the connector must support ExistsInCollection::NestedScalarCollection.
    pub nested_scalar_collections: Option&lt;LeafCapability&gt;,
}</code></pre>
<h2 id="existsincollection"><a class="header" href="#existsincollection"><code>ExistsInCollection</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Exists In Collection")]
pub enum ExistsInCollection {
    /// The rows to evaluate the exists predicate against come from a related collection.
    /// Only used if the 'relationships' capability is supported.
    Related {
        #[serde(skip_serializing_if = "Option::is_none", default)]
        /// Path to a nested field within an object column that must be navigated
        /// before the relationship is navigated.
        /// Only non-empty if the 'relationships.nested.filtering' capability is supported.
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
        /// The name of the relationship to follow
        relationship: RelationshipName,
        /// Values to be provided to any collection arguments
        arguments: BTreeMap&lt;ArgumentName, RelationshipArgument&gt;,
    },
    /// The rows to evaluate the exists predicate against come from an unrelated collection
    /// Only used if the 'query.exists.unrelated' capability is supported.
    Unrelated {
        /// The name of a collection
        collection: CollectionName,
        /// Values to be provided to any collection arguments
        arguments: BTreeMap&lt;ArgumentName, RelationshipArgument&gt;,
    },
    /// The rows to evaluate the exists predicate against come from a nested array field.
    /// Only used if the 'query.exists.nested_collections' capability is supported.
    NestedCollection {
        column_name: FieldName,
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested collection via object columns
        #[serde(skip_serializing_if = "Vec::is_empty", default)]
        field_path: Vec&lt;FieldName&gt;,
    },
    /// Specifies a column that contains a nested array of scalars. The
    /// array will be brought into scope of the nested expression where
    /// each element becomes an object with one '__value' column that
    /// contains the element value.
    /// Only used if the 'query.exists.nested_scalar_collections' capability is supported.
    NestedScalarCollection {
        column_name: FieldName,
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested collection via object columns
        #[serde(skip_serializing_if = "Vec::is_empty", default)]
        field_path: Vec&lt;FieldName&gt;,
    },
}</code></pre>
<h2 id="explainresponse"><a class="header" href="#explainresponse"><code>ExplainResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Explain Response")]
pub struct ExplainResponse {
    /// A list of human-readable key-value pairs describing
    /// a query execution plan. For example, a connector for
    /// a relational database might return the generated SQL
    /// and/or the output of the `EXPLAIN` command. An API-based
    /// connector might encode a list of statically-known API
    /// calls which would be made.
    pub details: BTreeMap&lt;String, String&gt;,
}</code></pre>
<h2 id="expression"><a class="header" href="#expression"><code>Expression</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Expression")]
pub enum Expression {
    And {
        expressions: Vec&lt;Expression&gt;,
    },
    Or {
        expressions: Vec&lt;Expression&gt;,
    },
    Not {
        expression: Box&lt;Expression&gt;,
    },
    UnaryComparisonOperator {
        column: ComparisonTarget,
        operator: UnaryComparisonOperator,
    },
    BinaryComparisonOperator {
        column: ComparisonTarget,
        operator: ComparisonOperatorName,
        value: ComparisonValue,
    },
    /// A comparison against a nested array column.
    /// Only used if the 'query.nested_fields.filter_by.nested_arrays' capability is supported.
    ArrayComparison {
        column: ComparisonTarget,
        comparison: ArrayComparison,
    },
    Exists {
        in_collection: ExistsInCollection,
        predicate: Option&lt;Box&lt;Expression&gt;&gt;,
    },
}</code></pre>
<h2 id="extractionfunctiondefinition"><a class="header" href="#extractionfunctiondefinition"><code>ExtractionFunctionDefinition</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an aggregation function on a scalar type
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Extraction Function Definition")]
pub enum ExtractionFunctionDefinition {
    Nanosecond {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Microsecond {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Millisecond {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Second {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Minute {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Hour {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Day {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Week {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Month {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Quarter {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Year {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    DayOfWeek {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    DayOfYear {
        /// The result type, which must be a defined scalar type in the schema response.
        result_type: ScalarTypeName,
    },
    Custom {
        /// The scalar or object type of the result of this function
        result_type: Type,
    },
}</code></pre>
<h2 id="field"><a class="header" href="#field"><code>Field</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Field")]
pub enum Field {
    /// A field satisfied by returning the value of a row's column.
    Column {
        column: FieldName,
        /// When the type of the column is a (possibly-nullable) array or object,
        /// the caller can request a subset of the complete column data,
        /// by specifying fields to fetch here.
        /// If omitted, the column data will be fetched in full.
        fields: Option&lt;NestedField&gt;,
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
    },
    /// A field satisfied by navigating a relationship from the current row to a related collection.
    /// Only used if the 'relationships' capability is supported.
    Relationship {
        query: Box&lt;Query&gt;,
        /// The name of the relationship to follow for the subquery
        relationship: RelationshipName,
        /// Values to be provided to any collection arguments
        arguments: BTreeMap&lt;ArgumentName, RelationshipArgument&gt;,
    },
}</code></pre>
<h2 id="foreignkeyconstraint"><a class="header" href="#foreignkeyconstraint"><code>ForeignKeyConstraint</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Foreign Key Constraint")]
pub struct ForeignKeyConstraint {
    /// The columns on which you want want to define the foreign key.
    /// This is a mapping between fields on object type to columns on the foreign collection.
    /// The column on the foreign collection is specified via a field path (ie. an array of field
    /// names that descend through nested object fields). The field path must only contain a single item,
    /// meaning a column on the foreign collection's type, unless the 'relationships.nested'
    /// capability is supported, in which case multiple items can be used to denote a nested object field.
    pub column_mapping: BTreeMap&lt;FieldName, Vec&lt;FieldName&gt;&gt;,
    /// The name of a collection
    pub foreign_collection: CollectionName,
}</code></pre>
<h2 id="functioninfo"><a class="header" href="#functioninfo"><code>FunctionInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Function Info")]
pub struct FunctionInfo {
    /// The name of the function
    pub name: FunctionName,
    /// Description of the function
    pub description: Option&lt;String&gt;,
    /// Any arguments that this collection requires
    pub arguments: BTreeMap&lt;ArgumentName, ArgumentInfo&gt;,
    /// The name of the function's result type
    pub result_type: Type,
}</code></pre>
<h2 id="group"><a class="header" href="#group"><code>Group</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Group")]
pub struct Group {
    /// Values of dimensions which identify this group
    pub dimensions: Vec&lt;serde_json::Value&gt;,
    /// Aggregates computed within this group
    pub aggregates: IndexMap&lt;FieldName, serde_json::Value&gt;,
}</code></pre>
<h2 id="groupcomparisontarget"><a class="header" href="#groupcomparisontarget"><code>GroupComparisonTarget</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Aggregate Comparison Target")]
pub enum GroupComparisonTarget {
    Aggregate { aggregate: Aggregate },
}</code></pre>
<h2 id="groupcomparisonvalue"><a class="header" href="#groupcomparisonvalue"><code>GroupComparisonValue</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Aggregate Comparison Value")]
pub enum GroupComparisonValue {
    /// A scalar value to compare against
    Scalar { value: serde_json::Value },
    /// A value to compare against that is to be drawn from the query's variables.
    /// Only used if the 'query.variables' capability is supported.
    Variable { name: VariableName },
}</code></pre>
<h2 id="groupexpression"><a class="header" href="#groupexpression"><code>GroupExpression</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Group Expression")]
pub enum GroupExpression {
    And {
        expressions: Vec&lt;GroupExpression&gt;,
    },
    Or {
        expressions: Vec&lt;GroupExpression&gt;,
    },
    Not {
        expression: Box&lt;GroupExpression&gt;,
    },
    UnaryComparisonOperator {
        target: GroupComparisonTarget,
        operator: UnaryComparisonOperator,
    },
    BinaryComparisonOperator {
        target: GroupComparisonTarget,
        operator: ComparisonOperatorName,
        value: GroupComparisonValue,
    },
}</code></pre>
<h2 id="grouping-3"><a class="header" href="#grouping-3"><code>Grouping</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Grouping")]
pub struct Grouping {
    /// Dimensions along which to partition the data
    pub dimensions: Vec&lt;Dimension&gt;,
    /// Aggregates to compute in each group
    pub aggregates: IndexMap&lt;FieldName, Aggregate&gt;,
    /// Optionally specify a predicate to apply after grouping rows.
    /// Only used if the 'query.aggregates.group_by.filter' capability is supported.
    pub predicate: Option&lt;GroupExpression&gt;,
    /// Optionally specify how groups should be ordered
    /// Only used if the 'query.aggregates.group_by.order' capability is supported.
    pub order_by: Option&lt;GroupOrderBy&gt;,
    /// Optionally limit to N groups
    /// Only used if the 'query.aggregates.group_by.paginate' capability is supported.
    pub limit: Option&lt;u32&gt;,
    /// Optionally offset from the Nth group
    /// Only used if the 'query.aggregates.group_by.paginate' capability is supported.
    pub offset: Option&lt;u32&gt;,
}</code></pre>
<h2 id="groupbycapabilities"><a class="header" href="#groupbycapabilities"><code>GroupByCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Group By Capabilities")]
pub struct GroupByCapabilities {
    /// Does the connector support post-grouping predicates
    pub filter: Option&lt;LeafCapability&gt;,
    /// Does the connector support post-grouping ordering
    pub order: Option&lt;LeafCapability&gt;,
    /// Does the connector support post-grouping pagination
    pub paginate: Option&lt;LeafCapability&gt;,
}</code></pre>
<h2 id="grouporderby"><a class="header" href="#grouporderby"><code>GroupOrderBy</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Group Order By")]
pub struct GroupOrderBy {
    /// The elements to order by, in priority order
    pub elements: Vec&lt;GroupOrderByElement&gt;,
}</code></pre>
<h2 id="grouporderbyelement"><a class="header" href="#grouporderbyelement"><code>GroupOrderByElement</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Group Order By Element")]
pub struct GroupOrderByElement {
    pub order_direction: OrderDirection,
    pub target: GroupOrderByTarget,
}</code></pre>
<h2 id="grouporderbytarget"><a class="header" href="#grouporderbytarget"><code>GroupOrderByTarget</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Group Order By Target")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum GroupOrderByTarget {
    Dimension {
        /// The index of the dimension to order by, selected from the
        /// dimensions provided in the `Grouping` request.
        index: usize,
    },
    Aggregate {
        /// Aggregation method to apply
        aggregate: Aggregate,
    },
}</code></pre>
<h2 id="leafcapability"><a class="header" href="#leafcapability"><code>LeafCapability</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// A unit value to indicate a particular leaf capability is supported.
/// This is an empty struct to allow for future sub-capabilities.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct LeafCapability {}</code></pre>
<h2 id="mutationcapabilities"><a class="header" href="#mutationcapabilities"><code>MutationCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Mutation Capabilities")]
pub struct MutationCapabilities {
    /// Does the connector support executing multiple mutations in a transaction.
    pub transactional: Option&lt;LeafCapability&gt;,
    /// Does the connector support explaining mutations
    pub explain: Option&lt;LeafCapability&gt;,
}</code></pre>
<h2 id="mutationoperation"><a class="header" href="#mutationoperation"><code>MutationOperation</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Mutation Operation")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum MutationOperation {
    Procedure {
        /// The name of a procedure
        name: ProcedureName,
        /// Any named procedure arguments
        arguments: BTreeMap&lt;ArgumentName, serde_json::Value&gt;,
        /// The fields to return from the result, or null to return everything
        fields: Option&lt;NestedField&gt;,
    },
}</code></pre>
<h2 id="mutationoperationresults"><a class="header" href="#mutationoperationresults"><code>MutationOperationResults</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Mutation Operation Results")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum MutationOperationResults {
    Procedure { result: serde_json::Value },
}</code></pre>
<h2 id="mutationrequest"><a class="header" href="#mutationrequest"><code>MutationRequest</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Mutation Request")]
pub struct MutationRequest {
    /// The mutation operations to perform
    pub operations: Vec&lt;MutationOperation&gt;,
    /// The relationships between collections involved in the entire mutation request.
    /// Only used if the 'relationships' capability is supported.
    pub collection_relationships: BTreeMap&lt;RelationshipName, Relationship&gt;,
    /// Values to be provided to request-level arguments.
    pub request_arguments: Option&lt;BTreeMap&lt;ArgumentName, serde_json::Value&gt;&gt;,
}</code></pre>
<h2 id="mutationresponse"><a class="header" href="#mutationresponse"><code>MutationResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Mutation Response")]
pub struct MutationResponse {
    /// The results of each mutation operation, in the same order as they were received
    pub operation_results: Vec&lt;MutationOperationResults&gt;,
}</code></pre>
<h2 id="nestedarray"><a class="header" href="#nestedarray"><code>NestedArray</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
#[schemars(title = "NestedArray")]
pub struct NestedArray {
    pub fields: Box&lt;NestedField&gt;,
}</code></pre>
<h2 id="nestedarrayfilterbycapabilities"><a class="header" href="#nestedarrayfilterbycapabilities"><code>NestedArrayFilterByCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Nested Array Filter By Capabilities")]
pub struct NestedArrayFilterByCapabilities {
    /// Does the connector support filtering over nested arrays by checking if the array contains a value.
    /// This must be supported for all types that can be contained in an array that implement an 'eq'
    /// comparison operator.
    pub contains: Option&lt;LeafCapability&gt;,
    /// Does the connector support filtering over nested arrays by checking if the array is empty.
    /// This must be supported no matter what type is contained in the array.
    pub is_empty: Option&lt;LeafCapability&gt;,
}</code></pre>
<h2 id="nestedcollection"><a class="header" href="#nestedcollection"><code>NestedCollection</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
#[schemars(title = "NestedCollection")]
pub struct NestedCollection {
    pub query: Query,
}</code></pre>
<h2 id="nestedfield"><a class="header" href="#nestedfield"><code>NestedField</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "NestedField")]
pub enum NestedField {
    Object(NestedObject),
    Array(NestedArray),
    /// Perform a query over the nested array's rows.
    /// Only used if the 'query.nested_fields.nested_collections' capability is supported.
    Collection(NestedCollection),
}</code></pre>
<h2 id="nestedfieldcapabilities"><a class="header" href="#nestedfieldcapabilities"><code>NestedFieldCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Nested Field Capabilities")]
pub struct NestedFieldCapabilities {
    /// Does the connector support filtering by values of nested fields
    pub filter_by: Option&lt;NestedFieldFilterByCapabilities&gt;,
    /// Does the connector support ordering by values of nested fields
    pub order_by: Option&lt;LeafCapability&gt;,
    /// Does the connector support aggregating values within nested fields
    pub aggregates: Option&lt;LeafCapability&gt;,
    /// Does the connector support nested collection queries using
    /// `NestedField::NestedCollection`
    pub nested_collections: Option&lt;LeafCapability&gt;,
}</code></pre>
<h2 id="nestedfieldfilterbycapabilities"><a class="header" href="#nestedfieldfilterbycapabilities"><code>NestedFieldFilterByCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Nested Field Filter By Capabilities")]
pub struct NestedFieldFilterByCapabilities {
    /// Does the connector support filtering over nested arrays (ie. Expression::ArrayComparison)
    pub nested_arrays: Option&lt;NestedArrayFilterByCapabilities&gt;,
}</code></pre>
<h2 id="nestedobject"><a class="header" href="#nestedobject"><code>NestedObject</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
#[schemars(title = "NestedObject")]
pub struct NestedObject {
    pub fields: IndexMap&lt;FieldName, Field&gt;,
}</code></pre>
<h2 id="nestedrelationshipcapabilities"><a class="header" href="#nestedrelationshipcapabilities"><code>NestedRelationshipCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Nested Relationship Capabilities")]
pub struct NestedRelationshipCapabilities {
    /// Does the connector support navigating a relationship from inside a nested object inside a nested array
    pub array: Option&lt;LeafCapability&gt;,
    /// Does the connector support filtering over a relationship that starts from inside a nested object
    pub filtering: Option&lt;LeafCapability&gt;,
    /// Does the connector support ordering over a relationship that starts from inside a nested object
    pub ordering: Option&lt;LeafCapability&gt;,
}</code></pre>
<h2 id="objectfield"><a class="header" href="#objectfield"><code>ObjectField</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an object field
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Object Field")]
pub struct ObjectField {
    /// Description of this field
    pub description: Option&lt;String&gt;,
    /// The type of this field
    #[serde(rename = "type")]
    pub r#type: Type,
    /// The arguments available to the field - Matches implementation from CollectionInfo
    #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
    pub arguments: BTreeMap&lt;ArgumentName, ArgumentInfo&gt;,
}</code></pre>
<h2 id="objecttype"><a class="header" href="#objecttype"><code>ObjectType</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an object type
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Object Type")]
pub struct ObjectType {
    /// Description of this type
    pub description: Option&lt;String&gt;,
    /// Fields defined on this object type
    pub fields: BTreeMap&lt;FieldName, ObjectField&gt;,
    /// Any foreign keys defined for this object type's columns
    pub foreign_keys: BTreeMap&lt;String, ForeignKeyConstraint&gt;,
}</code></pre>
<h2 id="orderby"><a class="header" href="#orderby"><code>OrderBy</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Order By")]
pub struct OrderBy {
    /// The elements to order by, in priority order
    pub elements: Vec&lt;OrderByElement&gt;,
}</code></pre>
<h2 id="orderbyelement"><a class="header" href="#orderbyelement"><code>OrderByElement</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Order By Element")]
pub struct OrderByElement {
    pub order_direction: OrderDirection,
    pub target: OrderByTarget,
}</code></pre>
<h2 id="orderbytarget"><a class="header" href="#orderbytarget"><code>OrderByTarget</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Order By Target")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum OrderByTarget {
    /// The ordering is performed over a column.
    Column {
        /// Any (object) relationships to traverse to reach this column.
        /// Only non-empty if the 'relationships' capability is supported.
        /// 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.
        path: Vec&lt;PathElement&gt;,
        /// The name of the column
        name: FieldName,
        /// Arguments to satisfy the column specified by 'name'
        #[serde(skip_serializing_if = "BTreeMap::is_empty", default)]
        arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
        /// Path to a nested field within an object column.
        /// Only non-empty if the 'query.nested_fields.order_by' capability is supported.
        field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
    },
    /// The ordering is performed over the result of an aggregation.
    /// Only used if the 'relationships.order_by_aggregate' capability is supported.
    Aggregate {
        /// Non-empty collection of relationships to traverse.
        /// Only non-empty if the 'relationships' capability is supported.
        /// 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.
        path: Vec&lt;PathElement&gt;,
        /// The aggregation method to use
        aggregate: Aggregate,
    },
}</code></pre>
<h2 id="orderdirection"><a class="header" href="#orderdirection"><code>OrderDirection</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[schemars(title = "Order Direction")]
#[serde(rename_all = "snake_case")]
pub enum OrderDirection {
    Asc,
    Desc,
}</code></pre>
<h2 id="pathelement"><a class="header" href="#pathelement"><code>PathElement</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
#[schemars(title = "Path Element")]
pub struct PathElement {
    #[serde(skip_serializing_if = "Option::is_none", default)]
    /// Path to a nested field within an object column that must be navigated
    /// before the relationship is navigated.
    /// Only non-empty if the 'relationships.nested' capability is supported
    /// (plus perhaps one of the sub-capabilities, depending on the feature using the PathElement).
    pub field_path: Option&lt;Vec&lt;FieldName&gt;&gt;,
    /// The name of the relationship to follow
    pub relationship: RelationshipName,
    /// Values to be provided to any collection arguments
    pub arguments: BTreeMap&lt;ArgumentName, RelationshipArgument&gt;,
    /// A predicate expression to apply to the target collection
    pub predicate: Option&lt;Box&lt;Expression&gt;&gt;,
}</code></pre>
<h2 id="procedureinfo"><a class="header" href="#procedureinfo"><code>ProcedureInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Procedure Info")]
pub struct ProcedureInfo {
    /// The name of the procedure
    pub name: ProcedureName,
    /// Column description
    pub description: Option&lt;String&gt;,
    /// Any arguments that this collection requires
    pub arguments: BTreeMap&lt;ArgumentName, ArgumentInfo&gt;,
    /// The name of the result type
    pub result_type: Type,
}</code></pre>
<h2 id="query"><a class="header" href="#query"><code>Query</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Query")]
pub struct Query {
    /// Aggregate fields of the query.
    /// Only used if the 'query.aggregates' capability is supported.
    pub aggregates: Option&lt;IndexMap&lt;FieldName, Aggregate&gt;&gt;,
    /// Fields of the query
    pub fields: Option&lt;IndexMap&lt;FieldName, Field&gt;&gt;,
    /// Optionally limit to N results
    pub limit: Option&lt;u32&gt;,
    /// Optionally offset from the Nth result
    pub offset: Option&lt;u32&gt;,
    /// Optionally specify how rows should be ordered
    pub order_by: Option&lt;OrderBy&gt;,
    /// Optionally specify a predicate to apply to the rows
    pub predicate: Option&lt;Expression&gt;,
    /// Optionally group and aggregate the selected rows.
    /// Only used if the 'query.aggregates.group_by' capability is supported.
    pub groups: Option&lt;Grouping&gt;,
}</code></pre>
<h2 id="querycapabilities"><a class="header" href="#querycapabilities"><code>QueryCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Query Capabilities")]
pub struct QueryCapabilities {
    /// Does the connector support aggregate queries
    pub aggregates: Option&lt;AggregateCapabilities&gt;,
    /// Does the connector support queries which use variables
    pub variables: Option&lt;LeafCapability&gt;,
    /// Does the connector support explaining queries
    pub explain: Option&lt;LeafCapability&gt;,
    /// Does the connector support nested fields
    #[serde(default)]
    pub nested_fields: NestedFieldCapabilities,
    /// Does the connector support EXISTS predicates
    #[serde(default)]
    pub exists: ExistsCapabilities,
}</code></pre>
<h2 id="querycapabilitiesschemainfo"><a class="header" href="#querycapabilitiesschemainfo"><code>QueryCapabilitiesSchemaInfo</code></a></h2>
<pre><code class="language-rust norun noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Query Capabilities Schema Info")]
pub struct QueryCapabilitiesSchemaInfo {
    /// Schema information relevant to aggregate query capabilities
    pub aggregates: Option&lt;AggregateCapabilitiesSchemaInfo&gt;,
}</code></pre>
<h2 id="queryrequest"><a class="header" href="#queryrequest"><code>QueryRequest</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// This is the request body of the query POST endpoint
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Query Request")]
pub struct QueryRequest {
    /// The name of a collection
    pub collection: CollectionName,
    /// The query syntax tree
    pub query: Query,
    /// Values to be provided to any collection arguments
    pub arguments: BTreeMap&lt;ArgumentName, Argument&gt;,
    /// Any relationships between collections involved in the query request.
    /// Only used if the 'relationships' capability is supported.
    pub collection_relationships: BTreeMap&lt;RelationshipName, Relationship&gt;,
    /// One set of named variables for each rowset to fetch. Each variable set
    /// should be subtituted in turn, and a fresh set of rows returned.
    /// Only used if the 'query.variables' capability is supported.
    pub variables: Option&lt;Vec&lt;BTreeMap&lt;VariableName, serde_json::Value&gt;&gt;&gt;,
    /// Values to be provided to request-level arguments.
    pub request_arguments: Option&lt;BTreeMap&lt;ArgumentName, serde_json::Value&gt;&gt;,
}</code></pre>
<h2 id="queryresponse"><a class="header" href="#queryresponse"><code>QueryResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Query Response")]
/// Query responses may return multiple RowSets when using queries with variables.
/// Else, there should always be exactly one RowSet
pub struct QueryResponse(pub Vec&lt;RowSet&gt;);</code></pre>
<h2 id="relationship"><a class="header" href="#relationship"><code>Relationship</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Relationship")]
pub struct Relationship {
    /// A mapping between columns on the source row to columns on the target collection.
    /// The column on the target collection is specified via a field path (ie. an array of field
    /// names that descend through nested object fields). The field path will only contain a single item,
    /// meaning a column on the target collection's type, unless the 'relationships.nested'
    /// capability is supported, in which case multiple items denotes a nested object field.
    pub column_mapping: BTreeMap&lt;FieldName, Vec&lt;FieldName&gt;&gt;,
    pub relationship_type: RelationshipType,
    /// The name of a collection
    pub target_collection: CollectionName,
    /// Values to be provided to any collection arguments
    pub arguments: BTreeMap&lt;ArgumentName, RelationshipArgument&gt;,
}</code></pre>
<h2 id="relationshipargument"><a class="header" href="#relationshipargument"><code>RelationshipArgument</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Relationship Argument")]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum RelationshipArgument {
    /// The argument is provided by reference to a variable.
    /// Only used if the 'query.variables' capability is supported.
    Variable {
        name: VariableName,
    },
    /// The argument is provided as a literal value
    Literal {
        value: serde_json::Value,
    },
    // The argument is provided based on a column of the source collection
    Column {
        name: FieldName,
    },
}</code></pre>
<h2 id="relationshipcapabilities"><a class="header" href="#relationshipcapabilities"><code>RelationshipCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Relationship Capabilities")]
pub struct RelationshipCapabilities {
    /// Does the connector support comparisons that involve related collections (ie. joins)?
    pub relation_comparisons: Option&lt;LeafCapability&gt;,
    /// Does the connector support ordering by an aggregated array relationship?
    pub order_by_aggregate: Option&lt;LeafCapability&gt;,
    /// Does the connector support navigating a relationship from inside a nested object
    pub nested: Option&lt;NestedRelationshipCapabilities&gt;,
}</code></pre>
<h2 id="relationshiptype"><a class="header" href="#relationshiptype"><code>RelationshipType</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[schemars(title = "Relationship Type")]
#[serde(rename_all = "snake_case")]
pub enum RelationshipType {
    Object,
    Array,
}</code></pre>
<h2 id="rowfieldvalue"><a class="header" href="#rowfieldvalue"><code>RowFieldValue</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Row Field Value")]
pub struct RowFieldValue(pub serde_json::Value);

impl RowFieldValue {
    /// In the case where this field value was obtained using a
    /// [`Field::Relationship`], the returned JSON will be a [`RowSet`].
    /// We cannot express [`RowFieldValue`] as an enum, because
    /// [`RowFieldValue`] overlaps with values which have object types.
    pub fn as_rowset(self) -&gt; Option&lt;RowSet&gt; {
        serde_json::from_value(self.0).ok()
    }
}</code></pre>
<h2 id="rowset"><a class="header" href="#rowset"><code>RowSet</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Row Set")]
pub struct RowSet {
    /// The results of the aggregates returned by the query
    pub aggregates: Option&lt;IndexMap&lt;FieldName, serde_json::Value&gt;&gt;,
    /// The rows returned by the query, corresponding to the query's fields
    pub rows: Option&lt;Vec&lt;IndexMap&lt;FieldName, RowFieldValue&gt;&gt;&gt;,
    /// The results of any grouping operation
    pub groups: Option&lt;Vec&lt;Group&gt;&gt;,
}</code></pre>
<h2 id="scalartype"><a class="header" href="#scalartype"><code>ScalarType</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of a scalar type, i.e. types that can be used as the types of columns.
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Scalar Type")]
pub struct ScalarType {
    /// A description of valid values for this scalar type.
    pub representation: TypeRepresentation,
    /// A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.
    pub aggregate_functions: BTreeMap&lt;AggregateFunctionName, AggregateFunctionDefinition&gt;,
    /// A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.
    pub comparison_operators: BTreeMap&lt;ComparisonOperatorName, ComparisonOperatorDefinition&gt;,
    /// A map from extraction function names to their definitions.
    #[serde(default)]
    pub extraction_functions: BTreeMap&lt;ExtractionFunctionName, ExtractionFunctionDefinition&gt;,
}</code></pre>
<h2 id="schemaresponse"><a class="header" href="#schemaresponse"><code>SchemaResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Schema Response")]
pub struct SchemaResponse {
    /// A list of scalar types which will be used as the types of collection columns
    pub scalar_types: BTreeMap&lt;ScalarTypeName, ScalarType&gt;,
    /// A list of object types which can be used as the types of arguments, or return types of procedures.
    /// Names should not overlap with scalar type names.
    pub object_types: BTreeMap&lt;ObjectTypeName, ObjectType&gt;,
    /// Collections which are available for queries
    pub collections: Vec&lt;CollectionInfo&gt;,
    /// Functions (i.e. collections which return a single column and row)
    pub functions: Vec&lt;FunctionInfo&gt;,
    /// Procedures which are available for execution as part of mutations
    pub procedures: Vec&lt;ProcedureInfo&gt;,
    /// Schema data which is relevant to features enabled by capabilities
    pub capabilities: Option&lt;CapabilitySchemaInfo&gt;,
    /// Request level arguments which are required for queries and mutations
    pub request_arguments: Option&lt;RequestLevelArguments&gt;,
}</code></pre>
<h2 id="collectioninfo"><a class="header" href="#collectioninfo"><code>CollectionInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Collection Info")]
pub struct CollectionInfo {
    /// The name of the collection
    ///
    /// Note: these names are abstract - there is no requirement that this name correspond to
    /// the name of an actual collection in the database.
    pub name: CollectionName,
    /// Description of the collection
    pub description: Option&lt;String&gt;,
    /// Any arguments that this collection requires
    pub arguments: BTreeMap&lt;ArgumentName, ArgumentInfo&gt;,
    /// The name of the collection's object type
    #[serde(rename = "type")]
    pub collection_type: ObjectTypeName,
    /// Any uniqueness constraints enforced on this collection
    pub uniqueness_constraints: BTreeMap&lt;String, UniquenessConstraint&gt;,
    /// Information about relational mutation capabilities for this collection
    pub relational_mutations: Option&lt;RelationalMutationInfo&gt;,
}</code></pre>
<h2 id="type"><a class="header" href="#type"><code>Type</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// Types track the valid representations of values as JSON
#[derive(
    Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Type")]
pub enum Type {
    /// A named type
    Named {
        /// The name can refer to a scalar or object type
        name: TypeName,
    },
    /// A nullable type
    Nullable {
        /// The type of the non-null inhabitants of this type
        underlying_type: Box&lt;Type&gt;,
    },
    /// An array type
    Array {
        /// The type of the elements of the array
        element_type: Box&lt;Type&gt;,
    },
    /// A predicate type for a given object type
    Predicate {
        /// The object type name
        object_type_name: ObjectTypeName,
    },
}</code></pre>
<h2 id="typerepresentation"><a class="header" href="#typerepresentation"><code>TypeRepresentation</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// Representations of scalar types
#[derive(
    Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(tag = "type", rename_all = "snake_case")]
#[schemars(title = "Type Representation")]
pub enum TypeRepresentation {
    /// JSON booleans
    Boolean,
    /// Any JSON string
    String,
    /// A 8-bit signed integer with a minimum value of -2^7 and a maximum value of 2^7 - 1
    Int8,
    /// A 16-bit signed integer with a minimum value of -2^15 and a maximum value of 2^15 - 1
    Int16,
    /// A 32-bit signed integer with a minimum value of -2^31 and a maximum value of 2^31 - 1
    Int32,
    /// A 64-bit signed integer with a minimum value of -2^63 and a maximum value of 2^63 - 1
    Int64,
    /// An IEEE-754 single-precision floating-point number
    Float32,
    /// An IEEE-754 double-precision floating-point number
    Float64,
    /// Arbitrary-precision integer string
    #[serde(rename = "biginteger")]
    BigInteger,
    /// Arbitrary-precision decimal string
    #[serde(rename = "bigdecimal")]
    BigDecimal,
    /// UUID string (8-4-4-4-12)
    #[serde(rename = "uuid")]
    UUID,
    /// ISO 8601 date
    Date,
    /// ISO 8601 timestamp
    Timestamp,
    /// ISO 8601 timestamp-with-timezone
    #[serde(rename = "timestamptz")]
    TimestampTZ,
    /// GeoJSON, per RFC 7946
    Geography,
    /// GeoJSON Geometry object, per RFC 7946
    Geometry,
    /// Base64-encoded bytes
    Bytes,
    /// Arbitrary JSON
    #[serde(rename = "json")]
    JSON,
    /// One of the specified string values
    Enum { one_of: Vec&lt;String&gt; },
}</code></pre>
<h2 id="unarycomparisonoperator"><a class="header" href="#unarycomparisonoperator"><code>UnaryComparisonOperator</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[schemars(title = "Unary Comparison Operator")]
#[serde(rename_all = "snake_case")]
pub enum UnaryComparisonOperator {
    IsNull,
}</code></pre>
<h2 id="uniquenessconstraint"><a class="header" href="#uniquenessconstraint"><code>UniquenessConstraint</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[schemars(title = "Uniqueness Constraint")]
pub struct UniquenessConstraint {
    /// A list of columns which this constraint requires to be unique
    pub unique_columns: Vec&lt;FieldName&gt;,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-schema"><a class="header" href="#json-schema">JSON Schema</a></h1>
<h2 id="capabilitiesresponse-1"><a class="header" href="#capabilitiesresponse-1"><code>CapabilitiesResponse</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Capabilities Response",
  "type": "object",
  "required": [
    "capabilities",
    "version"
  ],
  "properties": {
    "version": {
      "type": "string"
    },
    "capabilities": {
      "$ref": "#/definitions/Capabilities"
    }
  },
  "definitions": {
    "AggregateCapabilities": {
      "title": "Aggregate Capabilities",
      "type": "object",
      "properties": {
        "filter_by": {
          "description": "Does the connector support filtering based on aggregated values",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "group_by": {
          "description": "Does the connector support aggregations over groups",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupByCapabilities"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Capabilities": {
      "title": "Capabilities",
      "description": "Describes the features of the specification which a data connector implements.",
      "type": "object",
      "required": [
        "mutation",
        "query"
      ],
      "properties": {
        "query": {
          "$ref": "#/definitions/QueryCapabilities"
        },
        "mutation": {
          "$ref": "#/definitions/MutationCapabilities"
        },
        "relationships": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationshipCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "relational_query": {
          "description": "Does the connector support the relational query API? This feature is experimental and subject to breaking changes within minor versions.",
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalQueryCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "relational_mutation": {
          "description": "Does the connector support the relational mutation API? This feature is experimental and subject to breaking changes within minor versions.",
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalMutationCapabilities"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "DatePartScalarExpressionCapability": {
      "title": "Date Part Scalar Expression Capability",
      "type": "object",
      "properties": {
        "year": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "quarter": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "month": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "week": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "day_of_week": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "day_of_year": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "day": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "hour": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "minute": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "second": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "microsecond": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "millisecond": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nanosecond": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "epoch": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "ExistsCapabilities": {
      "title": "Exists Capabilities",
      "type": "object",
      "properties": {
        "named_scopes": {
          "description": "Does the connector support named scopes in column references inside EXISTS predicates",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "unrelated": {
          "description": "Does the connector support ExistsInCollection::Unrelated",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nested_collections": {
          "description": "Does the connector support ExistsInCollection::NestedCollection",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nested_scalar_collections": {
          "description": "Does the connector support filtering over nested scalar arrays using existential quantification. This means the connector must support ExistsInCollection::NestedScalarCollection.",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "GroupByCapabilities": {
      "title": "Group By Capabilities",
      "type": "object",
      "properties": {
        "filter": {
          "description": "Does the connector support post-grouping predicates",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "order": {
          "description": "Does the connector support post-grouping ordering",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "paginate": {
          "description": "Does the connector support post-grouping pagination",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "LeafCapability": {
      "description": "A unit value to indicate a particular leaf capability is supported. This is an empty struct to allow for future sub-capabilities.",
      "type": "object"
    },
    "MutationCapabilities": {
      "title": "Mutation Capabilities",
      "type": "object",
      "properties": {
        "transactional": {
          "description": "Does the connector support executing multiple mutations in a transaction.",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "explain": {
          "description": "Does the connector support explaining mutations",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NestedArrayFilterByCapabilities": {
      "title": "Nested Array Filter By Capabilities",
      "type": "object",
      "properties": {
        "contains": {
          "description": "Does the connector support filtering over nested arrays by checking if the array contains a value. This must be supported for all types that can be contained in an array that implement an 'eq' comparison operator.",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "is_empty": {
          "description": "Does the connector support filtering over nested arrays by checking if the array is empty. This must be supported no matter what type is contained in the array.",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NestedFieldCapabilities": {
      "title": "Nested Field Capabilities",
      "type": "object",
      "properties": {
        "filter_by": {
          "description": "Does the connector support filtering by values of nested fields",
          "anyOf": [
            {
              "$ref": "#/definitions/NestedFieldFilterByCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "order_by": {
          "description": "Does the connector support ordering by values of nested fields",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "aggregates": {
          "description": "Does the connector support aggregating values within nested fields",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nested_collections": {
          "description": "Does the connector support nested collection queries using `NestedField::NestedCollection`",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NestedFieldFilterByCapabilities": {
      "title": "Nested Field Filter By Capabilities",
      "type": "object",
      "properties": {
        "nested_arrays": {
          "description": "Does the connector support filtering over nested arrays (ie. Expression::ArrayComparison)",
          "anyOf": [
            {
              "$ref": "#/definitions/NestedArrayFilterByCapabilities"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "NestedRelationshipCapabilities": {
      "title": "Nested Relationship Capabilities",
      "type": "object",
      "properties": {
        "array": {
          "description": "Does the connector support navigating a relationship from inside a nested object inside a nested array",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "filtering": {
          "description": "Does the connector support filtering over a relationship that starts from inside a nested object",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "ordering": {
          "description": "Does the connector support ordering over a relationship that starts from inside a nested object",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "QueryCapabilities": {
      "title": "Query Capabilities",
      "type": "object",
      "properties": {
        "aggregates": {
          "description": "Does the connector support aggregate queries",
          "anyOf": [
            {
              "$ref": "#/definitions/AggregateCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "variables": {
          "description": "Does the connector support queries which use variables",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "explain": {
          "description": "Does the connector support explaining queries",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nested_fields": {
          "description": "Does the connector support nested fields",
          "default": {},
          "allOf": [
            {
              "$ref": "#/definitions/NestedFieldCapabilities"
            }
          ]
        },
        "exists": {
          "description": "Does the connector support EXISTS predicates",
          "default": {},
          "allOf": [
            {
              "$ref": "#/definitions/ExistsCapabilities"
            }
          ]
        }
      }
    },
    "RelationalAggregateCapabilities": {
      "title": "Relational Aggregate Capabilities",
      "type": "object",
      "required": [
        "expression"
      ],
      "properties": {
        "expression": {
          "$ref": "#/definitions/RelationalExpressionCapabilities"
        },
        "group_by": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalAggregateExpressionCapabilities": {
      "title": "Relational Aggregate Expression Capabilities",
      "type": "object",
      "properties": {
        "avg": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "bool_and": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "bool_or": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "count": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalAggregateFunctionCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "first_value": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "last_value": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "max": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "median": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "min": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "string_agg": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "sum": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "var": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "stddev": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "stddev_pop": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "approx_percentile_cont": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "array_agg": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "approx_distinct": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalAggregateFunctionCapabilities": {
      "title": "Relational Aggregate Function Capabilities",
      "type": "object",
      "properties": {
        "distinct": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalComparisonExpressionCapabilities": {
      "title": "Relational Filter Expression Capabilities",
      "type": "object",
      "properties": {
        "between": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "contains": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "greater_than_eq": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "greater_than": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "ilike": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "in_list": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "is_false": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "is_nan": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "is_null": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "is_true": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "is_zero": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "less_than_eq": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "less_than": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "like": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalConditionalExpressionCapabilities": {
      "title": "Relational Conditional Expression Capabilities",
      "type": "object",
      "properties": {
        "case": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nullif": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalExpressionCapabilities": {
      "title": "Relational Expression Capabilities",
      "type": "object",
      "required": [
        "aggregate",
        "comparison",
        "conditional",
        "scalar",
        "window"
      ],
      "properties": {
        "conditional": {
          "$ref": "#/definitions/RelationalConditionalExpressionCapabilities"
        },
        "comparison": {
          "$ref": "#/definitions/RelationalComparisonExpressionCapabilities"
        },
        "scalar": {
          "$ref": "#/definitions/RelationalScalarExpressionCapabilities"
        },
        "aggregate": {
          "$ref": "#/definitions/RelationalAggregateExpressionCapabilities"
        },
        "window": {
          "$ref": "#/definitions/RelationalWindowExpressionCapabilities"
        }
      }
    },
    "RelationalJoinCapabilities": {
      "title": "Relational Join Capabilities",
      "type": "object",
      "required": [
        "expression",
        "join_types"
      ],
      "properties": {
        "expression": {
          "$ref": "#/definitions/RelationalExpressionCapabilities"
        },
        "join_types": {
          "$ref": "#/definitions/RelationalJoinTypeCapabilities"
        }
      }
    },
    "RelationalJoinTypeCapabilities": {
      "title": "Relational Join Type Capabilities",
      "type": "object",
      "properties": {
        "left": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "right": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "inner": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "full": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "left_semi": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "left_anti": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "right_semi": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "right_anti": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalMutationCapabilities": {
      "title": "Relational Mutation Capabilities",
      "description": "Describes which features of the relational mutation API are supported by the connector. This feature is experimental and subject to breaking changes within minor versions.",
      "type": "object",
      "properties": {
        "insert": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "update": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "delete": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalProjectionCapabilities": {
      "title": "Relational Projection Capabilities",
      "type": "object",
      "required": [
        "expression"
      ],
      "properties": {
        "expression": {
          "$ref": "#/definitions/RelationalExpressionCapabilities"
        }
      }
    },
    "RelationalQueryCapabilities": {
      "title": "Relational Query Capabilities",
      "description": "Describes which features of the relational query API are supported by the connector. This feature is experimental and subject to breaking changes within minor versions.",
      "type": "object",
      "required": [
        "project"
      ],
      "properties": {
        "project": {
          "$ref": "#/definitions/RelationalProjectionCapabilities"
        },
        "filter": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalExpressionCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "sort": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalSortCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "join": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalJoinCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "aggregate": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalAggregateCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "window": {
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalWindowCapabilities"
            },
            {
              "type": "null"
            }
          ]
        },
        "union": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalScalarExpressionCapabilities": {
      "title": "Relational Scalar Expression Capabilities",
      "type": "object",
      "properties": {
        "abs": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "and": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "array_element": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "binary_concat": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "btrim": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "ceil": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "character_length": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "coalesce": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "concat": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "cos": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_date": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_time": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "current_timestamp": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "date_part": {
          "anyOf": [
            {
              "$ref": "#/definitions/DatePartScalarExpressionCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "date_trunc": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "divide": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "exp": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "floor": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "get_field": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "greatest": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "least": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "left": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "ln": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "log": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "log10": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "log2": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "lpad": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "ltrim": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "minus": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "modulo": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "multiply": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "negate": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "not": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nvl": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "or": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "plus": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "power": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "random": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "replace": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "reverse": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "right": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "round": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "rpad": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "rtrim": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "sqrt": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "str_pos": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "substr_index": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "substr": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "tan": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "to_date": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "to_lower": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "to_timestamp": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "to_upper": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "trunc": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalSortCapabilities": {
      "title": "Relational Sort Capabilities",
      "type": "object",
      "required": [
        "expression"
      ],
      "properties": {
        "expression": {
          "$ref": "#/definitions/RelationalExpressionCapabilities"
        }
      }
    },
    "RelationalWindowCapabilities": {
      "title": "Relational Window Capabilities",
      "type": "object",
      "required": [
        "expression"
      ],
      "properties": {
        "expression": {
          "$ref": "#/definitions/RelationalExpressionCapabilities"
        }
      }
    },
    "RelationalWindowExpressionCapabilities": {
      "title": "Relational Window Expression Capabilities",
      "type": "object",
      "properties": {
        "row_number": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "dense_rank": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "ntile": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "rank": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "cume_dist": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "percent_rank": {
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationshipCapabilities": {
      "title": "Relationship Capabilities",
      "type": "object",
      "properties": {
        "relation_comparisons": {
          "description": "Does the connector support comparisons that involve related collections (ie. joins)?",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "order_by_aggregate": {
          "description": "Does the connector support ordering by an aggregated array relationship?",
          "anyOf": [
            {
              "$ref": "#/definitions/LeafCapability"
            },
            {
              "type": "null"
            }
          ]
        },
        "nested": {
          "description": "Does the connector support navigating a relationship from inside a nested object",
          "anyOf": [
            {
              "$ref": "#/definitions/NestedRelationshipCapabilities"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    }
  }
}
</code></pre>
<h2 id="errorresponse-1"><a class="header" href="#errorresponse-1"><code>ErrorResponse</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Error Response",
  "type": "object",
  "required": [
    "details",
    "message"
  ],
  "properties": {
    "message": {
      "description": "A human-readable summary of the error",
      "type": "string"
    },
    "details": {
      "description": "Any additional structured information about the error"
    }
  }
}
</code></pre>
<h2 id="explainresponse-1"><a class="header" href="#explainresponse-1"><code>ExplainResponse</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Explain Response",
  "type": "object",
  "required": [
    "details"
  ],
  "properties": {
    "details": {
      "description": "A list of human-readable key-value pairs describing a query execution plan. For example, a connector for a relational database might return the generated SQL and/or the output of the `EXPLAIN` command. An API-based connector might encode a list of statically-known API calls which would be made.",
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    }
  }
}
</code></pre>
<h2 id="mutationrequest-1"><a class="header" href="#mutationrequest-1"><code>MutationRequest</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Mutation Request",
  "type": "object",
  "required": [
    "collection_relationships",
    "operations"
  ],
  "properties": {
    "operations": {
      "description": "The mutation operations to perform",
      "type": "array",
      "items": {
        "$ref": "#/definitions/MutationOperation"
      }
    },
    "collection_relationships": {
      "description": "The relationships between collections involved in the entire mutation request. Only used if the 'relationships' capability is supported.",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Relationship"
      }
    },
    "request_arguments": {
      "description": "Values to be provided to request-level arguments.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": true
    }
  },
  "definitions": {
    "Aggregate": {
      "title": "Aggregate",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column",
            "distinct",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column_count"
              ]
            },
            "column": {
              "description": "The column to apply the count aggregate function to",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "distinct": {
              "description": "Whether or not only distinct items should be counted",
              "type": "boolean"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "function",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "single_column"
              ]
            },
            "column": {
              "description": "The column to apply the aggregation function to",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "function": {
              "description": "Single column aggregate function name.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "star_count"
              ]
            }
          }
        }
      ]
    },
    "Argument": {
      "title": "Argument",
      "oneOf": [
        {
          "description": "The argument is provided by reference to a variable. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "description": "The argument is provided as a literal value",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "literal"
              ]
            },
            "value": true
          }
        }
      ]
    },
    "ArrayComparison": {
      "title": "Array Comparison",
      "oneOf": [
        {
          "description": "Check if the array contains the specified value. Only used if the 'query.nested_fields.filter_by.nested_arrays.contains' capability is supported.",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "contains"
              ]
            },
            "value": {
              "$ref": "#/definitions/ComparisonValue"
            }
          }
        },
        {
          "description": "Check is the array is empty. Only used if the 'query.nested_fields.filter_by.nested_arrays.is_empty' capability is supported.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "is_empty"
              ]
            }
          }
        }
      ]
    },
    "ComparisonTarget": {
      "title": "Comparison Target",
      "oneOf": [
        {
          "description": "The comparison targets a column.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "The comparison targets the result of aggregation. Only used if the 'query.aggregates.filter_by' capability is supported.",
          "type": "object",
          "required": [
            "aggregate",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "path": {
              "description": "Non-empty collection of relationships to traverse",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "aggregate": {
              "description": "The aggregation method to use",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "ComparisonValue": {
      "title": "Comparison Value",
      "oneOf": [
        {
          "description": "The value to compare against should be drawn from another column",
          "type": "object",
          "required": [
            "name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any relationships to traverse to reach this column. Only non-empty if the 'relationships.relation_comparisons' is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "scope": {
              "description": "The scope in which this column exists, identified by an top-down index into the stack of scopes. The stack grows inside each `Expression::Exists`, so scope 0 (the default) refers to the current collection, and each subsequent index refers to the collection outside its predecessor's immediately enclosing `Expression::Exists` expression. Only used if the 'query.exists.named_scopes' capability is supported.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "description": "A scalar value to compare against",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "scalar"
              ]
            },
            "value": true
          }
        },
        {
          "description": "A value to compare against that is to be drawn from the query's variables. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "Dimension": {
      "title": "Dimension",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column_name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "column_name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column_name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "extraction": {
              "description": "The name of the extraction function to apply to the selected value, if any",
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      ]
    },
    "ExistsInCollection": {
      "title": "Exists In Collection",
      "oneOf": [
        {
          "description": "The rows to evaluate the exists predicate against come from a related collection. Only used if the 'relationships' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "relationship",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "related"
              ]
            },
            "field_path": {
              "description": "Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested.filtering' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "relationship": {
              "description": "The name of the relationship to follow",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        },
        {
          "description": "The rows to evaluate the exists predicate against come from an unrelated collection Only used if the 'query.exists.unrelated' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "collection",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unrelated"
              ]
            },
            "collection": {
              "description": "The name of a collection",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        },
        {
          "description": "The rows to evaluate the exists predicate against come from a nested array field. Only used if the 'query.exists.nested_collections' capability is supported.",
          "type": "object",
          "required": [
            "column_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nested_collection"
              ]
            },
            "column_name": {
              "type": "string"
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested collection via object columns",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "Specifies a column that contains a nested array of scalars. The array will be brought into scope of the nested expression where each element becomes an object with one '__value' column that contains the element value. Only used if the 'query.exists.nested_scalar_collections' capability is supported.",
          "type": "object",
          "required": [
            "column_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nested_scalar_collection"
              ]
            },
            "column_name": {
              "type": "string"
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested collection via object columns",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      ]
    },
    "Expression": {
      "title": "Expression",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "and"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Expression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "or"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Expression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expression",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "not"
              ]
            },
            "expression": {
              "$ref": "#/definitions/Expression"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "operator",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unary_comparison_operator"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "operator": {
              "$ref": "#/definitions/UnaryComparisonOperator"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "operator",
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "binary_comparison_operator"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "operator": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/ComparisonValue"
            }
          }
        },
        {
          "description": "A comparison against a nested array column. Only used if the 'query.nested_fields.filter_by.nested_arrays' capability is supported.",
          "type": "object",
          "required": [
            "column",
            "comparison",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array_comparison"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "comparison": {
              "$ref": "#/definitions/ArrayComparison"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "in_collection",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "exists"
              ]
            },
            "in_collection": {
              "$ref": "#/definitions/ExistsInCollection"
            },
            "predicate": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Expression"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        }
      ]
    },
    "Field": {
      "title": "Field",
      "oneOf": [
        {
          "description": "A field satisfied by returning the value of a row's column.",
          "type": "object",
          "required": [
            "column",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "column": {
              "type": "string"
            },
            "fields": {
              "description": "When the type of the column is a (possibly-nullable) array or object, the caller can request a subset of the complete column data, by specifying fields to fetch here. If omitted, the column data will be fetched in full.",
              "anyOf": [
                {
                  "$ref": "#/definitions/NestedField"
                },
                {
                  "type": "null"
                }
              ]
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            }
          }
        },
        {
          "description": "A field satisfied by navigating a relationship from the current row to a related collection. Only used if the 'relationships' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "query",
            "relationship",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "relationship"
              ]
            },
            "query": {
              "$ref": "#/definitions/Query"
            },
            "relationship": {
              "description": "The name of the relationship to follow for the subquery",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        }
      ]
    },
    "GroupComparisonTarget": {
      "title": "Aggregate Comparison Target",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "aggregate",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "aggregate": {
              "$ref": "#/definitions/Aggregate"
            }
          }
        }
      ]
    },
    "GroupComparisonValue": {
      "title": "Aggregate Comparison Value",
      "oneOf": [
        {
          "description": "A scalar value to compare against",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "scalar"
              ]
            },
            "value": true
          }
        },
        {
          "description": "A value to compare against that is to be drawn from the query's variables. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "GroupExpression": {
      "title": "Group Expression",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "and"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/GroupExpression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "or"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/GroupExpression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expression",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "not"
              ]
            },
            "expression": {
              "$ref": "#/definitions/GroupExpression"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "operator",
            "target",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unary_comparison_operator"
              ]
            },
            "target": {
              "$ref": "#/definitions/GroupComparisonTarget"
            },
            "operator": {
              "$ref": "#/definitions/UnaryComparisonOperator"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "operator",
            "target",
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "binary_comparison_operator"
              ]
            },
            "target": {
              "$ref": "#/definitions/GroupComparisonTarget"
            },
            "operator": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/GroupComparisonValue"
            }
          }
        }
      ]
    },
    "GroupOrderBy": {
      "title": "Group Order By",
      "type": "object",
      "required": [
        "elements"
      ],
      "properties": {
        "elements": {
          "description": "The elements to order by, in priority order",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GroupOrderByElement"
          }
        }
      }
    },
    "GroupOrderByElement": {
      "title": "Group Order By Element",
      "type": "object",
      "required": [
        "order_direction",
        "target"
      ],
      "properties": {
        "order_direction": {
          "$ref": "#/definitions/OrderDirection"
        },
        "target": {
          "$ref": "#/definitions/GroupOrderByTarget"
        }
      }
    },
    "GroupOrderByTarget": {
      "title": "Group Order By Target",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "index",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "dimension"
              ]
            },
            "index": {
              "description": "The index of the dimension to order by, selected from the dimensions provided in the `Grouping` request.",
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "type": "object",
          "required": [
            "aggregate",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "aggregate": {
              "description": "Aggregation method to apply",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "Grouping": {
      "title": "Grouping",
      "type": "object",
      "required": [
        "aggregates",
        "dimensions"
      ],
      "properties": {
        "dimensions": {
          "description": "Dimensions along which to partition the data",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Dimension"
          }
        },
        "aggregates": {
          "description": "Aggregates to compute in each group",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Aggregate"
          }
        },
        "predicate": {
          "description": "Optionally specify a predicate to apply after grouping rows. Only used if the 'query.aggregates.group_by.filter' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupExpression"
            },
            {
              "type": "null"
            }
          ]
        },
        "order_by": {
          "description": "Optionally specify how groups should be ordered Only used if the 'query.aggregates.group_by.order' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupOrderBy"
            },
            {
              "type": "null"
            }
          ]
        },
        "limit": {
          "description": "Optionally limit to N groups Only used if the 'query.aggregates.group_by.paginate' capability is supported.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "offset": {
          "description": "Optionally offset from the Nth group Only used if the 'query.aggregates.group_by.paginate' capability is supported.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "MutationOperation": {
      "title": "Mutation Operation",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "arguments",
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "procedure"
              ]
            },
            "name": {
              "description": "The name of a procedure",
              "type": "string"
            },
            "arguments": {
              "description": "Any named procedure arguments",
              "type": "object",
              "additionalProperties": true
            },
            "fields": {
              "description": "The fields to return from the result, or null to return everything",
              "anyOf": [
                {
                  "$ref": "#/definitions/NestedField"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        }
      ]
    },
    "NestedField": {
      "title": "NestedField",
      "oneOf": [
        {
          "title": "NestedObject",
          "type": "object",
          "required": [
            "fields",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "object"
              ]
            },
            "fields": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Field"
              }
            }
          }
        },
        {
          "title": "NestedArray",
          "type": "object",
          "required": [
            "fields",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array"
              ]
            },
            "fields": {
              "$ref": "#/definitions/NestedField"
            }
          }
        },
        {
          "title": "NestedCollection",
          "description": "Perform a query over the nested array's rows. Only used if the 'query.nested_fields.nested_collections' capability is supported.",
          "type": "object",
          "required": [
            "query",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "collection"
              ]
            },
            "query": {
              "$ref": "#/definitions/Query"
            }
          }
        }
      ]
    },
    "OrderBy": {
      "title": "Order By",
      "type": "object",
      "required": [
        "elements"
      ],
      "properties": {
        "elements": {
          "description": "The elements to order by, in priority order",
          "type": "array",
          "items": {
            "$ref": "#/definitions/OrderByElement"
          }
        }
      }
    },
    "OrderByElement": {
      "title": "Order By Element",
      "type": "object",
      "required": [
        "order_direction",
        "target"
      ],
      "properties": {
        "order_direction": {
          "$ref": "#/definitions/OrderDirection"
        },
        "target": {
          "$ref": "#/definitions/OrderByTarget"
        }
      }
    },
    "OrderByTarget": {
      "title": "Order By Target",
      "oneOf": [
        {
          "description": "The ordering is performed over a column.",
          "type": "object",
          "required": [
            "name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported. 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.order_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "The ordering is performed over the result of an aggregation. Only used if the 'relationships.order_by_aggregate' capability is supported.",
          "type": "object",
          "required": [
            "aggregate",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "path": {
              "description": "Non-empty collection of relationships to traverse. Only non-empty if the 'relationships' capability is supported. 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "aggregate": {
              "description": "The aggregation method to use",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "OrderDirection": {
      "title": "Order Direction",
      "type": "string",
      "enum": [
        "asc",
        "desc"
      ]
    },
    "PathElement": {
      "title": "Path Element",
      "type": "object",
      "required": [
        "arguments",
        "relationship"
      ],
      "properties": {
        "field_path": {
          "description": "Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested' capability is supported (plus perhaps one of the sub-capabilities, depending on the feature using the PathElement).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "relationship": {
          "description": "The name of the relationship to follow",
          "type": "string"
        },
        "arguments": {
          "description": "Values to be provided to any collection arguments",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/RelationshipArgument"
          }
        },
        "predicate": {
          "description": "A predicate expression to apply to the target collection",
          "anyOf": [
            {
              "$ref": "#/definitions/Expression"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Query": {
      "title": "Query",
      "type": "object",
      "properties": {
        "aggregates": {
          "description": "Aggregate fields of the query. Only used if the 'query.aggregates' capability is supported.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/Aggregate"
          }
        },
        "fields": {
          "description": "Fields of the query",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/Field"
          }
        },
        "limit": {
          "description": "Optionally limit to N results",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "offset": {
          "description": "Optionally offset from the Nth result",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "order_by": {
          "description": "Optionally specify how rows should be ordered",
          "anyOf": [
            {
              "$ref": "#/definitions/OrderBy"
            },
            {
              "type": "null"
            }
          ]
        },
        "predicate": {
          "description": "Optionally specify a predicate to apply to the rows",
          "anyOf": [
            {
              "$ref": "#/definitions/Expression"
            },
            {
              "type": "null"
            }
          ]
        },
        "groups": {
          "description": "Optionally group and aggregate the selected rows. Only used if the 'query.aggregates.group_by' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/Grouping"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Relationship": {
      "title": "Relationship",
      "type": "object",
      "required": [
        "arguments",
        "column_mapping",
        "relationship_type",
        "target_collection"
      ],
      "properties": {
        "column_mapping": {
          "description": "A mapping between columns on the source row to columns on the target collection. The column on the target collection is specified via a field path (ie. an array of field names that descend through nested object fields). The field path will only contain a single item, meaning a column on the target collection's type, unless the 'relationships.nested' capability is supported, in which case multiple items denotes a nested object field.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "relationship_type": {
          "$ref": "#/definitions/RelationshipType"
        },
        "target_collection": {
          "description": "The name of a collection",
          "type": "string"
        },
        "arguments": {
          "description": "Values to be provided to any collection arguments",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/RelationshipArgument"
          }
        }
      }
    },
    "RelationshipArgument": {
      "title": "Relationship Argument",
      "oneOf": [
        {
          "description": "The argument is provided by reference to a variable. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "description": "The argument is provided as a literal value",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "literal"
              ]
            },
            "value": true
          }
        },
        {
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "RelationshipType": {
      "title": "Relationship Type",
      "type": "string",
      "enum": [
        "object",
        "array"
      ]
    },
    "UnaryComparisonOperator": {
      "title": "Unary Comparison Operator",
      "type": "string",
      "enum": [
        "is_null"
      ]
    }
  }
}
</code></pre>
<h2 id="mutationresponse-1"><a class="header" href="#mutationresponse-1"><code>MutationResponse</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Mutation Response",
  "type": "object",
  "required": [
    "operation_results"
  ],
  "properties": {
    "operation_results": {
      "description": "The results of each mutation operation, in the same order as they were received",
      "type": "array",
      "items": {
        "$ref": "#/definitions/MutationOperationResults"
      }
    }
  },
  "definitions": {
    "MutationOperationResults": {
      "title": "Mutation Operation Results",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "result",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "procedure"
              ]
            },
            "result": true
          }
        }
      ]
    }
  }
}
</code></pre>
<h2 id="queryrequest-1"><a class="header" href="#queryrequest-1"><code>QueryRequest</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Query Request",
  "description": "This is the request body of the query POST endpoint",
  "type": "object",
  "required": [
    "arguments",
    "collection",
    "collection_relationships",
    "query"
  ],
  "properties": {
    "collection": {
      "description": "The name of a collection",
      "type": "string"
    },
    "query": {
      "description": "The query syntax tree",
      "allOf": [
        {
          "$ref": "#/definitions/Query"
        }
      ]
    },
    "arguments": {
      "description": "Values to be provided to any collection arguments",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Argument"
      }
    },
    "collection_relationships": {
      "description": "Any relationships between collections involved in the query request. Only used if the 'relationships' capability is supported.",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Relationship"
      }
    },
    "variables": {
      "description": "One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned. Only used if the 'query.variables' capability is supported.",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "object",
        "additionalProperties": true
      }
    },
    "request_arguments": {
      "description": "Values to be provided to request-level arguments.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": true
    }
  },
  "definitions": {
    "Aggregate": {
      "title": "Aggregate",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column",
            "distinct",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column_count"
              ]
            },
            "column": {
              "description": "The column to apply the count aggregate function to",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "distinct": {
              "description": "Whether or not only distinct items should be counted",
              "type": "boolean"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "function",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "single_column"
              ]
            },
            "column": {
              "description": "The column to apply the aggregation function to",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "function": {
              "description": "Single column aggregate function name.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "star_count"
              ]
            }
          }
        }
      ]
    },
    "Argument": {
      "title": "Argument",
      "oneOf": [
        {
          "description": "The argument is provided by reference to a variable. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "description": "The argument is provided as a literal value",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "literal"
              ]
            },
            "value": true
          }
        }
      ]
    },
    "ArrayComparison": {
      "title": "Array Comparison",
      "oneOf": [
        {
          "description": "Check if the array contains the specified value. Only used if the 'query.nested_fields.filter_by.nested_arrays.contains' capability is supported.",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "contains"
              ]
            },
            "value": {
              "$ref": "#/definitions/ComparisonValue"
            }
          }
        },
        {
          "description": "Check is the array is empty. Only used if the 'query.nested_fields.filter_by.nested_arrays.is_empty' capability is supported.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "is_empty"
              ]
            }
          }
        }
      ]
    },
    "ComparisonTarget": {
      "title": "Comparison Target",
      "oneOf": [
        {
          "description": "The comparison targets a column.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "The comparison targets the result of aggregation. Only used if the 'query.aggregates.filter_by' capability is supported.",
          "type": "object",
          "required": [
            "aggregate",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "path": {
              "description": "Non-empty collection of relationships to traverse",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "aggregate": {
              "description": "The aggregation method to use",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "ComparisonValue": {
      "title": "Comparison Value",
      "oneOf": [
        {
          "description": "The value to compare against should be drawn from another column",
          "type": "object",
          "required": [
            "name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any relationships to traverse to reach this column. Only non-empty if the 'relationships.relation_comparisons' is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "scope": {
              "description": "The scope in which this column exists, identified by an top-down index into the stack of scopes. The stack grows inside each `Expression::Exists`, so scope 0 (the default) refers to the current collection, and each subsequent index refers to the collection outside its predecessor's immediately enclosing `Expression::Exists` expression. Only used if the 'query.exists.named_scopes' capability is supported.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "description": "A scalar value to compare against",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "scalar"
              ]
            },
            "value": true
          }
        },
        {
          "description": "A value to compare against that is to be drawn from the query's variables. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "Dimension": {
      "title": "Dimension",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column_name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "column_name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column_name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "extraction": {
              "description": "The name of the extraction function to apply to the selected value, if any",
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      ]
    },
    "ExistsInCollection": {
      "title": "Exists In Collection",
      "oneOf": [
        {
          "description": "The rows to evaluate the exists predicate against come from a related collection. Only used if the 'relationships' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "relationship",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "related"
              ]
            },
            "field_path": {
              "description": "Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested.filtering' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "relationship": {
              "description": "The name of the relationship to follow",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        },
        {
          "description": "The rows to evaluate the exists predicate against come from an unrelated collection Only used if the 'query.exists.unrelated' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "collection",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unrelated"
              ]
            },
            "collection": {
              "description": "The name of a collection",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        },
        {
          "description": "The rows to evaluate the exists predicate against come from a nested array field. Only used if the 'query.exists.nested_collections' capability is supported.",
          "type": "object",
          "required": [
            "column_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nested_collection"
              ]
            },
            "column_name": {
              "type": "string"
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested collection via object columns",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "Specifies a column that contains a nested array of scalars. The array will be brought into scope of the nested expression where each element becomes an object with one '__value' column that contains the element value. Only used if the 'query.exists.nested_scalar_collections' capability is supported.",
          "type": "object",
          "required": [
            "column_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nested_scalar_collection"
              ]
            },
            "column_name": {
              "type": "string"
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested collection via object columns",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      ]
    },
    "Expression": {
      "title": "Expression",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "and"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Expression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "or"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Expression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expression",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "not"
              ]
            },
            "expression": {
              "$ref": "#/definitions/Expression"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "operator",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unary_comparison_operator"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "operator": {
              "$ref": "#/definitions/UnaryComparisonOperator"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "operator",
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "binary_comparison_operator"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "operator": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/ComparisonValue"
            }
          }
        },
        {
          "description": "A comparison against a nested array column. Only used if the 'query.nested_fields.filter_by.nested_arrays' capability is supported.",
          "type": "object",
          "required": [
            "column",
            "comparison",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array_comparison"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "comparison": {
              "$ref": "#/definitions/ArrayComparison"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "in_collection",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "exists"
              ]
            },
            "in_collection": {
              "$ref": "#/definitions/ExistsInCollection"
            },
            "predicate": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Expression"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        }
      ]
    },
    "Field": {
      "title": "Field",
      "oneOf": [
        {
          "description": "A field satisfied by returning the value of a row's column.",
          "type": "object",
          "required": [
            "column",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "column": {
              "type": "string"
            },
            "fields": {
              "description": "When the type of the column is a (possibly-nullable) array or object, the caller can request a subset of the complete column data, by specifying fields to fetch here. If omitted, the column data will be fetched in full.",
              "anyOf": [
                {
                  "$ref": "#/definitions/NestedField"
                },
                {
                  "type": "null"
                }
              ]
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            }
          }
        },
        {
          "description": "A field satisfied by navigating a relationship from the current row to a related collection. Only used if the 'relationships' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "query",
            "relationship",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "relationship"
              ]
            },
            "query": {
              "$ref": "#/definitions/Query"
            },
            "relationship": {
              "description": "The name of the relationship to follow for the subquery",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        }
      ]
    },
    "GroupComparisonTarget": {
      "title": "Aggregate Comparison Target",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "aggregate",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "aggregate": {
              "$ref": "#/definitions/Aggregate"
            }
          }
        }
      ]
    },
    "GroupComparisonValue": {
      "title": "Aggregate Comparison Value",
      "oneOf": [
        {
          "description": "A scalar value to compare against",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "scalar"
              ]
            },
            "value": true
          }
        },
        {
          "description": "A value to compare against that is to be drawn from the query's variables. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "GroupExpression": {
      "title": "Group Expression",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "and"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/GroupExpression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "or"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/GroupExpression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expression",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "not"
              ]
            },
            "expression": {
              "$ref": "#/definitions/GroupExpression"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "operator",
            "target",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unary_comparison_operator"
              ]
            },
            "target": {
              "$ref": "#/definitions/GroupComparisonTarget"
            },
            "operator": {
              "$ref": "#/definitions/UnaryComparisonOperator"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "operator",
            "target",
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "binary_comparison_operator"
              ]
            },
            "target": {
              "$ref": "#/definitions/GroupComparisonTarget"
            },
            "operator": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/GroupComparisonValue"
            }
          }
        }
      ]
    },
    "GroupOrderBy": {
      "title": "Group Order By",
      "type": "object",
      "required": [
        "elements"
      ],
      "properties": {
        "elements": {
          "description": "The elements to order by, in priority order",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GroupOrderByElement"
          }
        }
      }
    },
    "GroupOrderByElement": {
      "title": "Group Order By Element",
      "type": "object",
      "required": [
        "order_direction",
        "target"
      ],
      "properties": {
        "order_direction": {
          "$ref": "#/definitions/OrderDirection"
        },
        "target": {
          "$ref": "#/definitions/GroupOrderByTarget"
        }
      }
    },
    "GroupOrderByTarget": {
      "title": "Group Order By Target",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "index",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "dimension"
              ]
            },
            "index": {
              "description": "The index of the dimension to order by, selected from the dimensions provided in the `Grouping` request.",
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "type": "object",
          "required": [
            "aggregate",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "aggregate": {
              "description": "Aggregation method to apply",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "Grouping": {
      "title": "Grouping",
      "type": "object",
      "required": [
        "aggregates",
        "dimensions"
      ],
      "properties": {
        "dimensions": {
          "description": "Dimensions along which to partition the data",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Dimension"
          }
        },
        "aggregates": {
          "description": "Aggregates to compute in each group",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Aggregate"
          }
        },
        "predicate": {
          "description": "Optionally specify a predicate to apply after grouping rows. Only used if the 'query.aggregates.group_by.filter' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupExpression"
            },
            {
              "type": "null"
            }
          ]
        },
        "order_by": {
          "description": "Optionally specify how groups should be ordered Only used if the 'query.aggregates.group_by.order' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupOrderBy"
            },
            {
              "type": "null"
            }
          ]
        },
        "limit": {
          "description": "Optionally limit to N groups Only used if the 'query.aggregates.group_by.paginate' capability is supported.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "offset": {
          "description": "Optionally offset from the Nth group Only used if the 'query.aggregates.group_by.paginate' capability is supported.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "NestedField": {
      "title": "NestedField",
      "oneOf": [
        {
          "title": "NestedObject",
          "type": "object",
          "required": [
            "fields",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "object"
              ]
            },
            "fields": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Field"
              }
            }
          }
        },
        {
          "title": "NestedArray",
          "type": "object",
          "required": [
            "fields",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array"
              ]
            },
            "fields": {
              "$ref": "#/definitions/NestedField"
            }
          }
        },
        {
          "title": "NestedCollection",
          "description": "Perform a query over the nested array's rows. Only used if the 'query.nested_fields.nested_collections' capability is supported.",
          "type": "object",
          "required": [
            "query",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "collection"
              ]
            },
            "query": {
              "$ref": "#/definitions/Query"
            }
          }
        }
      ]
    },
    "OrderBy": {
      "title": "Order By",
      "type": "object",
      "required": [
        "elements"
      ],
      "properties": {
        "elements": {
          "description": "The elements to order by, in priority order",
          "type": "array",
          "items": {
            "$ref": "#/definitions/OrderByElement"
          }
        }
      }
    },
    "OrderByElement": {
      "title": "Order By Element",
      "type": "object",
      "required": [
        "order_direction",
        "target"
      ],
      "properties": {
        "order_direction": {
          "$ref": "#/definitions/OrderDirection"
        },
        "target": {
          "$ref": "#/definitions/OrderByTarget"
        }
      }
    },
    "OrderByTarget": {
      "title": "Order By Target",
      "oneOf": [
        {
          "description": "The ordering is performed over a column.",
          "type": "object",
          "required": [
            "name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported. 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.order_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "The ordering is performed over the result of an aggregation. Only used if the 'relationships.order_by_aggregate' capability is supported.",
          "type": "object",
          "required": [
            "aggregate",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "path": {
              "description": "Non-empty collection of relationships to traverse. Only non-empty if the 'relationships' capability is supported. 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "aggregate": {
              "description": "The aggregation method to use",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "OrderDirection": {
      "title": "Order Direction",
      "type": "string",
      "enum": [
        "asc",
        "desc"
      ]
    },
    "PathElement": {
      "title": "Path Element",
      "type": "object",
      "required": [
        "arguments",
        "relationship"
      ],
      "properties": {
        "field_path": {
          "description": "Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested' capability is supported (plus perhaps one of the sub-capabilities, depending on the feature using the PathElement).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "relationship": {
          "description": "The name of the relationship to follow",
          "type": "string"
        },
        "arguments": {
          "description": "Values to be provided to any collection arguments",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/RelationshipArgument"
          }
        },
        "predicate": {
          "description": "A predicate expression to apply to the target collection",
          "anyOf": [
            {
              "$ref": "#/definitions/Expression"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Query": {
      "title": "Query",
      "type": "object",
      "properties": {
        "aggregates": {
          "description": "Aggregate fields of the query. Only used if the 'query.aggregates' capability is supported.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/Aggregate"
          }
        },
        "fields": {
          "description": "Fields of the query",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/Field"
          }
        },
        "limit": {
          "description": "Optionally limit to N results",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "offset": {
          "description": "Optionally offset from the Nth result",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "order_by": {
          "description": "Optionally specify how rows should be ordered",
          "anyOf": [
            {
              "$ref": "#/definitions/OrderBy"
            },
            {
              "type": "null"
            }
          ]
        },
        "predicate": {
          "description": "Optionally specify a predicate to apply to the rows",
          "anyOf": [
            {
              "$ref": "#/definitions/Expression"
            },
            {
              "type": "null"
            }
          ]
        },
        "groups": {
          "description": "Optionally group and aggregate the selected rows. Only used if the 'query.aggregates.group_by' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/Grouping"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Relationship": {
      "title": "Relationship",
      "type": "object",
      "required": [
        "arguments",
        "column_mapping",
        "relationship_type",
        "target_collection"
      ],
      "properties": {
        "column_mapping": {
          "description": "A mapping between columns on the source row to columns on the target collection. The column on the target collection is specified via a field path (ie. an array of field names that descend through nested object fields). The field path will only contain a single item, meaning a column on the target collection's type, unless the 'relationships.nested' capability is supported, in which case multiple items denotes a nested object field.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "relationship_type": {
          "$ref": "#/definitions/RelationshipType"
        },
        "target_collection": {
          "description": "The name of a collection",
          "type": "string"
        },
        "arguments": {
          "description": "Values to be provided to any collection arguments",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/RelationshipArgument"
          }
        }
      }
    },
    "RelationshipArgument": {
      "title": "Relationship Argument",
      "oneOf": [
        {
          "description": "The argument is provided by reference to a variable. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "description": "The argument is provided as a literal value",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "literal"
              ]
            },
            "value": true
          }
        },
        {
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "RelationshipType": {
      "title": "Relationship Type",
      "type": "string",
      "enum": [
        "object",
        "array"
      ]
    },
    "UnaryComparisonOperator": {
      "title": "Unary Comparison Operator",
      "type": "string",
      "enum": [
        "is_null"
      ]
    }
  }
}
</code></pre>
<h2 id="queryresponse-1"><a class="header" href="#queryresponse-1"><code>QueryResponse</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Query Response",
  "description": "Query responses may return multiple RowSets when using queries with variables. Else, there should always be exactly one RowSet",
  "type": "array",
  "items": {
    "$ref": "#/definitions/RowSet"
  },
  "definitions": {
    "Group": {
      "title": "Group",
      "type": "object",
      "required": [
        "aggregates",
        "dimensions"
      ],
      "properties": {
        "dimensions": {
          "description": "Values of dimensions which identify this group",
          "type": "array",
          "items": true
        },
        "aggregates": {
          "description": "Aggregates computed within this group",
          "type": "object",
          "additionalProperties": true
        }
      }
    },
    "RowFieldValue": {
      "title": "Row Field Value"
    },
    "RowSet": {
      "title": "Row Set",
      "type": "object",
      "properties": {
        "aggregates": {
          "description": "The results of the aggregates returned by the query",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": true
        },
        "rows": {
          "description": "The rows returned by the query, corresponding to the query's fields",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/definitions/RowFieldValue"
            }
          }
        },
        "groups": {
          "description": "The results of any grouping operation",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/Group"
          }
        }
      }
    }
  }
}
</code></pre>
<h2 id="queryrequest-2"><a class="header" href="#queryrequest-2"><code>QueryRequest</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Query Request",
  "description": "This is the request body of the query POST endpoint",
  "type": "object",
  "required": [
    "arguments",
    "collection",
    "collection_relationships",
    "query"
  ],
  "properties": {
    "collection": {
      "description": "The name of a collection",
      "type": "string"
    },
    "query": {
      "description": "The query syntax tree",
      "allOf": [
        {
          "$ref": "#/definitions/Query"
        }
      ]
    },
    "arguments": {
      "description": "Values to be provided to any collection arguments",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Argument"
      }
    },
    "collection_relationships": {
      "description": "Any relationships between collections involved in the query request. Only used if the 'relationships' capability is supported.",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/Relationship"
      }
    },
    "variables": {
      "description": "One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned. Only used if the 'query.variables' capability is supported.",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "type": "object",
        "additionalProperties": true
      }
    },
    "request_arguments": {
      "description": "Values to be provided to request-level arguments.",
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": true
    }
  },
  "definitions": {
    "Aggregate": {
      "title": "Aggregate",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column",
            "distinct",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column_count"
              ]
            },
            "column": {
              "description": "The column to apply the count aggregate function to",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "distinct": {
              "description": "Whether or not only distinct items should be counted",
              "type": "boolean"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "function",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "single_column"
              ]
            },
            "column": {
              "description": "The column to apply the aggregation function to",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "function": {
              "description": "Single column aggregate function name.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "star_count"
              ]
            }
          }
        }
      ]
    },
    "Argument": {
      "title": "Argument",
      "oneOf": [
        {
          "description": "The argument is provided by reference to a variable. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "description": "The argument is provided as a literal value",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "literal"
              ]
            },
            "value": true
          }
        }
      ]
    },
    "ArrayComparison": {
      "title": "Array Comparison",
      "oneOf": [
        {
          "description": "Check if the array contains the specified value. Only used if the 'query.nested_fields.filter_by.nested_arrays.contains' capability is supported.",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "contains"
              ]
            },
            "value": {
              "$ref": "#/definitions/ComparisonValue"
            }
          }
        },
        {
          "description": "Check is the array is empty. Only used if the 'query.nested_fields.filter_by.nested_arrays.is_empty' capability is supported.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "is_empty"
              ]
            }
          }
        }
      ]
    },
    "ComparisonTarget": {
      "title": "Comparison Target",
      "oneOf": [
        {
          "description": "The comparison targets a column.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "The comparison targets the result of aggregation. Only used if the 'query.aggregates.filter_by' capability is supported.",
          "type": "object",
          "required": [
            "aggregate",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "path": {
              "description": "Non-empty collection of relationships to traverse",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "aggregate": {
              "description": "The aggregation method to use",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "ComparisonValue": {
      "title": "Comparison Value",
      "oneOf": [
        {
          "description": "The value to compare against should be drawn from another column",
          "type": "object",
          "required": [
            "name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any relationships to traverse to reach this column. Only non-empty if the 'relationships.relation_comparisons' is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.filter_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "scope": {
              "description": "The scope in which this column exists, identified by an top-down index into the stack of scopes. The stack grows inside each `Expression::Exists`, so scope 0 (the default) refers to the current collection, and each subsequent index refers to the collection outside its predecessor's immediately enclosing `Expression::Exists` expression. Only used if the 'query.exists.named_scopes' capability is supported.",
              "type": [
                "integer",
                "null"
              ],
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "description": "A scalar value to compare against",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "scalar"
              ]
            },
            "value": true
          }
        },
        {
          "description": "A value to compare against that is to be drawn from the query's variables. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "Dimension": {
      "title": "Dimension",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "column_name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "column_name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'column_name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "extraction": {
              "description": "The name of the extraction function to apply to the selected value, if any",
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      ]
    },
    "ExistsInCollection": {
      "title": "Exists In Collection",
      "oneOf": [
        {
          "description": "The rows to evaluate the exists predicate against come from a related collection. Only used if the 'relationships' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "relationship",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "related"
              ]
            },
            "field_path": {
              "description": "Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested.filtering' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            },
            "relationship": {
              "description": "The name of the relationship to follow",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        },
        {
          "description": "The rows to evaluate the exists predicate against come from an unrelated collection Only used if the 'query.exists.unrelated' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "collection",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unrelated"
              ]
            },
            "collection": {
              "description": "The name of a collection",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        },
        {
          "description": "The rows to evaluate the exists predicate against come from a nested array field. Only used if the 'query.exists.nested_collections' capability is supported.",
          "type": "object",
          "required": [
            "column_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nested_collection"
              ]
            },
            "column_name": {
              "type": "string"
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested collection via object columns",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "Specifies a column that contains a nested array of scalars. The array will be brought into scope of the nested expression where each element becomes an object with one '__value' column that contains the element value. Only used if the 'query.exists.nested_scalar_collections' capability is supported.",
          "type": "object",
          "required": [
            "column_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nested_scalar_collection"
              ]
            },
            "column_name": {
              "type": "string"
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested collection via object columns",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      ]
    },
    "Expression": {
      "title": "Expression",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "and"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Expression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "or"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Expression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expression",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "not"
              ]
            },
            "expression": {
              "$ref": "#/definitions/Expression"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "operator",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unary_comparison_operator"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "operator": {
              "$ref": "#/definitions/UnaryComparisonOperator"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "column",
            "operator",
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "binary_comparison_operator"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "operator": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/ComparisonValue"
            }
          }
        },
        {
          "description": "A comparison against a nested array column. Only used if the 'query.nested_fields.filter_by.nested_arrays' capability is supported.",
          "type": "object",
          "required": [
            "column",
            "comparison",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array_comparison"
              ]
            },
            "column": {
              "$ref": "#/definitions/ComparisonTarget"
            },
            "comparison": {
              "$ref": "#/definitions/ArrayComparison"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "in_collection",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "exists"
              ]
            },
            "in_collection": {
              "$ref": "#/definitions/ExistsInCollection"
            },
            "predicate": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Expression"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        }
      ]
    },
    "Field": {
      "title": "Field",
      "oneOf": [
        {
          "description": "A field satisfied by returning the value of a row's column.",
          "type": "object",
          "required": [
            "column",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "column": {
              "type": "string"
            },
            "fields": {
              "description": "When the type of the column is a (possibly-nullable) array or object, the caller can request a subset of the complete column data, by specifying fields to fetch here. If omitted, the column data will be fetched in full.",
              "anyOf": [
                {
                  "$ref": "#/definitions/NestedField"
                },
                {
                  "type": "null"
                }
              ]
            },
            "arguments": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            }
          }
        },
        {
          "description": "A field satisfied by navigating a relationship from the current row to a related collection. Only used if the 'relationships' capability is supported.",
          "type": "object",
          "required": [
            "arguments",
            "query",
            "relationship",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "relationship"
              ]
            },
            "query": {
              "$ref": "#/definitions/Query"
            },
            "relationship": {
              "description": "The name of the relationship to follow for the subquery",
              "type": "string"
            },
            "arguments": {
              "description": "Values to be provided to any collection arguments",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/RelationshipArgument"
              }
            }
          }
        }
      ]
    },
    "GroupComparisonTarget": {
      "title": "Aggregate Comparison Target",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "aggregate",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "aggregate": {
              "$ref": "#/definitions/Aggregate"
            }
          }
        }
      ]
    },
    "GroupComparisonValue": {
      "title": "Aggregate Comparison Value",
      "oneOf": [
        {
          "description": "A scalar value to compare against",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "scalar"
              ]
            },
            "value": true
          }
        },
        {
          "description": "A value to compare against that is to be drawn from the query's variables. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "GroupExpression": {
      "title": "Group Expression",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "and"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/GroupExpression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expressions",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "or"
              ]
            },
            "expressions": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/GroupExpression"
              }
            }
          }
        },
        {
          "type": "object",
          "required": [
            "expression",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "not"
              ]
            },
            "expression": {
              "$ref": "#/definitions/GroupExpression"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "operator",
            "target",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "unary_comparison_operator"
              ]
            },
            "target": {
              "$ref": "#/definitions/GroupComparisonTarget"
            },
            "operator": {
              "$ref": "#/definitions/UnaryComparisonOperator"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "operator",
            "target",
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "binary_comparison_operator"
              ]
            },
            "target": {
              "$ref": "#/definitions/GroupComparisonTarget"
            },
            "operator": {
              "type": "string"
            },
            "value": {
              "$ref": "#/definitions/GroupComparisonValue"
            }
          }
        }
      ]
    },
    "GroupOrderBy": {
      "title": "Group Order By",
      "type": "object",
      "required": [
        "elements"
      ],
      "properties": {
        "elements": {
          "description": "The elements to order by, in priority order",
          "type": "array",
          "items": {
            "$ref": "#/definitions/GroupOrderByElement"
          }
        }
      }
    },
    "GroupOrderByElement": {
      "title": "Group Order By Element",
      "type": "object",
      "required": [
        "order_direction",
        "target"
      ],
      "properties": {
        "order_direction": {
          "$ref": "#/definitions/OrderDirection"
        },
        "target": {
          "$ref": "#/definitions/GroupOrderByTarget"
        }
      }
    },
    "GroupOrderByTarget": {
      "title": "Group Order By Target",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "index",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "dimension"
              ]
            },
            "index": {
              "description": "The index of the dimension to order by, selected from the dimensions provided in the `Grouping` request.",
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "type": "object",
          "required": [
            "aggregate",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "aggregate": {
              "description": "Aggregation method to apply",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "Grouping": {
      "title": "Grouping",
      "type": "object",
      "required": [
        "aggregates",
        "dimensions"
      ],
      "properties": {
        "dimensions": {
          "description": "Dimensions along which to partition the data",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Dimension"
          }
        },
        "aggregates": {
          "description": "Aggregates to compute in each group",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/Aggregate"
          }
        },
        "predicate": {
          "description": "Optionally specify a predicate to apply after grouping rows. Only used if the 'query.aggregates.group_by.filter' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupExpression"
            },
            {
              "type": "null"
            }
          ]
        },
        "order_by": {
          "description": "Optionally specify how groups should be ordered Only used if the 'query.aggregates.group_by.order' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/GroupOrderBy"
            },
            {
              "type": "null"
            }
          ]
        },
        "limit": {
          "description": "Optionally limit to N groups Only used if the 'query.aggregates.group_by.paginate' capability is supported.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "offset": {
          "description": "Optionally offset from the Nth group Only used if the 'query.aggregates.group_by.paginate' capability is supported.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        }
      }
    },
    "NestedField": {
      "title": "NestedField",
      "oneOf": [
        {
          "title": "NestedObject",
          "type": "object",
          "required": [
            "fields",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "object"
              ]
            },
            "fields": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Field"
              }
            }
          }
        },
        {
          "title": "NestedArray",
          "type": "object",
          "required": [
            "fields",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array"
              ]
            },
            "fields": {
              "$ref": "#/definitions/NestedField"
            }
          }
        },
        {
          "title": "NestedCollection",
          "description": "Perform a query over the nested array's rows. Only used if the 'query.nested_fields.nested_collections' capability is supported.",
          "type": "object",
          "required": [
            "query",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "collection"
              ]
            },
            "query": {
              "$ref": "#/definitions/Query"
            }
          }
        }
      ]
    },
    "OrderBy": {
      "title": "Order By",
      "type": "object",
      "required": [
        "elements"
      ],
      "properties": {
        "elements": {
          "description": "The elements to order by, in priority order",
          "type": "array",
          "items": {
            "$ref": "#/definitions/OrderByElement"
          }
        }
      }
    },
    "OrderByElement": {
      "title": "Order By Element",
      "type": "object",
      "required": [
        "order_direction",
        "target"
      ],
      "properties": {
        "order_direction": {
          "$ref": "#/definitions/OrderDirection"
        },
        "target": {
          "$ref": "#/definitions/OrderByTarget"
        }
      }
    },
    "OrderByTarget": {
      "title": "Order By Target",
      "oneOf": [
        {
          "description": "The ordering is performed over a column.",
          "type": "object",
          "required": [
            "name",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "path": {
              "description": "Any (object) relationships to traverse to reach this column. Only non-empty if the 'relationships' capability is supported. 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "name": {
              "description": "The name of the column",
              "type": "string"
            },
            "arguments": {
              "description": "Arguments to satisfy the column specified by 'name'",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Argument"
              }
            },
            "field_path": {
              "description": "Path to a nested field within an object column. Only non-empty if the 'query.nested_fields.order_by' capability is supported.",
              "type": [
                "array",
                "null"
              ],
              "items": {
                "type": "string"
              }
            }
          }
        },
        {
          "description": "The ordering is performed over the result of an aggregation. Only used if the 'relationships.order_by_aggregate' capability is supported.",
          "type": "object",
          "required": [
            "aggregate",
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "aggregate"
              ]
            },
            "path": {
              "description": "Non-empty collection of relationships to traverse. Only non-empty if the 'relationships' capability is supported. 'PathElement.field_path' will only be non-empty if the 'relationships.nested.ordering' capability is supported.",
              "type": "array",
              "items": {
                "$ref": "#/definitions/PathElement"
              }
            },
            "aggregate": {
              "description": "The aggregation method to use",
              "allOf": [
                {
                  "$ref": "#/definitions/Aggregate"
                }
              ]
            }
          }
        }
      ]
    },
    "OrderDirection": {
      "title": "Order Direction",
      "type": "string",
      "enum": [
        "asc",
        "desc"
      ]
    },
    "PathElement": {
      "title": "Path Element",
      "type": "object",
      "required": [
        "arguments",
        "relationship"
      ],
      "properties": {
        "field_path": {
          "description": "Path to a nested field within an object column that must be navigated before the relationship is navigated. Only non-empty if the 'relationships.nested' capability is supported (plus perhaps one of the sub-capabilities, depending on the feature using the PathElement).",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "relationship": {
          "description": "The name of the relationship to follow",
          "type": "string"
        },
        "arguments": {
          "description": "Values to be provided to any collection arguments",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/RelationshipArgument"
          }
        },
        "predicate": {
          "description": "A predicate expression to apply to the target collection",
          "anyOf": [
            {
              "$ref": "#/definitions/Expression"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Query": {
      "title": "Query",
      "type": "object",
      "properties": {
        "aggregates": {
          "description": "Aggregate fields of the query. Only used if the 'query.aggregates' capability is supported.",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/Aggregate"
          }
        },
        "fields": {
          "description": "Fields of the query",
          "type": [
            "object",
            "null"
          ],
          "additionalProperties": {
            "$ref": "#/definitions/Field"
          }
        },
        "limit": {
          "description": "Optionally limit to N results",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "offset": {
          "description": "Optionally offset from the Nth result",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "order_by": {
          "description": "Optionally specify how rows should be ordered",
          "anyOf": [
            {
              "$ref": "#/definitions/OrderBy"
            },
            {
              "type": "null"
            }
          ]
        },
        "predicate": {
          "description": "Optionally specify a predicate to apply to the rows",
          "anyOf": [
            {
              "$ref": "#/definitions/Expression"
            },
            {
              "type": "null"
            }
          ]
        },
        "groups": {
          "description": "Optionally group and aggregate the selected rows. Only used if the 'query.aggregates.group_by' capability is supported.",
          "anyOf": [
            {
              "$ref": "#/definitions/Grouping"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Relationship": {
      "title": "Relationship",
      "type": "object",
      "required": [
        "arguments",
        "column_mapping",
        "relationship_type",
        "target_collection"
      ],
      "properties": {
        "column_mapping": {
          "description": "A mapping between columns on the source row to columns on the target collection. The column on the target collection is specified via a field path (ie. an array of field names that descend through nested object fields). The field path will only contain a single item, meaning a column on the target collection's type, unless the 'relationships.nested' capability is supported, in which case multiple items denotes a nested object field.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "relationship_type": {
          "$ref": "#/definitions/RelationshipType"
        },
        "target_collection": {
          "description": "The name of a collection",
          "type": "string"
        },
        "arguments": {
          "description": "Values to be provided to any collection arguments",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/RelationshipArgument"
          }
        }
      }
    },
    "RelationshipArgument": {
      "title": "Relationship Argument",
      "oneOf": [
        {
          "description": "The argument is provided by reference to a variable. Only used if the 'query.variables' capability is supported.",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "variable"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "description": "The argument is provided as a literal value",
          "type": "object",
          "required": [
            "type",
            "value"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "literal"
              ]
            },
            "value": true
          }
        },
        {
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "column"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "RelationshipType": {
      "title": "Relationship Type",
      "type": "string",
      "enum": [
        "object",
        "array"
      ]
    },
    "UnaryComparisonOperator": {
      "title": "Unary Comparison Operator",
      "type": "string",
      "enum": [
        "is_null"
      ]
    }
  }
}
</code></pre>
<h2 id="schemaresponse-1"><a class="header" href="#schemaresponse-1"><code>SchemaResponse</code></a></h2>
<pre><code class="language-json">{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Schema Response",
  "type": "object",
  "required": [
    "collections",
    "functions",
    "object_types",
    "procedures",
    "scalar_types"
  ],
  "properties": {
    "scalar_types": {
      "description": "A list of scalar types which will be used as the types of collection columns",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/ScalarType"
      }
    },
    "object_types": {
      "description": "A list of object types which can be used as the types of arguments, or return types of procedures. Names should not overlap with scalar type names.",
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/ObjectType"
      }
    },
    "collections": {
      "description": "Collections which are available for queries",
      "type": "array",
      "items": {
        "$ref": "#/definitions/CollectionInfo"
      }
    },
    "functions": {
      "description": "Functions (i.e. collections which return a single column and row)",
      "type": "array",
      "items": {
        "$ref": "#/definitions/FunctionInfo"
      }
    },
    "procedures": {
      "description": "Procedures which are available for execution as part of mutations",
      "type": "array",
      "items": {
        "$ref": "#/definitions/ProcedureInfo"
      }
    },
    "capabilities": {
      "description": "Schema data which is relevant to features enabled by capabilities",
      "anyOf": [
        {
          "$ref": "#/definitions/CapabilitySchemaInfo"
        },
        {
          "type": "null"
        }
      ]
    },
    "request_arguments": {
      "description": "Request level arguments which are required for queries and mutations",
      "anyOf": [
        {
          "$ref": "#/definitions/RequestLevelArguments"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "definitions": {
    "AggregateCapabilitiesSchemaInfo": {
      "title": "Aggregate Capabilities Schema Info",
      "type": "object",
      "required": [
        "count_scalar_type"
      ],
      "properties": {
        "count_scalar_type": {
          "description": "The scalar type which should be used for the return type of count (star_count and column_count) operations.",
          "type": "string"
        }
      }
    },
    "AggregateFunctionDefinition": {
      "title": "Aggregate Function Definition",
      "description": "The definition of an aggregation function on a scalar type",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "min"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "max"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "sum"
              ]
            },
            "result_type": {
              "description": "The scalar type of the result of this function, which should have one of the type representations Int64 or Float64, depending on whether this function is defined on a scalar type with an integer or floating-point representation, respectively.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "average"
              ]
            },
            "result_type": {
              "description": "The scalar type of the result of this function, which should have the type representation Float64",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "custom"
              ]
            },
            "result_type": {
              "description": "The scalar or object type of the result of this function",
              "allOf": [
                {
                  "$ref": "#/definitions/Type"
                }
              ]
            }
          }
        }
      ]
    },
    "ArgumentInfo": {
      "title": "Argument Info",
      "type": "object",
      "required": [
        "type"
      ],
      "properties": {
        "description": {
          "description": "Argument description",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The name of the type of this argument",
          "allOf": [
            {
              "$ref": "#/definitions/Type"
            }
          ]
        }
      }
    },
    "CapabilitySchemaInfo": {
      "title": "Capability Schema Info",
      "type": "object",
      "properties": {
        "query": {
          "description": "Schema information relevant to query capabilities",
          "anyOf": [
            {
              "$ref": "#/definitions/QueryCapabilitiesSchemaInfo"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "CollectionInfo": {
      "title": "Collection Info",
      "type": "object",
      "required": [
        "arguments",
        "name",
        "type",
        "uniqueness_constraints"
      ],
      "properties": {
        "name": {
          "description": "The name of the collection\n\nNote: these names are abstract - there is no requirement that this name correspond to the name of an actual collection in the database.",
          "type": "string"
        },
        "description": {
          "description": "Description of the collection",
          "type": [
            "string",
            "null"
          ]
        },
        "arguments": {
          "description": "Any arguments that this collection requires",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        },
        "type": {
          "description": "The name of the collection's object type",
          "type": "string"
        },
        "uniqueness_constraints": {
          "description": "Any uniqueness constraints enforced on this collection",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/UniquenessConstraint"
          }
        },
        "relational_mutations": {
          "description": "Information about relational mutation capabilities for this collection",
          "anyOf": [
            {
              "$ref": "#/definitions/RelationalMutationInfo"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "ComparisonOperatorDefinition": {
      "title": "Comparison Operator Definition",
      "description": "The definition of a comparison operator on a scalar type",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "equal"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "in"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "less_than"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "less_than_or_equal"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "greater_than"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "greater_than_or_equal"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "contains"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "contains_insensitive"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "starts_with"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "starts_with_insensitive"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ends_with"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "ends_with_insensitive"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "argument_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "custom"
              ]
            },
            "argument_type": {
              "description": "The type of the argument to this operator",
              "allOf": [
                {
                  "$ref": "#/definitions/Type"
                }
              ]
            }
          }
        }
      ]
    },
    "ExtractionFunctionDefinition": {
      "title": "Extraction Function Definition",
      "description": "The definition of an aggregation function on a scalar type",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nanosecond"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "microsecond"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "millisecond"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "second"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "minute"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "hour"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "day"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "week"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "month"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "quarter"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "year"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "day_of_week"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "day_of_year"
              ]
            },
            "result_type": {
              "description": "The result type, which must be a defined scalar type in the schema response.",
              "type": "string"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "result_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "custom"
              ]
            },
            "result_type": {
              "description": "The scalar or object type of the result of this function",
              "allOf": [
                {
                  "$ref": "#/definitions/Type"
                }
              ]
            }
          }
        }
      ]
    },
    "ForeignKeyConstraint": {
      "title": "Foreign Key Constraint",
      "type": "object",
      "required": [
        "column_mapping",
        "foreign_collection"
      ],
      "properties": {
        "column_mapping": {
          "description": "The columns on which you want want to define the foreign key. This is a mapping between fields on object type to columns on the foreign collection. The column on the foreign collection is specified via a field path (ie. an array of field names that descend through nested object fields). The field path must only contain a single item, meaning a column on the foreign collection's type, unless the 'relationships.nested' capability is supported, in which case multiple items can be used to denote a nested object field.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "foreign_collection": {
          "description": "The name of a collection",
          "type": "string"
        }
      }
    },
    "FunctionInfo": {
      "title": "Function Info",
      "type": "object",
      "required": [
        "arguments",
        "name",
        "result_type"
      ],
      "properties": {
        "name": {
          "description": "The name of the function",
          "type": "string"
        },
        "description": {
          "description": "Description of the function",
          "type": [
            "string",
            "null"
          ]
        },
        "arguments": {
          "description": "Any arguments that this collection requires",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        },
        "result_type": {
          "description": "The name of the function's result type",
          "allOf": [
            {
              "$ref": "#/definitions/Type"
            }
          ]
        }
      }
    },
    "ObjectField": {
      "title": "Object Field",
      "description": "The definition of an object field",
      "type": "object",
      "required": [
        "type"
      ],
      "properties": {
        "description": {
          "description": "Description of this field",
          "type": [
            "string",
            "null"
          ]
        },
        "type": {
          "description": "The type of this field",
          "allOf": [
            {
              "$ref": "#/definitions/Type"
            }
          ]
        },
        "arguments": {
          "description": "The arguments available to the field - Matches implementation from CollectionInfo",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        }
      }
    },
    "ObjectType": {
      "title": "Object Type",
      "description": "The definition of an object type",
      "type": "object",
      "required": [
        "fields",
        "foreign_keys"
      ],
      "properties": {
        "description": {
          "description": "Description of this type",
          "type": [
            "string",
            "null"
          ]
        },
        "fields": {
          "description": "Fields defined on this object type",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ObjectField"
          }
        },
        "foreign_keys": {
          "description": "Any foreign keys defined for this object type's columns",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ForeignKeyConstraint"
          }
        }
      }
    },
    "ProcedureInfo": {
      "title": "Procedure Info",
      "type": "object",
      "required": [
        "arguments",
        "name",
        "result_type"
      ],
      "properties": {
        "name": {
          "description": "The name of the procedure",
          "type": "string"
        },
        "description": {
          "description": "Column description",
          "type": [
            "string",
            "null"
          ]
        },
        "arguments": {
          "description": "Any arguments that this collection requires",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        },
        "result_type": {
          "description": "The name of the result type",
          "allOf": [
            {
              "$ref": "#/definitions/Type"
            }
          ]
        }
      }
    },
    "QueryCapabilitiesSchemaInfo": {
      "title": "Query Capabilities Schema Info",
      "type": "object",
      "properties": {
        "aggregates": {
          "description": "Schema information relevant to aggregate query capabilities",
          "anyOf": [
            {
              "$ref": "#/definitions/AggregateCapabilitiesSchemaInfo"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "RelationalMutationInfo": {
      "title": "Relational Mutation Info",
      "type": "object",
      "required": [
        "deletable",
        "insertable",
        "updatable"
      ],
      "properties": {
        "insertable": {
          "description": "Whether inserts are supported for this collection",
          "type": "boolean"
        },
        "updatable": {
          "description": "Whether updates are supported for this collection",
          "type": "boolean"
        },
        "deletable": {
          "description": "Whether deletes are supported for this collection",
          "type": "boolean"
        }
      }
    },
    "RequestLevelArguments": {
      "title": "Request Level Arguments",
      "type": "object",
      "required": [
        "mutation_arguments",
        "query_arguments",
        "relational_query_arguments"
      ],
      "properties": {
        "query_arguments": {
          "description": "Any arguments that all Query requests require",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        },
        "mutation_arguments": {
          "description": "Any arguments that all Mutation requests require",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        },
        "relational_query_arguments": {
          "description": "Any arguments that all Relational Query requests require",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ArgumentInfo"
          }
        }
      }
    },
    "ScalarType": {
      "title": "Scalar Type",
      "description": "The definition of a scalar type, i.e. types that can be used as the types of columns.",
      "type": "object",
      "required": [
        "aggregate_functions",
        "comparison_operators",
        "representation"
      ],
      "properties": {
        "representation": {
          "description": "A description of valid values for this scalar type.",
          "allOf": [
            {
              "$ref": "#/definitions/TypeRepresentation"
            }
          ]
        },
        "aggregate_functions": {
          "description": "A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/AggregateFunctionDefinition"
          }
        },
        "comparison_operators": {
          "description": "A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ComparisonOperatorDefinition"
          }
        },
        "extraction_functions": {
          "description": "A map from extraction function names to their definitions.",
          "default": {},
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/ExtractionFunctionDefinition"
          }
        }
      }
    },
    "Type": {
      "title": "Type",
      "description": "Types track the valid representations of values as JSON",
      "oneOf": [
        {
          "description": "A named type",
          "type": "object",
          "required": [
            "name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "named"
              ]
            },
            "name": {
              "description": "The name can refer to a scalar or object type",
              "type": "string"
            }
          }
        },
        {
          "description": "A nullable type",
          "type": "object",
          "required": [
            "type",
            "underlying_type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "nullable"
              ]
            },
            "underlying_type": {
              "description": "The type of the non-null inhabitants of this type",
              "allOf": [
                {
                  "$ref": "#/definitions/Type"
                }
              ]
            }
          }
        },
        {
          "description": "An array type",
          "type": "object",
          "required": [
            "element_type",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "array"
              ]
            },
            "element_type": {
              "description": "The type of the elements of the array",
              "allOf": [
                {
                  "$ref": "#/definitions/Type"
                }
              ]
            }
          }
        },
        {
          "description": "A predicate type for a given object type",
          "type": "object",
          "required": [
            "object_type_name",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "predicate"
              ]
            },
            "object_type_name": {
              "description": "The object type name",
              "type": "string"
            }
          }
        }
      ]
    },
    "TypeRepresentation": {
      "title": "Type Representation",
      "description": "Representations of scalar types",
      "oneOf": [
        {
          "description": "JSON booleans",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "boolean"
              ]
            }
          }
        },
        {
          "description": "Any JSON string",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "string"
              ]
            }
          }
        },
        {
          "description": "A 8-bit signed integer with a minimum value of -2^7 and a maximum value of 2^7 - 1",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "int8"
              ]
            }
          }
        },
        {
          "description": "A 16-bit signed integer with a minimum value of -2^15 and a maximum value of 2^15 - 1",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "int16"
              ]
            }
          }
        },
        {
          "description": "A 32-bit signed integer with a minimum value of -2^31 and a maximum value of 2^31 - 1",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "int32"
              ]
            }
          }
        },
        {
          "description": "A 64-bit signed integer with a minimum value of -2^63 and a maximum value of 2^63 - 1",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "int64"
              ]
            }
          }
        },
        {
          "description": "An IEEE-754 single-precision floating-point number",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "float32"
              ]
            }
          }
        },
        {
          "description": "An IEEE-754 double-precision floating-point number",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "float64"
              ]
            }
          }
        },
        {
          "description": "Arbitrary-precision integer string",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "biginteger"
              ]
            }
          }
        },
        {
          "description": "Arbitrary-precision decimal string",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "bigdecimal"
              ]
            }
          }
        },
        {
          "description": "UUID string (8-4-4-4-12)",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "uuid"
              ]
            }
          }
        },
        {
          "description": "ISO 8601 date",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "date"
              ]
            }
          }
        },
        {
          "description": "ISO 8601 timestamp",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "timestamp"
              ]
            }
          }
        },
        {
          "description": "ISO 8601 timestamp-with-timezone",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "timestamptz"
              ]
            }
          }
        },
        {
          "description": "GeoJSON, per RFC 7946",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "geography"
              ]
            }
          }
        },
        {
          "description": "GeoJSON Geometry object, per RFC 7946",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "geometry"
              ]
            }
          }
        },
        {
          "description": "Base64-encoded bytes",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "bytes"
              ]
            }
          }
        },
        {
          "description": "Arbitrary JSON",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "json"
              ]
            }
          }
        },
        {
          "description": "One of the specified string values",
          "type": "object",
          "required": [
            "one_of",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "enum"
              ]
            },
            "one_of": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        }
      ]
    },
    "UniquenessConstraint": {
      "title": "Uniqueness Constraint",
      "type": "object",
      "required": [
        "unique_columns"
      ],
      "properties": {
        "unique_columns": {
          "description": "A list of columns which this constraint requires to be unique",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    }
  }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
